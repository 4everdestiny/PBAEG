"""
author : 4everdestiny
create_time : 2022.3.4
description : this is the code to check the payload generated
1. run a local process to check this payload
input : payload
output : the payload is valid or invalid
"""
import angr
import pwn
from log import log
from exploit_generation.ROPGeneration import ROPGeneration
from exploit_check.ExploitGenerateFile import ExploitGenerateFile
import os
log = log.Log()


class ExploitCheckLocal:
    def __init__(self, binarypath):
        self.binarypath = binarypath
        os.system("chmod +x {binarypath}".format(binarypath=self.binarypath))
        self.argv = []
        self.mips_argv = []

    def CheckPayload(self, payloadlist, write_payload=True,
                     change_file_path=False, index=0, state=None):
        try:
            payload_is_ok = self.CheckPayloadNewProcess(payloadlist=payloadlist, state=state)
        except:
            log.Exception("payload has some error, but we need to write the payload in file")
            payload_is_ok = False
        if write_payload:
            if not change_file_path:
                egf = ExploitGenerateFile(
                    binarypath=self.binarypath, payloadlist=payloadlist,
                )
            else:
                if payload_is_ok:
                    egf = ExploitGenerateFile(
                        binarypath=self.binarypath, payloadlist=payloadlist,
                        filepath=self.binarypath + "_success" + str(index) + ".py",
                        argv=self.argv, mips_argv=self.mips_argv
                    )
                else:
                    egf = ExploitGenerateFile(
                        binarypath=self.binarypath, payloadlist=payloadlist,
                        filepath=self.binarypath + "_fail" + str(index) + ".py",
                        argv=self.argv, mips_argv=self.mips_argv
                    )
            egf.WriteFile()
        return payload_is_ok

    def GetSymbolicStringLength(self, state, address):
        """
        return the string's symbolic length from this address,
        according to the state
        :param state: the current state
        :param address: the address of the string
        :return: the string length for the symbolic length
        """
        max_length = 0x500
        length = 0
        for i in range(max_length):
            char_sym = state.mem[address + i].uint8_t.resolved
            if char_sym.symbolic:
                length += 1
            else:
                return length
        return length

    def HandlerMipsProcess(self, state=None):
        """
        handle the mips process launcher
        :return: the process by mips
        """
        bits = state.arch.bits
        if "el" in state.arch.qemu_name:
            endian = "little"
        else:
            endian = "big"
        if bits == 32 and endian == "little":
            qemu_name = "qemu-mipsel"
            ld_path = "/usr/mipsel-linux-gnu/"
        elif bits == 32 and endian == "big":
            qemu_name = "qemu-mips"
            ld_path = "/usr/mips-linux-gnu/"
        elif bits == 64 and endian == "little":
            qemu_name = "qemu-mips64el"
            ld_path = "/usr/mips64el-linux-gnuabi64/"
        elif bits == 64 and endian == "big":
            qemu_name = "qemu-mips64"
            ld_path = "/usr/mips64-linux-gnuabi64/"
        else:
            log.Exception("architecture error in HandlerMipsProcess")
            return None
        argv = [qemu_name, "-L", ld_path, self.binarypath]
        debug_argv = [qemu_name, "-g", "1234", "-L", ld_path, self.binarypath]
        self.mips_argv = [argv, debug_argv]
        process = pwn.process(argv)
        return process

    def HandlerArmProcess(self, state=None):
        """
        handle the arm process launcher
        :return: the process by arm
        """
        bits = state.arch.bits
        if "EL" in state.arch.name:
            endian = "little"
        else:
            endian = "big"
        if bits == 32 and endian == "little":
            qemu_name = "qemu-arm"
            ld_path = "/usr/arm-linux-gnueabi/"
        elif bits == 32 and endian == "big":
            qemu_name = "qemu-armeb"
            ld_path = "/usr/mips-linux-gnu/"
        elif bits == 64 and endian == "little":
            qemu_name = "qemu-aarch64"
            ld_path = "/usr/aarch64-linux-gnu/"
        elif bits == 64 and endian == "big":
            qemu_name = "qemu-aarch64eb"
            ld_path = "/usr/mips64-linux-gnuabi64/"
        else:
            log.Exception("architecture error in HandlerArmProcess")
            return None
        argv = [qemu_name, "-L", ld_path, self.binarypath]
        debug_argv = [qemu_name, "-g", "1234", "-L", ld_path, self.binarypath]
        self.mips_argv = [argv, debug_argv]
        process = pwn.process(argv)
        return process

    def GetProcessWithArgv(self, payloadlist, state=None):
        """
        sometimes we have some payload in argv, so we need to
        generate a process having argv
        :param payloadlist: the payloadlist
        :param state: the current state
        :return: process
        """
        if state is None:
            p = pwn.process(self.binarypath)
            return p
        if state.arch.name == "MIPS32":
            return self.HandlerMipsProcess(state=state)
        if state.arch.name == "ARMEL":
            return self.HandlerArmProcess(state=state)
        argc = state.solver.eval(state.posix.argc)
        if argc == 1:
            p = pwn.process(self.binarypath)
            return p
        else:
            real_argv = []
            argv_addr = state.solver.eval(state.posix.argv)
            for i in range(argc):
                find_payload = False
                for singlepayload in payloadlist.GetList():
                    if singlepayload.inargv:
                        if singlepayload.argv_index == i:
                            if not singlepayload.CheckStaticPayload():
                                log.Exception("payload in argv must be static")
                                return None
                            real_argv.append(singlepayload.GetPayload())
                            find_payload = True
                if find_payload:
                    continue
                argvi_addr = state.mem[argv_addr + i * 4].uint32_t.resolved
                symbolic_length = self.GetSymbolicStringLength(state, address=argvi_addr)
                if symbolic_length == 0:
                    argvi_sym = state.mem[argvi_addr].string.resolved
                    argv_bytes = state.solver.eval(argvi_sym, cast_to=bytes)
                else:
                    argvi_sym = state.memory.load(argvi_addr, symbolic_length)
                    argv_bytes = state.solver.eval(argvi_sym, cast_to=bytes)
                real_argv.append(argv_bytes)
                self.argv = real_argv
            p = pwn.process(real_argv)
            return p

    def GenerateFile(self, payloadlist=None):
        """
        parse the file needed in exploit
        :param payloadlist: the payloadlist
        :return: None
        """
        dir = ""
        for i in range(len(self.binarypath) - 1, -1, -1):
            if self.binarypath[i] == "/":
                dir = self.binarypath[:i]
                break
        deletefile = True
        for singlepayload in payloadlist.GetList():
            if singlepayload.infile:
                filepath = dir + "/" + singlepayload.file_name.decode()
                if os.path.isfile(filepath) and deletefile:
                    os.remove(filepath)
                    deletefile = False
                with open(filepath, "ab") as f:
                    if singlepayload.CheckStaticPayload():
                        f.write(singlepayload.GetPayload())
                    f.close()

    def CheckPayloadNewProcess(self, payloadlist=None, state=None):
        """
        check the payload is ok, or not ok by new process
        :param payloadlist: the payloadlist for the exploit
        :param state: the current state
        :return: True when success, False when not
        """
        check_info = "hacked_by_Lancet"
        test_command = "echo {info}".format(info=check_info)
        pwn.context.log_level = "debug"
        pwn.context.timeout = 3

        self.GenerateFile(payloadlist=payloadlist)

        try:
            p = self.GetProcessWithArgv(payloadlist=payloadlist, state=state)
            # p = pwn.process(self.binarypath)
            # pwn.gdb.attach(p)
            process = payloadlist.CheckPayloadWithProcess(process=p)
            p.sendline(test_command)
            info = p.recvuntil(check_info)
            p.close()
            if check_info in info.decode():
                return True
            else:
                return False
        except:
            p.close()
            log.Exception("payload has some error, please check it")
            return False

    def WritePayloadFile(self, payload):
        final_payload = """
import pwn

pwn.context.timeout = 3
pwn.context.log_level = "debug"
p = pwn.process("{binarypath}")
pwn.gdb.attach(p)
p.send({payload})
p.interactive()
        """.format(binarypath=self.binarypath, payload=str(payload))
        with open("./exploit_generated_temp.py", "w") as f:
            f.write(final_payload)


if __name__ == '__main__':
    # have tested:
    # ../binaries/stack_overflow/static/test1/level1_test1
    # ../binaries/stack_overflow/static/test2/level1_test2
    # ../binaries/stack_overflow/static/test3/level1_test3
    # ../binaries/stack_overflow/static/test4/level1_test4
    # ../binaries/stack_overflow/dynamic/test1/dynamic_test1
    # ../binaries/stack_overflow/dynamic/test2/dynamic_test2
    # ../binaries/stack_overflow/dynamic/test2/dynamic_test2
    # ../binaries/stack_overflow/dynamic/test3/dynamic_test3
    # ../binaries/stack_overflow/dynamic/test4/dynamic_test4
    binarypath = "../binaries/stack_overflow/dynamic/test4/dynamic_test4"
    ROPGeneration = ROPGeneration(binarypath, needlength=0x100, prefixlength=0x18)
    ExploitCheckLocal = ExploitCheckLocal(binarypath)
    # payload = b"a" * 0x18
    # payload += ROPGeneration.GeneratePayload().GetContent()
    payload = ROPGeneration.GeneratePayload()
    result = ExploitCheckLocal.CheckPayload(payload, write_payload=True)
    print(result)