"""
author : 4everdestiny
create_time : 2022.12.14
description : this is the code to collect the gadgets information find
input : binary path
output : generally return the gadget information
"""

from exploit_generation.ProtectionInformation import ProtectionInformation
from exploit_generation.GadgetInfo import GadgetInfo
import ropper
from log.log import Log
import re
import subprocess

log = Log()


class GadgetsFind:
    def __init__(self, binarypath, avoidchars=b"\n"):
        self.binarypath = binarypath
        self.avoidchars = avoidchars
        protection = ProtectionInformation(self.binarypath).GetProtection()
        self.canary = protection["Canary"]
        self.NX = protection["NX"]
        self.PIE = protection["PIE"]
        self.static = protection["static"]
        self.arch = protection["arch"]
        self.roppersevice = ropper.RopperService()
        self.LoadRopper()
        # for ROPgadget
        self.ROPgadgets = []
        self.ROPgadgets_pop = []
        self.InitROPgadget()

    def InitRopperOptions(self):
        self.roppersevice.options.all = True
        self.roppersevice.options.badbytes = self.avoidchars.hex()
        self.roppersevice.options.color = False
        self.roppersevice.options.inst_count = 10

    def LoadRopper(self):
        self.InitRopperOptions()
        self.roppersevice.addFile(self.binarypath)
        if self.arch == "amd64":
            architecture = "x86_64"
        elif self.arch == "i386":
            architecture = "x86"
        elif self.arch == "mips":
            architecture = "MIPS"
        elif self.arch == "arm":
            architecture = "ARM"
        else:
            architecture = self.arch
        self.roppersevice.setArchitectureFor(name=self.binarypath, arch=architecture)
        self.roppersevice.loadGadgetsFor(name=self.binarypath)

    def InitROPgadget(self):
        """
        init to get all the information in ROPgadget
        :return: True when success, False when failed
        """
        if not self.GetROPGadgetInfo(gadgets_type="pop"):
            return False
        if not self.GetROPGadgetInfo(gadgets_type="all"):
            return False
        return True

    def FindJmpGadget(self, register="rsp"):
        """
        find jump register gadget, especially for jmp rsp gadget
        :param register: the jmp gadget target register
        :return: None if no gadget found, otherwise the struct of the gadget
        """
        instruction = "jmp {register}".format(register=register)
        result = self.roppersevice.search(search=instruction, name=self.binarypath)
        try:
            file, gadget = next(result)
            return gadget
        except:
            # print("here")
            gadget = self.FindInstructionInROPgadget(instruction=instruction)
            if gadget is not None:
                return gadget
            log.Exception("not found for {instruction}".format(instruction=instruction))
            return None

    def FindPopNumberGadget(self, number=3, avoid_registers=[]):
        """
        according to the number of pop, for example
        if number = 3:
        pop eax, pop ebx, pop ecx, ret
        if number = 2:
        pop eax, pop ebx ret
        :param number: the number of pop
        :param avoid_registers: the registers you don't want to afftect in this gadget
        :return: the gadget find, if not, return None
        """
        result = self.roppersevice.search(
            search="pop ???", name=self.binarypath)
        while True:
            try:
                file, gadget = next(result)
                if len(gadget.lines) != number + 1:
                    continue
                find_flag = True
                for gadget_info in gadget.lines:
                    if "pop" not in gadget_info[1] and "ret" not in gadget_info[1]:
                        find_flag = False
                        break
                if find_flag:
                    if self.arch == "amd64":
                        if "rsp" not in gadget.affected_regs:
                            if self.GetIfAffected(gadget=gadget,
                                                  avoid_registers=avoid_registers):
                               continue
                            return gadget
                    elif self.arch == "i386":
                        if "esp" not in gadget.affected_regs:
                            if self.GetIfAffected(gadget=gadget,
                                                  avoid_registers=avoid_registers):
                                continue
                            return gadget
                    else:
                        pass
            except:
                gadget = self.FindPopNumberGadgetInROPgadget(
                    number=number, avoid_registers=avoid_registers)
                if gadget is not None:
                    return gadget
                log.Exception("not found for pop number:{number}".format(number=number))
                return None

    def DeepFindPopGadget(self, register="rsp", avoid_registers=None):
        """
        find pop register gadget,
        when cannot find the pop single register gadget, use this function
        to find pop two registers gadget
        for example: pop rsi, r15, ret (pop ... ret)
        :param register: register, the gadget which want to contain this register
        :param avoid_registers: the registers avoid
        :return: the gadget struct
        """
        popgadgets = self.roppersevice.searchPopPopRet(name=self.binarypath)
        for file, gadgets in popgadgets.items():
            for gadget in gadgets:
                # print(gadget.affected_regs)
                # never change rsp's value
                if self.arch == "amd64":
                    if register in gadget.affected_regs and "rsp" not in gadget.affected_regs:
                        if self.GetIfAffected(gadget=gadget,
                                              avoid_registers=avoid_registers):
                            continue
                        return gadget
                elif self.arch == "i386":
                    if register in gadget.affected_regs and "esp" not in gadget.affected_regs:
                        if self.GetIfAffected(gadget=gadget,
                                              avoid_registers=avoid_registers):
                            continue
                        return gadget
        return None

    def FindPopGadget(self, register="rsp", avoid_registers=None):
        """
        find pop register gadget,
        for example: pop rdi; ret
        :param register: the pop gadget target register
        :param avoid_registers: the register avoid
        :return: None if no gadget found, otherwise the struct of the gadget
        """
        instruction = "pop {register};ret".format(register=register)
        result = self.roppersevice.searchInstructions(code=instruction, name=self.binarypath)
        try:
            gadget = result[self.binarypath][0]
            return gadget
        except:
            gadget = self.FindPopGadgetInROPgadget(register=register, avoid_registers=avoid_registers)
            if gadget is not None:
                return gadget
            gadget = self.DeepFindPopGadget(register=register, avoid_registers=avoid_registers)
            if gadget is not None:
                return gadget
            log.info("not found for {instruction}, try to check the avoid registers".format(instruction=instruction))
            return None

    def FindInstructionGadget(self, instruction="ret"):
        """
        find ret instruction gadget
        :return: None if cannot find, otherwise the struct of gadget
        """
        result = self.roppersevice.searchInstructions(code=instruction, name=self.binarypath)
        try:
            gadget = result[self.binarypath][0]
            return gadget
        except:
            gadget = self.FindInstructionInROPgadget(instruction=instruction)
            if gadget is not None:
                return gadget
            log.Exception("not found for {instruction}".format(instruction=instruction))
            return None

    def GetGadgetAffectedRegisters(self, gadget=None):
        """
        return the list of affect registers
        :param gadget: the gadget struct which you want to get
        :return: the list of affected registers
        """
        if gadget is not None:
            if hasattr(gadget, "gadget_source"):
                return gadget.affected_regs
            instruction = gadget.simpleInstructionString()
            if self.arch == "amd64":
                affected_regs = re.findall("r[a-z0-9]{2}", instruction)
                return affected_regs[:-1]
            elif self.arch == "i386":
                affected_regs = re.findall("e[a-z]{2}", instruction)
                return affected_regs
            else:
                affected_regs = None
                return affected_regs
        else:
            log.Exception("gadget is None, please check the code")
            return None

    def GetIfAffected(self, gadget=None, avoid_registers=None):
        """
        get the information if the register is in avoid_registers
        :param gadget: the gadget you want to use
        :param avoid_registers: the registers you want to avoid
        :return:
        """
        if gadget is None:
            log.Exception("the gadget is None, please check it")
            return True
        if avoid_registers is None:
            # log.Exception("the avoid_registers is None, please check it")
            return False
        afftected_registers = self.GetGadgetAffectedRegisters(gadget=gadget)
        for af_reg in afftected_registers:
            if af_reg in avoid_registers:
                return True
        return False

    def GetROPGadgetInfo(self, gadgets_type="pop"):
        """
        here we use ropgadget to find some gadget, because sometime we
        cannot find correct gadgets in ropper
        :return: True when successfully get, False when not
        """
        if gadgets_type == "pop":
            command = "ROPgadget --binary {binarypath} --only 'pop|ret'".format(
                binarypath=self.binarypath)
        else:
            command = "ROPgadget --binary {binarypath}".format(
                binarypath=self.binarypath)
        try:
            ret = subprocess.run(
                command, shell=True, stdout=subprocess.PIPE,
                stderr=subprocess.PIPE, encoding="utf-8", timeout=30)
        except:
            log.Exception("cannot use ROPgagdet to get the gadgets in this binary")
            return False
        # print(ret.stdout)
        lines = ret.stdout.split("\n")
        for gadget in lines:
            match = re.search("0x[0-9a-f]+", gadget)
            if match is None:
                continue
            address = int(match.group(0), 16)
            instructions = gadget.split(":")[1]
            if "ret " in instructions:
                continue
                # because we don;t need ret 0xffffc like ROPgadget
            instructions = instructions.split(";")
            for i in range(len(instructions)):
                instructions[i] = instructions[i].strip(" ")
            gadgetinfo = GadgetInfo(
                address=address, instructions=instructions, _type=gadgets_type)
            if gadgets_type == "pop":
                self.ROPgadgets_pop.append(gadgetinfo)
            elif gadgets_type == "all":
                self.ROPgadgets.append(gadgetinfo)
            else:
                log.Exception("don't know the need type, please check it")
            """
                        Gadgets information
            ============================================================
            0x000000000040074c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
            ...
            0x0000000000400506 : ret

            Unique gadgets found: 11
            """
        return True

    def FindInstructionInROPgadget(self, instruction):
        """
        find an instruction in ROPgadgets
        :param gadget: the instruction which you want to get
        :return: the gadget find
        """
        if ";" in instruction:
            instruction_list = instruction.split(";")
            for i in range(len(instruction_list)):
                instruction_list[i] = instruction_list[i].strip()
            instruction = instruction_list
        if type(instruction) == str:
            instruction = [instruction]
        for gadget in self.ROPgadgets:
            if gadget.compare(instruction):
                return gadget
        return None

    def FindPopNumberGadgetInROPgadget(self, number=3, avoid_registers=None):
        """
        according to the number of pop, for example
        if number = 3:
        pop eax, pop ebx, pop ecx, ret
        if number = 2:
        pop eax, pop ebx ret
        :param number: the number of pop
        :param avoid_registers: the registers you don't want to see in this gadget
        :return: the gadget find, if not, return None
        """
        for gadget in self.ROPgadgets_pop:
            instructions = gadget.instructions
            if len(instructions) == number + 1:
                continue
            for i in range(len(instructions) - 1):
                if "pop" not in instructions[i]:
                    continue
            if "ret" not in instructions[-1]:
                continue
            if self.arch == "amd64":
                if "rsp" not in gadget.affected_regs:
                    if self.GetIfAffected(
                            gadget=gadget, avoid_registers=avoid_registers):
                        continue
                    return gadget
            elif self.arch == "i386":
                if "esp" not in gadget.affected_regs:
                    if self.GetIfAffected(
                            gadget=gadget, avoid_registers=avoid_registers):
                        continue
                    return gadget
            else:
                pass
        return None

    def FindPopGadgetInROPgadget(self, register="rsp", avoid_registers=None):
        """
        find the gadget which can control the register
        :param register: the register you want to control
        :param avoid_registers: the register avoid
        :return: the gadget
        """
        # optimize: best, we need to find a single pop gagdget
        min_length = 100
        best_gadget = None
        for gadget in self.ROPgadgets_pop:
            for instruction in gadget.instructions:
                if register in instruction:
                    if self.GetIfAffected(gadget=gadget,
                                          avoid_registers=avoid_registers):
                        continue
                    if len(gadget.instructions) < min_length:
                        best_gadget = gadget
                        min_length = len(gadget.instructions)
        return best_gadget


if __name__ == '__main__':
    binarypath = "../binaries/64bit/stack_overflow/dynamic/test4/dynamic_test4"
    GadgetsFind = GadgetsFind(binarypath, avoidchars="")
    gadget = GadgetsFind.FindPopGadget(register="rsp")
    print(GadgetsFind.GetGadgetAffectedRegisters(gadget=gadget))
    #print(payload.GetList()[0])
