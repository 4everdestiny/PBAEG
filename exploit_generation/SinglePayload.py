"""
author : 4everdestiny
create_time : 2022.3.9
description : this is the code to generate a single payload
in different scenes, we need different payload, for example:
1. read(0, &buf, 0x100), we need a 0x100 length payload
2. gets(&buf), we need a \n in the payload
3. strcpy(&buf, &name), avoid chars is \n
4. scanf("%s", &name), avoid chars are
5. also we need some prefix in stackoverflow vulnerability
6. also we need some recv information after send payload
input : payload need option
output : the final payload
"""

from log import log
from pwn import p64, p32
from exploit_generation.RecvInfo import RecvInfo
log = log.Log()


class SinglePayload:
    def __init__(self, content=None, length=0x10, needline=False,
                 avoidchars=b"", prefixlength=0
                 ):
        """
        init function
        :param content: content for the original payload you want
        :param length: length for the length of payload you want
        :param needline: if you need \n in the end of payload, this is True
        :param avoidchars: in gets function, avoidchars is "\n", etc.
        :param prefixlength: prefix for the offset of payload, especially used if stack overflow
        """
        if content is None:
            content = []
        self.length = length
        self.needline = needline
        self.content = content
        self.avoidchars = avoidchars
        self.payload = b""
        # prefix length is used in stack overflow vulnerability
        # for the offseet used in payload
        self.prefixlength = prefixlength
        # for the recv info payload
        self.needadjust = False
        self.needadjustdict = {"heap_base": [], "libc_base": [], "elf_base": [], "canary": []}
        self.adjustinfolist = ["heap_base", "libc_base", "elf_base", "canary"]
        self.baseaddressdict = {"heap_base": 0, "libc_base": 0, "elf_base": 0, "canary": 0}
        self.recvtypes = ["heap_base", "libc_base", "elf_base", "canary"]
        self.needrecv = False
        self.recvinfo = []
        self.ParseAdjustInfo()
        self.inargv = False
        self.argv_index = 0
        self.infile = False
        self.file_name = b""
        # maybe need need prefix and recv options

    def PlacePayloadInArgv(self, argv_index=0):
        """
        sometimes, the payload might be in the argv, so we need to place
        the payload into argv
        :param argv_index: the index for the argv
        :return: True when success, False when not
        """
        if not self.CheckStaticPayload():
            log.Exception("the payload in argv must be static")
            return False
        self.argv_index = argv_index
        self.inargv = True

    def PlacePayloadInFile(self, file_name=b""):
        """
        sometimes, the payload might be in the file, so we need to place
        the payload into file
        :param file_path: the path for the file
        :return: True when success, False when not
        """
        if not self.CheckStaticPayload():
            log.Exception("the payload in file must be static")
            return False
        self.file_name = file_name
        self.infile = True

    def ParseAdjustInfo(self):
        """
        this function is used to parse all the info needed in this payload
        for example, if the payload is like this:
        [(elf_base, 0x1000)]
        :return:
        """
        # need remove all the information first
        self.needadjustdict = {"heap_base": [], "libc_base": [], "elf_base": [], "canary": []}
        for index in range(len(self.content)):
            payloadelement = self.content[index]
            adjustinfo = payloadelement.adjustinfo
            if adjustinfo in self.adjustinfolist:
                self.needadjustdict[adjustinfo].append(index)
                if not self.needadjust:
                    self.needadjust = True

    def GeneratePayload(self):
        """
        this function is used to generate the payload according to the options
        :return: True when generate successfully, False when not
        """
        self.ParseAdjustInfo()
        self.payload = b""
        if self.prefixlength != 0:
            if b"\x00" not in self.avoidchars:
                self.payload += b"\x00" * self.prefixlength
            else:
                self.payload += b"a" * self.prefixlength
        if self.needadjust:
            if not self.AdjustContent():
                log.Exception("need some base info first")
                return False
        for payloadelement in self.content:
            if payloadelement.datatype == "int64":
                self.payload += p64(payloadelement.datavalue)
            elif payloadelement.datatype == "int32":
                self.payload += p32(payloadelement.datavalue)
            elif payloadelement.datatype == "bytes":
                self.payload += payloadelement.datavalue
        if self.length == 0:
            # self.length == 0 means we are in gets function, which can write gigantic length
            # or sometime the length does not matter
            pass
        elif len(self.payload) < self.length:
            if b"\x00" not in self.avoidchars:
                self.payload = self.payload.ljust(self.length, b"\x00")
            else:
                self.payload = self.payload.ljust(self.length, b"a")
        elif len(self.payload) == self.length:
            pass
        else:
            log.Exception("the payload's length is longer than excepted, may cause some error")
            return False
        if self.needline:
            self.payload += b"\n"
        if self.CheckPayload():
            return True
        else:
            log.Exception("there are some avoid chars in payload, please check it")
            return False

    def GetPayload(self):
        """
        return self.payload
        :return: the final payload
        """
        if not self.GeneratePayload():
            log.Exception("error when generate payload")
            return None
        self.RemoveRemainedInfo()
        return self.payload

    def GenerateTempPayloadForCheck(self):
        """
        sometimes we need to generate a payload for check
        but sometimes have elf_base, libc_base adjust
        so we need to find a way to check the avoid chars in the original payload
        :return: the temp payload generate
        """
        temp_payload = b""
        for payloadelement in self.content:
            if payloadelement.adjustinfo is None or payloadelement.adjustinfo == "canary":
                if payloadelement.datatype == "int64":
                    temp_payload += p64(payloadelement.datavalue)
                elif payloadelement.datatype == "int32":
                    temp_payload += p32(payloadelement.datavalue)
                elif payloadelement.datatype == "bytes":
                    temp_payload += payloadelement.datavalue
            else:
                # here we only leave the lowest byte for check
                if payloadelement.datatype == "int64":
                    temp_payload += p64(payloadelement.datavalue)[0].to_bytes(length=1, byteorder="little")
                elif payloadelement.datatype == "int32":
                    temp_payload += p32(payloadelement.datavalue)[0].to_bytes(length=1, byteorder="little")
                elif payloadelement.datatype == "bytes":
                    # bytes cannot be adjust, this branch has no meaning
                    temp_payload += payloadelement.datavalue
        return temp_payload

    def BeforeAdjustCheck(self):
        """
        before adjust do a pre-check, so we can choose which method to use
        :return: True when check pass, False when failed
        """
        temp_payload = self.GenerateTempPayloadForCheck()
        for x in self.avoidchars:
            if x in temp_payload:
                # log.Exception("find avoid char in this payload, please check it")
                return False
        return True

    def CheckPayload(self):
        """
        this function
        :param payload:
        :return:
        """
        for x in self.avoidchars:
            if x in self.payload:
                # log.Exception("find avoid char in this payload, please check it")
                if x == 10 and self.needline:
                    if x not in self.payload[:-1]:
                        continue
                return False
        return True

    def GetContent(self):
        """
        get the content of payload
        :return: the content of payload
        """
        return self.content

    def CheckBaseInfo(self):
        """
        check all the base info needed
        :return: True when pass check, False when not pass
        """
        for base in self.adjustinfolist:
            if len(self.needadjustdict[base]) != 0 and self.baseaddressdict[base] == 0:
                log.Exception(f"need {base} first, check it")
                return False
        return True

    def CheckStaticPayload(self):
        """
        check if the payload is static
        :return: True when pass check, False when not pass
        """
        for base in self.adjustinfolist:
            if len(self.needadjustdict[base]) != 0 and self.baseaddressdict[base] == 0:
                return False
        return True

    def AdjustContent(self):
        """
        if some payload need base info, here we should use these base info
        to adjust payload
        :return: True when check base info success, False some thing error
        """
        if not self.CheckBaseInfo():
            log.Exception("need some base info frist")
            return False
        else:
            # here we need a list type content
            for base in self.adjustinfolist:
                for index in self.needadjustdict[base]:
                    payloadelement = self.content[index]
                    payloadelement.datavalue += self.baseaddressdict[base]
            self.needadjust = False
            return True

    def ReverseAdjustContent(self):
        """
        after we have generated a payload, we need to remove the
        information remained in the payload element
        :return:
        """
        if not self.CheckBaseInfo():
            log.Exception("need some base info frist")
            return False
        else:
            # here we need a list type content
            for base in self.adjustinfolist:
                for index in self.needadjustdict[base]:
                    payloadelement = self.content[index]
                    payloadelement.datavalue -= self.baseaddressdict[base]
            return True

    def AddRecvInfo(self, type="heap_base", recv_index=[0, 6], func="u64", adjustoffset=0):
        """
        add the recv info to the payload
        :param type: heapbase or libc_base or elf_base
        :param recv_index: the index of the recv information
        :param func: u64, int, u32, etc.
        :return: None
        """
        self.needrecv = True
        recv_types = self.adjustinfolist
        func_types = ["u64", "int16", "u32", "bytes"]
        if type in recv_types:
            if func in func_types:
                self.recvinfo.append(RecvInfo(
                    type=type, index=recv_index, func=func, adjustoffset=adjustoffset
                ))
            else:
                log.Exception("not found type in funcs, check the code")
        else:
            if type == "string":
                self.recvinfo.append(RecvInfo(
                    type=type, index=recv_index, func=func, adjustoffset=adjustoffset
                ))
            else:
                log.Exception("not found type in recv_types, check the code")

    def ChangeBases(self, basetype="heap_base", basevalue=0):
        """
        change the bases info in payload
        :return: True when successfully change, False when not
        """
        recv_types = self.adjustinfolist
        if basetype not in recv_types:
            log.Exception("not found type, check it")
            return False
        self.baseaddressdict[basetype] = basevalue

    def RemoveBases(self):
        """
        after we have generated a payload, we need to remove the
        bases information remained in this single payload
        :return:
        """
        for adjustinfo in self.adjustinfolist:
            self.baseaddressdict[adjustinfo] = 0

    def GetContentLength(self):
        """
        get the content's length
        :return: return the content's length
        """
        if self.content is None:
            return 0
        sumlength = 0
        for payloadelement in self.content:
            if payloadelement.datatype == "int64":
                sumlength += 8
            elif payloadelement.datatype == "int32":
                sumlength += 4
            elif payloadelement.datatype == "bytes":
                sumlength += len(payloadelement.datavalue)
        return sumlength

    def SetContent(self, content=None, change_length=True):
        """
        set the payload's content, for in format string vulnerability,
        we cannot know the final content,
        we must know canary or code_base or libc_base
        :param change_length: if set True, change the payload
        length using the content's length
        if not, don't change the length
        :return: None
        """
        if content is None:
            content = []
        self.content = content
        if change_length:
            self.length = self.GetContentLength()
        else:
            pass

    def __str___bak(self):
        """
        this function is used for generate a final payload in file
        so if the payload need adjust, we must generate a string like payload
        :return: a string payload
        """
        if not self.needadjust:
            """
            base64_encode_payload = base64.b64encode(self.GetPayload())
            payload = "payload = base64.b64decode({encode_payload})".format(
                encode_payload=base64_encode_payload)
            """
            payload = r"payload = {payload}".format(payload=self.GetPayload())
            return payload
        payload = ""
        if self.prefixlength != 0:
            if b"\x00" not in self.avoidchars:
                payload += "\x00" * self.prefixlength
            else:
                payload += "a" * self.prefixlength
        if self.needadjust:
            if type(self.content) == list:
                for i in range(len(self.content)):
                    if i != 0:
                        payload += " + "
                    needadjust = False
                    for info in self.adjustinfo:
                        if info in self.adjustlist.keys():
                            if i in self.adjustlist[info]:
                                needadjust = True
                                payload += "p64({info} + {value})".format(
                                    info=info, value=hex(self.originalcontent[i]))
                    if not needadjust:
                        payload += "p64({value})".format(value=hex(self.originalcontent[i]))
        if len(payload) < self.length:
            payload = payload.ljust(self.length, "\x00")
        elif len(self.payload) == self.length:
            pass
        else:
            log.Exception("the payload's length is longer than excepted, may cause some error")
        if self.needline:
            payload += "\n"
        final_payload_string = "payload = {payload}\n".format(payload=payload)
        return final_payload_string

    def __str__(self):
        """
        newly __str__ function for print payload
        this function is used for generate a final payload in file
        so if the payload need adjust, we must generate a string like payload
        :return: a payload information for debug
        """
        final_content = "=" * 10 + "single_payload_begin" + "=" * 10 + "\n"
        for i in range(len(self.content)):
            payloadelement = self.content[i]
            content = payloadelement.datavalue
            type_ = payloadelement.datatype
            adjustinfo = payloadelement.adjustinfo
            final_content += f"{i}:{type_}:{adjustinfo}:{content}"
            final_content += "\n"
        final_content += "=" * 10 + "single_payload_end" + "=" * 10 + "\n"
        return final_content

    def GeneratePayloadInFileNoAdjust(self):
        """
        when generate a payload into a file, and no need for the bases
        use this function to generate a payload for a file
        :return: the final payload for this single payload
        """
        if self.needadjust:
            log.Exception("need adjust in fact, maybe some logic error in code")
            return None
        if len(self.content) == 0:
            log.Exception("no content for this single payload, maybe something error here")
            return None
        payload = ""
        for index in range(len(self.content)):
            payloadelement = self.content[index]
            if index == 0:
                if payloadelement.datatype == "int64":
                    payload = r"p64({value})".format(
                        value=hex(payloadelement.datavalue))
                elif payloadelement.datatype == "int32":
                    payload = r"p32({value})".format(
                        value=hex(payloadelement.datavalue))
                elif payloadelement.datatype == "bytes":
                    payload = r"{value}".format(
                        value=payloadelement.datavalue)
            else:
                if payloadelement.datatype == "int64":
                    payload += r" + p64({value})".format(
                        value=hex(payloadelement.datavalue))
                elif payloadelement.datatype == "int32":
                    payload += r" + p32({value})".format(
                        value=hex(payloadelement.datavalue))
                elif payloadelement.datatype == "bytes":
                    payload += r" + {value}".format(
                        value=payloadelement.datavalue)
        if self.GetContentLength() < self.length:
            payload += "\n"
            payload += r'payload = payload.ljust({length}, b"a")'.format(length=self.length)
        if self.needline:
            payload += "\n"
            payload += r'payload += b"\n"'
        return payload

    def GeneratePayloadInFileNeedAdjust(self):
        """
        when generate a payload into a file, and need some bases
        use this function to generate a payload for a file
        :return: the final payload for this single payload
        """
        if not self.needadjust:
            log.Exception("need adjust in fact, maybe some logic error in code")
            return None
        if len(self.content) == 0:
            log.Exception("no content for this single payload, maybe something error here")
            return None
        payload = ""
        for index in range(len(self.content)):
            payloadelement = self.content[index]
            if index == 0:
                if payloadelement.adjustinfo in self.needadjustdict:
                    if payloadelement.datatype == "int64":
                        payload = r"p64({base} + {value})".format(
                            base=payloadelement.adjustinfo, value=hex(payloadelement.datavalue))
                    elif payloadelement.datatype == "int32":
                        payload = r"p32({base} + {value})".format(
                            base=payloadelement.adjustinfo, value=hex(payloadelement.datavalue))
                    elif payloadelement.datatype == "bytes":
                        # no use for this branch, cannot reach
                        log.Exception("enter an unexcepted branch, please check your code")
                        return None
                else:
                    if payloadelement.datatype == "int64":
                        payload = r"p64({value})".format(value=hex(payloadelement.datavalue))
                    elif payloadelement.datatype == "int32":
                        payload = r"p32({value})".format(value=hex(payloadelement.datavalue))
                    elif payloadelement.datatype == "bytes":
                        payload = r"{value}".format(value=payloadelement.datavalue)
            else:
                if payloadelement.adjustinfo in self.needadjustdict:
                    if payloadelement.datatype == "int64":
                        payload += r" + p64({base} + {value})".format(
                            base=payloadelement.adjustinfo, value=hex(payloadelement.datavalue))
                    elif payloadelement.datatype == "int32":
                        payload += r" + p32({base} + {value})".format(
                            base=payloadelement.adjustinfo, value=hex(payloadelement.datavalue))
                    elif payloadelement.datatype == "bytes":
                        # no use for this branch, cannot reach
                        log.Exception("enter an unexcepted branch, please check your code")
                        return None
                else:
                    if payloadelement.datatype == "int64":
                        payload += r" + p64({value})".format(value=hex(payloadelement.datavalue))
                    elif payloadelement.datatype == "int32":
                        payload += r" + p32({value})".format(value=hex(payloadelement.datavalue))
                    elif payloadelement.datatype == "bytes":
                        payload += r" + {value}".format(value=payloadelement.datavalue)
        if self.needline:
            payload += "\n"
            payload += r'payload += b"\n"'
        return payload

    def GeneratePayloadInFileAboutRecv(self):
        """
        generate the content for a payload about the recv information
        :return: the final payload content
        """
        final_payload_content = ""
        for recvinfo in self.recvinfo:
            if type(recvinfo.index[1]) != int:
                if recvinfo.func == "u64":
                    index1 = recvinfo.index[0]
                    index2 = recvinfo.index[1]
                    final_payload_content += r"{info} = u64(p.recvuntil({index2},drop=True)[{index1}:].ljust(8,b'\x00')) + {offset}".format(
                        info=recvinfo.type, index1=index1, index2=index2, offset=hex(recvinfo.adjustoffset)
                    )
                    final_payload_content += "\n"
                    final_payload_content += "pwn.log.success('{info}:' + hex({value}))\n".format(info=recvinfo.type, value=recvinfo.type)
                elif recvinfo.func == "u32":
                    index1 = recvinfo.index[0]
                    index2 = recvinfo.index[1]
                    final_payload_content += r"{info} = u32(p.recvuntil({index2},drop=True)[{index1}:].ljust(8,b'\x00')) + {offset}".format(
                        info=recvinfo.type, index1=index1, index2=index2, offset=hex(recvinfo.adjustoffset)
                    )
                    final_payload_content += "\n"
                    final_payload_content += "pwn.log.success('{info}:' + hex({value}))\n".format(info=recvinfo.type, value=recvinfo.type)
                elif recvinfo.func == "int16":
                    index1 = recvinfo.index[0]
                    index2 = recvinfo.index[1]
                    final_payload_content += r"{info} = int(p.recvuntil({index2}, drop=True)[{index1}:], 16) + {offset}".format(
                        info=recvinfo.type, index1=index1, index2=index2, offset=hex(recvinfo.adjustoffset)
                    )
                    final_payload_content += "\n"
                    final_payload_content += "pwn.log.success('{info}:' + hex({value}))\n".format(info=recvinfo.type,                                                                                      value=recvinfo.type)
                elif recvinfo.func == "bytes":
                    index1 = recvinfo.index[0]
                    index2 = recvinfo.index[1]
                    final_payload_content += r'p.recvuntil({index2})'.format(
                         index2=index2
                    )
                    final_payload_content += "\n"
                else:
                    log.Exception("not found the function")
            else:
                if recvinfo.func == "u64":
                    index1 = recvinfo.index[0]
                    index2 = recvinfo.index[1]
                    final_payload_content += r"{info} = u64(p.recv()[{index1}:{index2}].ljust(8,b'\x00')) + {offset}".format(
                        info=recvinfo.type, index1=index1, index2=index2, offset=hex(recvinfo.adjustoffset)
                    )
                    final_payload_content += "\n"
                    final_payload_content += "pwn.log.success('{info}:' + hex({value}))\n".format(info=recvinfo.type, value=recvinfo.type)
                elif recvinfo.func == "u32":
                    index1 = recvinfo.index[0]
                    index2 = recvinfo.index[1]
                    final_payload_content += r"{info} = u32(p.recv()[{index1}:{index2}].ljust(4,b'\x00')) + {offset}".format(
                        info=recvinfo.type, index1=index1, index2=index2, offset=hex(recvinfo.adjustoffset)
                    )
                    final_payload_content += "\n"
                    final_payload_content += "pwn.log.success('{info}:' + hex({value}))\n".format(info=recvinfo.type, value=recvinfo.type)
                elif recvinfo.func == "int16":
                    index1 = recvinfo.index[0]
                    index2 = recvinfo.index[1]
                    final_payload_content += r"{info} = int(p.recv()[{index1}:{index2}], 16) + {offset}".format(
                        info=recvinfo.type, index1=index1, index2=index2, offset=hex(recvinfo.adjustoffset)
                    )
                    final_payload_content += "\n"
                    final_payload_content += "pwn.log.success('{info}:' + hex({value}))\n".format(info=recvinfo.type,                                                                 value=recvinfo.type)
                elif recvinfo.func == "bytes":
                    index1 = recvinfo.index[0]
                    index2 = recvinfo.index[1]
                    final_payload_content += r"p.recv()[{index1}:{index2}]".format(
                         index1=index1, index2=index2
                    )
                    final_payload_content += "\n"
                else:
                    log.Exception("not found the function")
        return final_payload_content

    def RemoveRemainedInfo(self):
        """
        after we generate a full payload, we need to remove the
        information of bases, and for another process's use
        1. sub the base_address in payload element
        2. remove the base information in this single payload
        :return: None
        """
        self.ReverseAdjustContent()
        self.RemoveBases()

    def GeneratePayloadInFile(self):
        """
        this fucntion is used for generated the final payload in file
        :return:
        """
        if self.inargv or self.infile:
            return ""
        final_payload_content = ""
        if self.GetContentLength() != 0:
            self.ParseAdjustInfo()
            if self.prefixlength != 0:
                final_payload_content += "payload = "
                if b"\x00" not in self.avoidchars:
                    final_payload_content += r'b"\x00" * {length}'.format(
                        length=self.prefixlength)
                else:
                    final_payload_content += r'b"a" * {length}'.format(
                        length=self.prefixlength)
            else:
                final_payload_content += r'payload = b""'
            final_payload_content += "\n"
            final_payload_content += "payload += "
            if not self.needadjust:
                final_payload_content += self.GeneratePayloadInFileNoAdjust()
            else:
                final_payload_content += self.GeneratePayloadInFileNeedAdjust()
            final_payload_content += "\n"
            final_payload_content += "p.send(payload)\n"
        if self.needrecv:
            final_payload_content += self.GeneratePayloadInFileAboutRecv()
        return final_payload_content

