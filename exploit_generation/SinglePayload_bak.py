"""
author : 4everdestiny
create_time : 2022.3.9
description : this is the code to generate a single payload
in different scenes, we need different payload, for example:
1. read(0, &buf, 0x100), we need a 0x100 length payload
2. gets(&buf), we need a \n in the payload
3. strcpy(&buf, &name), avoid chars is \n
4. scanf("%s", &name), avoid chars are
5. also we need some prefix in stackoverflow vulnerability
6. also we need some recv information after send payload
input : payload need option
output : the final payload
"""

from log import log
from pwn import p64
from exploit_generation.RecvInfo import RecvInfo
log = log.Log()
import base64

class SinglePayload:
    def __init__(self, content="", length=0x10, needline=False,
                 avoidchars=b"\n", needadjust=False, prefixlength=0
                 ):
        """
        init function
        :param content: content for the original payload you want
        :param length: length for the length of payload you want
        :param needline: if you need \n in the end of payload, this is True
        :param avoidchars: in gets function, avoidchars is "\n", etc.
        :param prefixlength: prefix for the offset of payload, especially used if stack overflow
        """
        self.length = length
        self.needline = needline
        self.content = content
        self.avoidchars = avoidchars
        self.payload = b""
        # prefix length is used in stack overflow vulnerability
        # for the offseet used in payload
        self.prefixlength = prefixlength
        # for the recv info payload
        self.needadjust = needadjust
        if self.needadjust:
            self.originalcontent = content[:]
        self.adjustlist = {"heap_base": [], "libc_base": [], "elf_base": [], "canary": []}
        self.adjustinfo = ["heap_base", "libc_base", "elf_base", "canary"]
        self.recvtypes = ["heap_base", "libc_base", "elf_base", "canary"]
        self.needrecv = False
        self.recvinfo = []
        self.heap_base = 0
        self.libc_base = 0
        self.elf_base = 0
        self.canary = 0
        # maybe need need prefix and recv options

    def GeneratePayload(self):
        """
        this function is used to generate the payload according to the options
        :return: None
        """
        self.payload = b""
        if self.prefixlength != 0:
            if b"\x00" not in self.avoidchars:
                self.payload += b"\x00" * self.prefixlength
            else:
                self.payload += b"a" * self.prefixlength
        if self.needadjust:
            self.AdjustContent()
            self.payload += b"".join(map(p64, self.content))
        else:
            self.payload += self.content
        if len(self.payload) < self.length:
            self.payload = self.payload.ljust(self.length, b"\x00")
        elif len(self.payload) == self.length:
            pass
        else:
            log.Exception("the payload's length is longer than excepted, may cause some error")
        if self.needline:
            self.payload += b"\n"
        if self.CheckPayload():
            return self.payload
        else:
            log.Exception("there are some avoid chars in payload, please check it")
            return self.payload

    def GetPayload(self):
        """
        return self.payload
        :return: the final payload
        """
        self.GeneratePayload()
        return self.payload

    def CheckPayload(self):
        """
        this function
        :param payload:
        :return:
        """
        for x in self.avoidchars:
            if x in self.payload:
                return False
        return True

    def GetContent(self):
        """
        get the content of payload
        :return: the content of payload
        """
        return self.content

    def CheckBaseInfo(self):
        """
        check all the base info needed
        :return: True when pass check, False when not pass
        """
        if len(self.adjustlist["heap_base"]) != 0 and self.heap_base == 0:
            log.Exception("need heap_base first, check it")
            return False
        if len(self.adjustlist["libc_base"]) != 0 and self.libc_base == 0:
            log.Exception("need libc_base first, check it")
            return False
        if len(self.adjustlist["elf_base"]) != 0 and self.elf_base == 0:
            log.Exception("need elf_base first, check it")
            return False
        if len(self.adjustlist["canary"]) != 0 and self.canary == 0:
            log.Exception("need canary first, check it")
            return False
        return True

    def AdjustContent(self):
        """
        if some payload need base info, here we should use these base info
        to adjust payload
        :return: True when check base info success, False some thing error
        """
        if not self.CheckBaseInfo():
            log.Exception("need base info frist")
            return False
        else:
            # here we need a list type content
            for index in self.adjustlist["heap_base"]:
                self.content[index] = self.originalcontent[index] + self.heap_base
            for index in self.adjustlist["libc_base"]:
                self.content[index] = self.originalcontent[index] + self.libc_base
            for index in self.adjustlist["elf_base"]:
                self.content[index] = self.originalcontent[index] + self.elf_base
            for index in self.adjustlist["canary"]:
                self.content[index] = self.originalcontent[index] + self.canary
            return True

    def AddAdjustList(self, type="heap_base", indexs=[]):
        """
        change the addjustlist list info
        :param type: the base info needed
        :param indexs: the indexs need to adjust
        :return: None
        """
        if type in self.adjustlist.keys():
            for i in range(len(indexs)):
                self.adjustlist[type].append(indexs[i])
        else:
            log.Exception("type error for adjust list")
        return None

    def AddRecvInfo(self, type="heap_base", recv_index=[0, 6], func="u64", adjustoffset=0):
        """
        add the recv info to the payload
        :param type: heapbase or libc_base or elf_base
        :param recv_index: the index of the recv information
        :param func: u64, int, etc.
        :return: None
        """
        self.needrecv = True
        recv_types = ["libc_base", "heap_base", "elf_base", "canary"]
        func_types = ["u64", "int16"]
        if type in recv_types:
            if func in func_types:
                self.needrecv = True
                self.recvinfo.append(RecvInfo(
                    type=type, index=recv_index, func=func, adjustoffset=adjustoffset
                ))
            else:
                log.Exception("not found type in funcs, check the code")
        else:
            log.Exception("not found type in recv_types, check the code")

    def ChangeBases(self, type="heap_base", value=0):
        """
        change the bases info in payload
        :return: None
        """
        recv_types = ["libc_base", "heap_base", "elf_base"]
        if type not in recv_types:
            log.Exception("not found type, check it")
            return None
        if type == "heap_base":
            self.heap_base = value
        if type == "libc_base":
            self.libc_base = value
        if type == "elf_base":
            self.elf_base = value

    def SetContent(self, content=b"", change_length=True):
        """
        set the payload's content, for in format string vulnerability,
        we cannot know the final content,
        we must know canary or code_base or libc_base
        :param change_length: if set True, change the payload
        length using the content's length
        if not, don't change the length
        :return: None
        """
        self.content = content
        if change_length:
            self.length = len(content)
        else:
            pass

    def __str___bak(self):
        """
        this function is used for generate a final payload in file
        so if the payload need adjust, we must generate a string like payload
        :return: a string payload
        """
        if not self.needadjust:
            """
            base64_encode_payload = base64.b64encode(self.GetPayload())
            payload = "payload = base64.b64decode({encode_payload})".format(
                encode_payload=base64_encode_payload)
            """
            payload = r"payload = {payload}".format(payload=self.GetPayload())
            return payload
        payload = ""
        if self.prefixlength != 0:
            if b"\x00" not in self.avoidchars:
                payload += "\x00" * self.prefixlength
            else:
                payload += "a" * self.prefixlength
        if self.needadjust:
            if type(self.content) == list:
                for i in range(len(self.content)):
                    if i != 0:
                        payload += " + "
                    needadjust = False
                    for info in self.adjustinfo:
                        if info in self.adjustlist.keys():
                            if i in self.adjustlist[info]:
                                needadjust = True
                                payload += "p64({info} + {value})".format(
                                    info=info, value=hex(self.originalcontent[i]))
                    if not needadjust:
                        payload += "p64({value})".format(value=hex(self.originalcontent[i]))
        if len(payload) < self.length:
            payload = payload.ljust(self.length, "\x00")
        elif len(self.payload) == self.length:
            pass
        else:
            log.Exception("the payload's length is longer than excepted, may cause some error")
        if self.needline:
            payload += "\n"
        final_payload_string = "payload = {payload}\n".format(payload=payload)
        return final_payload_string

    def __str__(self):
        """
        newly __str__ function for print payload
        this function is used for generate a final payload in file
        so if the payload need adjust, we must generate a string like payload
        :return: a payload information for debug
        """
        final_content = "=" * 10 + "single_payload_begin" + "=" * 10 + "\n"
        for i in range(len(self.content)):
            payloadelement = self.content[i]
            content = payloadelement.content
            type_ = payloadelement.type
            final_content += f"{i}:{type_}:{content}"
            final_content += "\n"
        final_content += "=" * 10 + "single_payload_end" + "=" * 10 + "\n"
        return final_content

    def GeneratePayloadInFile(self):
        """
        this fucntion is used for generated the final payload in file
        :return:
        """
        pass