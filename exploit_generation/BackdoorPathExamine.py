"""
author : 4everdestiny
create_time : 2023.7.10
description : this is the code to find a path towards backdoor
input : binary path
output : if have backdoor try to find the path to backdoor
"""

from global_func.BackDoorFinder import BackDoorFinder
import angr
from log.log import Log
from exploit_generation.PayloadList import PayloadList
from exploit_generation.PayloadElement import PayloadElement
from exploit_generation.SinglePayload import SinglePayload
from state.FormatStringStateLog import FormatStringStateLog
from state.FormatStringStateLog import SingleFormatStringStateLog
from fuzz.Fuzzer import Fuzzer
from global_func.FuzzerHelper import FuzzerHelper
import sys


log = Log()


class BackdoorPathExamine:
    def __init__(self, binary_path="", function_helper=None, protection=None):
        self.binary_path = binary_path
        self.backdoors = {}
        self.protection = protection
        #self.project = angr.Project(self.binary_path)
        self.binary_static = self.protection["static"]
        self.function_helper = function_helper
        self.payloadlist = []
        self.project = None
        self.state = None
        self.statelog = []
        self.formatstringstatelog = FormatStringStateLog()
        self.BP = []
        self.NewProject()

    def FindBackdoor(self):
        """
        use BackdoorFinder to find the backdoor
        :return: the backdoor find in this binary
        """
        backdoorfinder = BackDoorFinder(
            binary_path=self.binary_path, function_helper=self.function_helper
        )
        backdoors = backdoorfinder.AnalyseBackdoor()
        if backdoors is None:
            return False
        else:
            if len(backdoors) == 0:
                return False
            self.backdoors = backdoors
            return True

    def NewProject(self):
        self.project = angr.Project(self.binary_path, auto_load_libs=True)
        if self.protection["static"]:
            self.binary_static = True
        else:
            self.binary_static = False
        if not self.binary_static:
            self.state = self.project.factory.entry_state(
                remove_options={angr.options.ALL_FILES_EXIST,
                                angr.options.LAZY_SOLVES,
                                angr.options.ZERO_FILL_UNCONSTRAINED_MEMORY,
                                angr.options.ZERO_FILL_UNCONSTRAINED_REGISTERS},
                args=[self.project.filename]
            )
        else:
            # self.HookForStaticBinary()
            fuzzerhelper = FuzzerHelper(
                binary_path=self.binary_path, function_helper=self.function_helper
            )
            fuzzerhelper.HookForStaticBinary(
                project=self.project, protection=self.protection
            )
            self.state = self.project.factory.entry_state(
                remove_options={angr.options.ALL_FILES_EXIST,
                                angr.options.LAZY_SOLVES},
                args=[self.project.filename]
            )

    def FindSingleBackdoorPath(self, state):
        """
        call this func when find a path to backdoor
        :param state: the current state
        :return: None
        """
        if not state.satisfiable():
            log.info("but the state cannot be satisfied in FindSingleBackdoorPath")
            return
        #state.solver.eval(state.solver.constraints)
        payload_string = state.posix.dumps(sys.stdin.fileno())
        if len(payload_string) == 0:
            log.Exception("input is emptry, an error constraints in FindSingleBackdoorPath")
            return
        log.success("find a path to backdoor in FindSingleBackdoorPath")
        payload = [PayloadElement(
            datavalue=payload_string, adjustinfo=None, datatype="bytes")]
        singelpayload = SinglePayload(
            content=payload, length=len(payload_string),
            prefixlength=0
        )
        temp_payloadlist = PayloadList()
        temp_payloadlist.AppendPayload(singelpayload)
        self.payloadlist.append(temp_payloadlist)
        self.statelog.append(state.copy())

    def PrintfCond(self, state):
        """
        finish the printf function's condition, if it is a printf function call
        call check of read, and then check the stack overflow vulnerability.
        :param state: the current state to check
        :return: return True when it is a printf call, False when not
        """
        printf_address = self.function_helper.GetFunctionAddress(func_name="printf", use_deep_find=True)
        if printf_address is None:
            # log.Exception("no printf in this binary, no meaning for this action")
            return False
        # print(obj.plt.keys())
        if state.arch.name == "X86":
            if state.solver.eval(state.regs.eip) == printf_address:
                return True
            else:
                return False
        elif state.arch.name == "AMD64":
            if state.solver.eval(state.regs.rip) == printf_address:
                return True
            else:
                return False
        return False

    def RemoveBreakpoints(self, state=None):
        """
        we need to remove all the breakpoints for next running in stack overflow check
        :param state: the state needed to remove breakpoints
        :return: None
        """
        if state is None:
            log.Exception("parameter state error")
            return False
        for BP in self.BP:
            event_type = BP[0]
            bp = BP[1]
            state.inspect.remove_breakpoint(event_type=event_type, bp=bp)

    def FormatStringCheck(self, state):
        """
        check the printf func to judge whether there is a format string Vulnerability
        check stack/heap format string?(finished)
        :param state: the angr state
        :return: print the info, and none return
        True when have fmt, False when not
        """
        if state.arch.name == "AMD64":
            call_address = state.solver.eval(state.mem[state.regs.rsp].int64_t.resolved) - 5
            log.info("call_addr:" + hex(call_address))
            log.info("fmt_rdi_symbolic:" + str(state.regs.rdi.symbolic))
            if state.regs.rdi.symbolic == True:
                log.info("printf function rdi is symbolic")
                log.Exception("format string rdi is symbolic")
                return False
            else:
                rdi = state.solver.eval(state.regs.rdi)
                max_length = 0
                single_size = 4
                for length in range(0, 0x100, single_size):
                    format_string = state.memory.load(rdi + length, single_size)
                    if format_string.symbolic:
                        max_length += single_size
                    else:
                        break
                if max_length >= 1:
                    log.success("find a symbolic format string")
                    log.success("call_addr:" + hex(state.solver.eval(state.mem[state.regs.rsp].int64_t.resolved) - 5))
                    log.success("max format string length:" + hex(max_length))
                    copystate = state.copy()
                    self.RemoveBreakpoints(state=copystate)
                    statelog = SingleFormatStringStateLog(
                        state=copystate, formatstringlength=max_length, project=self.project
                    )
                    self.formatstringstatelog.insert(statelog=statelog)
                    # canary_leak_can = self.UseFmtLeakCanary(state)
                    log.info("try to avoid this error")
                    copystate = state.copy()
                    rdi = copystate.solver.eval(copystate.regs.rdi)
                    payload = "aaa\x00"
                    constrained_parameter_address = rdi
                    constrained_parameter_size_bytes = len(payload)
                    constrained_parameter_bitvector = state.memory.load(
                        constrained_parameter_address,
                        constrained_parameter_size_bytes
                    )
                    constrained_parameter_desired_value = payload
                    constraint_expression = constrained_parameter_bitvector == constrained_parameter_desired_value
                    copystate.add_constraints(constraint_expression)
                    if copystate.satisfiable():
                        state.add_constraints(constraint_expression)
                        log.success(
                            "have avoided a format string Vulnerability in {address}".format(
                                address=hex(call_address)))
                        return True
                    return True
                else:
                    log.info("this printf function's format string is stable")
                    log.info("not useful for format string Vulnerability")
                    return False
        elif state.arch.name == "X86":
            call_address = state.solver.eval(state.mem[state.regs.esp].int.resolved) - 5
            log.info("call_addr:" + hex(call_address))
            par1 = state.mem[state.regs.esp + 4].int.resolved
            log.info("fmt_par1_symbolic:" + str(par1.symbolic))
            if par1.symbolic == True:
                log.info("printf function's parameter1 is symbolic")
                log.Exception("format string is symbolic")
                return False
            else:
                par1 = state.solver.eval(par1)
                max_length = 0
                single_size = 4
                for length in range(0, 0x100, single_size):
                    format_string = state.memory.load(par1 + length, single_size)
                    if format_string.symbolic:
                        max_length += single_size
                    else:
                        break
                if max_length >= 1:
                    log.success("find a symbolic format string")
                    log.success("call_addr:" + hex(state.solver.eval(state.mem[state.regs.esp].int.resolved) - 5))
                    log.success("maybe max format string length:" + hex(max_length))
                    copystate = state.copy()
                    self.RemoveBreakpoints(state=copystate)
                    statelog = SingleFormatStringStateLog(
                        state=copystate, formatstringlength=max_length, project=self.project
                    )
                    self.formatstringstatelog.insert(statelog=statelog)
                    # canary_leak_can = self.UseFmtLeakCanary(state)
                    log.info("try to avoid this error")
                    copystate = state.copy()
                    rdi = copystate.solver.eval(copystate.regs.rdi)
                    payload = "aaa\x00"
                    constrained_parameter_address = rdi
                    constrained_parameter_size_bytes = len(payload)
                    constrained_parameter_bitvector = state.memory.load(
                        constrained_parameter_address,
                        constrained_parameter_size_bytes
                    )
                    constrained_parameter_desired_value = payload
                    constraint_expression = constrained_parameter_bitvector == constrained_parameter_desired_value
                    copystate.add_constraints(constraint_expression)
                    if copystate.satisfiable():
                        state.add_constraints(constraint_expression)
                        log.success(
                            "have avoided a format string Vulnerability in {address}".format(
                                address=hex(call_address)))
                        return True
                    return True
                else:
                    log.info("this printf function's format string is stable")
                    log.info("not useful for format string Vulnerability")
                    return False

    def InitCheckFmtBreakpoints(self):
        BP = self.state.inspect.b("call", when=angr.BP_BEFORE, condition=self.PrintfCond, action=self.FormatStringCheck)
        self.BP.append(["call", BP])

    def FindPathTowardsBackdoor(self, stepcount=0x1000):
        """
        find the path towards backdoor
        :param stepcount: the stepcount for the fuzzer to find backdoor
        :return: True when find, False when not
        """
        if not self.FindBackdoor():
            log.info("cannot find backdoor inside this binary")
            return False
        print(self.backdoors)
        for backdoor in self.backdoors:
            self.project.hook(backdoor["backdoortarget"], hook=self.FindSingleBackdoorPath)
        self.InitCheckFmtBreakpoints()
        self.fuzzer = Fuzzer(
            binarypath=self.binary_path, project=self.project,
            state=self.state)
        self.fuzzer.run(stepcount=stepcount)
        for backdoor in self.backdoors:
            if self.project.is_hooked(backdoor["backdoortarget"]):
                self.project.unhook(backdoor["backdoortarget"])

    def BackdoorMain(self, stepcount=0x1000):
        """
        the main function for find the backdoor
        :return: True when find, False when not
        """
        self.FindPathTowardsBackdoor(stepcount=stepcount)
        if len(self.payloadlist) == 0:
            return False
        else:
            return True


if __name__ == '__main__':
    binary_path = "../binaries/binaries_for_paper/mips/00-hello-pwn/00-hello-pwn"
    backdoorpathexamine = BackdoorPathExamine(binary_path=binary_path)
    #print(backdoorpathexamine.FindBackdoor())
    backdoorpathexamine.FindPathTowardsBackdoor()