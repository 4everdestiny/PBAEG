"""
author : 4everdestiny
create_time : 2022.3.9
description : this is the code to generate a single payload
in different scenes, we need different payload, for example:
1. read(0, &buf, 0x100), we need a 0x100 length payload
2. gets(&buf), we need a \n in the payload
3. strcpy(&buf, &name), avoid chars is \n
4. scanf("%s", &name), avoid chars are
5. also we need some prefix in stackoverflow vulnerability
6. also we need some recv information after send payload
input : payload need option
output : the final payload
"""

import pwn
from log import log
log = log.Log()
import time


class PayloadList:
    def __init__(self):
        self.payloadlist = []
        self.bases = {"heap_base": 0, "libc_base": 0, "elf_base": 0, "canary": 0}

    def AppendPayload(self, payload):
        """
        append a payload into the lost
        :param payload: the struct of SinglePayload
        :return: None
        """
        self.payloadlist.append(payload)

    def GetContent(self):
        """
        return the whole content of payloads
        :return: the whole payload
        """
        finalpayload = b""
        for i in range(len(self.payloadlist)):
            finalpayload += self.payloadlist[i].GetPayload()
        return finalpayload

    def GetList(self):
        """
        return the payload list
        :return: payload list
        """
        return self.payloadlist

    def MergePayloadList(self, payloadlist=None):
        """
        merge another payload list
        just add all the payload in payload list to this payloadlist
        :param payloadlist: another payloadlist to merge
        :return: None return, just add all the payload
        """
        for payload in payloadlist.GetList():
            self.payloadlist.append(payload)

    def CheckPayloadWithProcess(self, process=None):
        for payloadlistindex in range(len(self.payloadlist)):
            singlepayload = self.payloadlist[payloadlistindex]
            #process.recv()
            if singlepayload.GetContentLength() != 0 and not singlepayload.inargv and \
                    not singlepayload.infile:
                process.send(singlepayload.GetPayload())
                time.sleep(1)
            if singlepayload.needrecv:
                for recvinfo in singlepayload.recvinfo:
                    if type(recvinfo.index[1]) != int:
                        # here, info use byte to truncate
                        info = process.recvuntil(recvinfo.index[1], drop=True)
                    else:
                        info = process.recv()[:recvinfo.index[1]]
                    if recvinfo.func == "u64":
                        index1 = recvinfo.index[0]
                        value = pwn.u64(info[index1:].ljust(8, b"\x00"))
                        base_value = value + recvinfo.adjustoffset
                        self.bases[recvinfo.type] = base_value
                        log.success("{base_info}:{value}".format(
                            base_info=recvinfo.type, value=hex(base_value))
                        )
                    elif recvinfo.func == "u32":
                        index1 = recvinfo.index[0]
                        value = pwn.u32(info[index1:].ljust(4, b"\x00"))
                        base_value = value + recvinfo.adjustoffset
                        self.bases[recvinfo.type] = base_value
                        log.success("{base_info}:{value}".format(
                            base_info=recvinfo.type, value=hex(base_value))
                        )
                    elif recvinfo.func == "int16":
                        index1 = recvinfo.index[0]
                        value = int(info[index1:], 16)
                        base_value = value + recvinfo.adjustoffset
                        self.bases[recvinfo.type] = base_value
                        log.success("{base_info}:{value}".format(
                            base_info=recvinfo.type, value=hex(base_value))
                        )
                    elif recvinfo.func == "bytes":
                        pass
                for adjustindex in range(payloadlistindex + 1, len(self.payloadlist)):
                    singlepayload = self.payloadlist[adjustindex]
                    for x in singlepayload.adjustinfolist:
                        singlepayload.ChangeBases(basetype=x, basevalue=self.bases[x])

    def CheckEmpty(self):
        """
        if this payloadlist is empty, return True, else return False
        :return: True when empty, False when not
        """
        if len(self.payloadlist) == 0:
            return True
        else:
            return False
