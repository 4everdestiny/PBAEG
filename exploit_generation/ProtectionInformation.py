"""
author : 4everdestiny
create_time : 2022.3.2
description : this is the code to collect the protection mechanism in a binary
input : binary path
output : a struct contains all the binary protection information
"""

import pwn
from log import log
import subprocess
import angr
log = log.Log()


class ProtectionInformation:
    def __init__(self, binarypath):
        self.binarypath = binarypath
        self.protection = {}
        self.protection["RELRO"] = "NO"
        self.protection["Canary"] = True
        self.protection["NX"] = True
        self.protection["PIE"] = True
        self.protection["arch"] = "i386"
        self.protection["bits"] = "32"
        self.protection["endian"] = "little"
        self.protection["static"] = True
        self.protection["stripped"] = False
        self.ParseProtection()

    def ParseProtection(self):
        """
        parse all the protection mechanism in this binary
        :return: None if no binary found, else return all the information
        """
        try:
            binary_elf = pwn.ELF(self.binarypath, checksec=False)
        except:
            log.Exception("No such file or directory in ProtectionInfomation.py")
            return None
        # print(binary_elf.canary)
        result_lines = ""
        # parse for relro
        self.protection["RELRO"] = binary_elf.relro
        # parse for canary
        self.protection["Canary"] = binary_elf.canary
        # parse for NX
        self.protection["NX"] = not binary_elf.execstack
        # parse for PIE
        self.protection["PIE"] = binary_elf.pie
        # parse for arch and bits and endian
        self.protection["arch"] = binary_elf.arch
        self.protection["endian"] = binary_elf.endian
        self.protection["bits"] = binary_elf.bits
        # parse for the static or not
        self.protection["static"] = binary_elf.statically_linked
        """
        static_information = subprocess.getoutput("ldd {binarypath}".format(binarypath=self.binarypath))
        if "not a dynamic executable" in static_information:
            self.protection["static"] = True
        else:
            self.protection["static"] = False
        """
        if self.protection["static"] == True:
            # self.protection["Canary"] = False
            self.protection["Canary"] = self.ParseCanaryForStatic()
        self.protection["RELRO"] = binary_elf.relro
        if "__libc_start_main" not in binary_elf.symbols.keys():
            self.protection["stripped"] = True
        return self.protection

    def ParseCanaryForStatic(self):
        """
        parse the static binary canary information
        :return: True when canary enable, False when canary not
        """
        # print("here")
        proj = angr.Project(self.binarypath)
        main_symbol = proj.loader.main_object.get_symbol("main")
        if main_symbol is None:
            return False
        main_address = main_symbol.linked_addr
        function_address = main_address
        block = proj.factory.block(addr=main_address)
        code = block.disassembly.__str__()
        if self.protection["arch"] == "i386":
            for _ in range(0x100):
                if "gs:[0x14]" not in code:
                    function_address += block.size
                    if function_address >= main_address + main_symbol.size:
                        break
                    block = proj.factory.block(function_address)
                    code = block.disassembly.__str__()
                    continue
                else:
                    return True
            return False
        elif self.protection["arch"] == "amd64":
            for _ in range(0x100):
                if "fs:[0x28]" not in code:
                    function_address += block.size
                    if function_address >= main_address + main_symbol.size:
                        break
                    block = proj.factory.block(function_address)
                    code = block.disassembly.__str__()
                    continue
                else:
                    return True
            return False
        elif self.protection["arch"] == "mips":
            for _ in range(0x100):
                if "$gp" not in code:
                    function_address += block.size
                    if function_address >= main_address + main_symbol.size:
                        break
                    block = proj.factory.block(function_address)
                    code = block.disassembly.__str__()
                    continue
                else:
                    return True
            return False
        return True

    def GetProtection(self):
        """
        :return: return the protection information
        """
        return self.protection

    def __str__(self):
        return self.protection.__str__()


if __name__ == '__main__':
    binarypath = "../binaries/binaries_for_paper/mips/00-hello-pwn/00-hello-pwn"
    #binarypath = "../binaries/32bit/stack_overflow/static/test1/static_test1"
    ProtectionInformation = ProtectionInformation(binarypath)
    ProtectionInformation.ParseProtection()
    print(ProtectionInformation)